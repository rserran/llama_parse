// This file is auto-generated by @hey-api/openapi-ts

export type AdvancedModeTransformConfig = {
  mode?: "advanced";
  /**
   * Configuration for the segmentation.
   */
  segmentation_config?:
    | NoneSegmentationConfig
    | PageSegmentationConfig
    | ElementSegmentationConfig;
  /**
   * Configuration for the chunking.
   */
  chunking_config?:
    | NoneChunkingConfig
    | CharacterChunkingConfig
    | TokenChunkingConfig
    | SentenceChunkingConfig
    | SemanticChunkingConfig;
};

/**
 * API Result for a single agent data item
 */
export type AgentData = {
  id?: string | null;
  deployment_name: string;
  project_id?: string | null;
  collection?: string;
  data: {
    [key: string]: unknown;
  };
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * API request model for creating agent data
 */
export type AgentDataCreate = {
  deployment_name: string;
  collection?: string;
  data: {
    [key: string]: unknown;
  };
};

/**
 * API request model for updating agent data
 */
export type AgentDataUpdate = {
  data: {
    [key: string]: unknown;
  };
};

/**
 * API Result for a single group in the aggregate response
 */
export type AggregateGroup = {
  group_key: {
    [key: string]: unknown;
  };
  count?: number | null;
  first_item?: {
    [key: string]: unknown;
  } | null;
};

/**
 * API request body for aggregating agent data
 */
export type AggregateRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: {
    [key: string]: FilterOperation;
  } | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
  /**
   * The agent deployment's name to aggregate data for
   */
  deployment_name: string;
  /**
   * The logical agent data collection to aggregate data for
   */
  collection?: string;
  /**
   * The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations
   */
  group_by?: Array<string> | null;
  /**
   * Whether to count the number of items in each group
   */
  count?: boolean | null;
  /**
   * Whether to return the first item in each group (Sorted by created_at)
   */
  first?: boolean | null;
  /**
   * The offset to start from. If not provided, the first page is returned
   */
  offset?: number | null;
};

export type ApplyStatusDetails = {
  /**
   * Status of the apply process (file updates and deletions)
   */
  status?: "pending" | "processing" | "completed" | "failed";
  effective_at?: string;
  /**
   * The job record ID associated with this status, if any.
   */
  job_record_id?: string | null;
  /**
   * Error message for the latest job attempt, if any.
   */
  error_message?: string | null;
};

export type AutoTransformConfig = {
  mode?: "auto";
  /**
   * Chunk size for the transformation.
   */
  chunk_size?: number;
  /**
   * Chunk overlap for the transformation.
   */
  chunk_overlap?: number;
};

export type AzureOpenAiEmbedding = {
  /**
   * The name of the OpenAI embedding model.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Additional kwargs for the OpenAI API.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  /**
   * The OpenAI API key.
   */
  api_key?: string | null;
  /**
   * The base URL for Azure deployment.
   */
  api_base?: string;
  /**
   * The version for Azure OpenAI API.
   */
  api_version?: string;
  /**
   * Maximum number of retries.
   */
  max_retries?: number;
  /**
   * Timeout for each request.
   */
  timeout?: number;
  /**
   * The default headers for API requests.
   */
  default_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
   */
  reuse_client?: boolean;
  /**
   * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
   */
  dimensions?: number | null;
  /**
   * The Azure endpoint to use.
   */
  azure_endpoint?: string | null;
  /**
   * The Azure deployment to use.
   */
  azure_deployment?: string | null;
  class_name?: string;
};

export type AzureOpenAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "AZURE_EMBEDDING";
  /**
   * Configuration for the Azure OpenAI embedding model.
   */
  component?: AzureOpenAiEmbedding;
};

/**
 * Status of an individual file in a batch job.
 */
export type BatchFileStatus =
  | "pending"
  | "processing"
  | "completed"
  | "failed"
  | "skipped"
  | "cancelled";

/**
 * Status of an individual file in a batch job.
 */
export const BatchFileStatus = {
  PENDING: "pending",
  PROCESSING: "processing",
  COMPLETED: "completed",
  FAILED: "failed",
  SKIPPED: "skipped",
  CANCELLED: "cancelled",
} as const;

/**
 * Detailed information about an item in a batch job.
 */
export type BatchItemDetail = {
  /**
   * Processing status of this item
   */
  status: BatchFileStatus;
  effective_at?: string;
  /**
   * The job record ID associated with this status, if any.
   */
  job_record_id?: string | null;
  /**
   * Error message for the latest job attempt, if any.
   */
  error_message?: string | null;
  /**
   * ID of the item
   */
  item_id: string;
  /**
   * Name of the item
   */
  item_name: string;
  /**
   * Job ID for the underlying processing job (links to parse/extract job results)
   */
  job_id?: string | null;
  /**
   * Reason item was skipped (e.g., 'already_processed', 'size_limit_exceeded')
   */
  skip_reason?: string | null;
  /**
   * When processing started for this item
   */
  started_at?: string | null;
  /**
   * When processing completed for this item
   */
  completed_at?: string | null;
};

/**
 * Paginated response containing batch job item details.
 */
export type BatchItemListResponse = {
  /**
   * List of item details
   */
  items?: Array<BatchItemDetail>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Request to cancel a running batch job.
 */
export type BatchJobCancelRequest = {
  /**
   * Optional reason for cancelling the job
   */
  reason?: string | null;
};

/**
 * Response after cancelling a batch job.
 */
export type BatchJobCancelResponse = {
  /**
   * ID of the cancelled job
   */
  job_id: string;
  /**
   * New status (should be 'cancelled')
   */
  status: BatchJobStatus;
  /**
   * Number of items processed before cancellation
   */
  processed_items: number;
  /**
   * Confirmation message
   */
  message: string;
};

/**
 * Request to create a batch processing job.
 *
 * Supports two modes:
 * 1. Directory mode: Process all files in a directory (use directory_id)
 * 2. Item list mode: Process specific items (use item_ids). Project must be provided via validate_project dependency.
 */
export type BatchJobCreateRequest = {
  /**
   * ID of the directory containing files to process
   */
  directory_id?: string | null;
  /**
   * List of specific item IDs to process. Either this or directory_id must be provided.
   */
  item_ids?: Array<string> | null;
  /**
   * Job configuration for batch processing. Can be BatchParseJobRecordCreate or ClassifyJob.
   */
  job_config: BatchParseJobRecordCreate | ClassifyJob;
  /**
   * Number of files to fetch per batch from the directory (only used in directory mode)
   */
  page_size?: number;
  /**
   * Maximum number of files to process before calling continue-as-new. If None, continue-as-new is called after every batch. (only used in directory mode)
   */
  continue_as_new_threshold?: number | null;
};

/**
 * Response schema for paginated batch job queries.
 */
export type BatchJobQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<BatchJobResponse>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Response schema for a batch processing job.
 */
export type BatchJobResponse = {
  /**
   * Current status of the job
   */
  status: BatchJobStatus;
  effective_at?: string;
  /**
   * The job record ID associated with this status, if any.
   */
  job_record_id?: string | null;
  /**
   * Error message for the latest job attempt, if any.
   */
  error_message?: string | null;
  /**
   * Unique identifier for the batch job
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Project this job belongs to
   */
  project_id: string;
  /**
   * Directory being processed
   */
  directory_id?: string | null;
  /**
   * Type of processing operation
   */
  job_type: BatchJobType;
  /**
   * Total number of items in the job
   */
  total_items: number;
  /**
   * Number of items processed so far
   */
  processed_items?: number;
  /**
   * Number of items that failed processing
   */
  failed_items?: number;
  /**
   * Number of items skipped (already processed or size limit)
   */
  skipped_items?: number;
  /**
   * Temporal workflow ID for this batch job
   */
  workflow_id?: string | null;
  /**
   * Timestamp when job processing started
   */
  started_at?: string | null;
  /**
   * Timestamp when job completed
   */
  completed_at?: string | null;
};

/**
 * Status of a batch processing job.
 */
export type BatchJobStatus =
  | "pending"
  | "running"
  | "dispatched"
  | "completed"
  | "failed"
  | "cancelled";

/**
 * Status of a batch processing job.
 */
export const BatchJobStatus = {
  PENDING: "pending",
  RUNNING: "running",
  DISPATCHED: "dispatched",
  COMPLETED: "completed",
  FAILED: "failed",
  CANCELLED: "cancelled",
} as const;

/**
 * Detailed status response for a batch processing job.
 */
export type BatchJobStatusResponse = {
  job: BatchJobResponse;
  /**
   * Percentage of items processed (0-100)
   */
  progress_percentage: number;
};

/**
 * Type of batch processing operation.
 */
export type BatchJobType = "parse" | "extract" | "classify";

/**
 * Type of batch processing operation.
 */
export const BatchJobType = {
  PARSE: "parse",
  EXTRACT: "extract",
  CLASSIFY: "classify",
} as const;

/**
 * Generic parse job configuration for batch processing.
 *
 * This model contains the parsing configuration that applies to all files
 * in a batch, but excludes file-specific fields like file_name, file_id, etc.
 * Those file-specific fields are populated from DirectoryFile data when
 * creating individual ParseJobRecordCreate instances for each file.
 *
 * The fields in this model should be generic settings that apply uniformly
 * to all files being processed in the batch.
 */
export type BatchParseJobConfig = {
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  /**
   * The custom metadata to attach to the documents.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The resource info about the file
   */
  resource_info?: {
    [key: string]: unknown;
  } | null;
  languages?: Array<ParserLanguages>;
  parsing_instruction?: string | null;
  disable_ocr?: boolean | null;
  annotate_links?: boolean | null;
  adaptive_long_table?: boolean | null;
  compact_markdown_table?: boolean | null;
  disable_reconstruction?: boolean | null;
  disable_image_extraction?: boolean | null;
  invalidate_cache?: boolean | null;
  outlined_table_extraction?: boolean | null;
  aggressive_table_extraction?: boolean | null;
  merge_tables_across_pages_in_markdown?: boolean | null;
  output_pdf_of_document?: boolean | null;
  do_not_cache?: boolean | null;
  fast_mode?: boolean | null;
  skip_diagonal_text?: boolean | null;
  preserve_layout_alignment_across_pages?: boolean | null;
  preserve_very_small_text?: boolean | null;
  gpt4o_mode?: boolean | null;
  gpt4o_api_key?: string | null;
  do_not_unroll_columns?: boolean | null;
  extract_layout?: boolean | null;
  high_res_ocr?: boolean | null;
  html_make_all_elements_visible?: boolean | null;
  layout_aware?: boolean | null;
  specialized_chart_parsing_agentic?: boolean | null;
  specialized_chart_parsing_plus?: boolean | null;
  specialized_chart_parsing_efficient?: boolean | null;
  specialized_image_parsing?: boolean | null;
  precise_bounding_box?: boolean | null;
  line_level_bounding_box?: boolean | null;
  html_remove_navigation_elements?: boolean | null;
  html_remove_fixed_elements?: boolean | null;
  guess_xlsx_sheet_name?: boolean | null;
  page_separator?: string | null;
  bounding_box?: string | null;
  bbox_top?: number | null;
  bbox_right?: number | null;
  bbox_bottom?: number | null;
  bbox_left?: number | null;
  target_pages?: string | null;
  use_vendor_multimodal_model?: boolean | null;
  vendor_multimodal_model_name?: string | null;
  model?: string | null;
  vendor_multimodal_api_key?: string | null;
  page_prefix?: string | null;
  page_suffix?: string | null;
  webhook_url?: string | null;
  preset?: string | null;
  take_screenshot?: boolean | null;
  is_formatting_instruction?: boolean | null;
  premium_mode?: boolean | null;
  continuous_mode?: boolean | null;
  input_s3_path?: string | null;
  /**
   * The region for the input S3 bucket.
   */
  input_s3_region?: string | null;
  /**
   * If specified, llamaParse will save the output to the specified path. All output file will use this 'prefix' should be a valid s3:// url
   */
  output_s3_path_prefix?: string | null;
  /**
   * The region for the output S3 bucket.
   */
  output_s3_region?: string | null;
  project_id?: string | null;
  azure_openai_deployment_name?: string | null;
  azure_openai_endpoint?: string | null;
  azure_openai_api_version?: string | null;
  azure_openai_key?: string | null;
  input_url?: string | null;
  http_proxy?: string | null;
  auto_mode?: boolean | null;
  auto_mode_trigger_on_regexp_in_page?: string | null;
  auto_mode_trigger_on_text_in_page?: string | null;
  auto_mode_trigger_on_table_in_page?: boolean | null;
  auto_mode_trigger_on_image_in_page?: boolean | null;
  auto_mode_configuration_json?: string | null;
  structured_output?: boolean | null;
  structured_output_json_schema?: string | null;
  structured_output_json_schema_name?: string | null;
  max_pages?: number | null;
  max_pages_enforced?: number | null;
  extract_charts?: boolean | null;
  formatting_instruction?: string | null;
  complemental_formatting_instruction?: string | null;
  content_guideline_instruction?: string | null;
  spreadsheet_extract_sub_tables?: boolean | null;
  spreadsheet_force_formula_computation?: boolean | null;
  inline_images_in_markdown?: boolean | null;
  job_timeout_in_seconds?: number | null;
  job_timeout_extra_time_per_page_in_seconds?: number | null;
  strict_mode_image_extraction?: boolean | null;
  strict_mode_image_ocr?: boolean | null;
  strict_mode_reconstruction?: boolean | null;
  strict_mode_buggy_font?: boolean | null;
  save_images?: boolean | null;
  hide_headers?: boolean | null;
  hide_footers?: boolean | null;
  page_header_prefix?: string | null;
  page_header_suffix?: string | null;
  page_footer_prefix?: string | null;
  page_footer_suffix?: string | null;
  keep_page_separator_when_merging_tables?: boolean | null;
  ignore_document_elements_for_layout_detection?: boolean | null;
  output_tables_as_HTML?: boolean | null;
  internal_is_screenshot_job?: boolean | null;
  parse_mode?: ParsingMode | null;
  system_prompt?: string | null;
  system_prompt_append?: string | null;
  user_prompt?: string | null;
  page_error_tolerance?: number | null;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string | null;
  replace_failed_page_with_error_message_suffix?: string | null;
  markdown_table_multiline_header_separator?: string | null;
  tier?: string | null;
  version?: string | null;
  extract_printed_page_number?: boolean | null;
  type?: "parse";
  /**
   * The language.
   */
  lang?: string;
  /**
   * The output bucket.
   */
  outputBucket?: string | null;
  /**
   * The pipeline ID.
   */
  pipeline_id?: string | null;
};

/**
 * Batch-specific parse job record for batch processing.
 *
 * This model contains the metadata and configuration for a batch parse job,
 * but excludes file-specific information. It's used as input to the batch
 * parent workflow and combined with DirectoryFile data to create full
 * ParseJobRecordCreate instances for each file.
 *
 * Attributes:
 * job_name: Must be PARSE_RAW_FILE
 * partitions: Partitions for job output location
 * parameters: Generic parse configuration (BatchParseJobConfig)
 * session_id: Upstream request ID for tracking
 * correlation_id: Correlation ID for cross-service tracking
 * parent_job_execution_id: Parent job execution ID if nested
 * user_id: User who created the job
 * project_id: Project this job belongs to
 * webhook_url: Optional webhook URL for job completion notifications
 */
export type BatchParseJobRecordCreate = {
  job_name?: "parse_raw_file_job";
  /**
   * The partitions for this execution. Used for determining where to save job output.
   */
  partitions?: {
    [key: string]: string;
  };
  /**
   * The generic parse configuration for all files in the batch.
   */
  parameters?: BatchParseJobConfig | null;
  /**
   * The upstream request ID that created this job. Used for tracking the job across services.
   */
  session_id?: string | null;
  /**
   * The correlation ID for this job. Used for tracking the job across services.
   */
  correlation_id?: string | null;
  /**
   * The ID of the parent job execution.
   */
  parent_job_execution_id?: string | null;
  /**
   * The ID of the user that created this job
   */
  user_id?: string | null;
  /**
   * The ID of the project this job belongs to.
   */
  project_id?: string | null;
  /**
   * The URL that needs to be called at the end of the parsing job.
   */
  webhook_url?: string | null;
};

export type BedrockEmbedding = {
  /**
   * The modelId of the Bedrock model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * The name of aws profile to use. If not given, then the default profile is used.
   */
  profile_name?: string | null;
  /**
   * AWS Access Key ID to use
   */
  aws_access_key_id?: string | null;
  /**
   * AWS Secret Access Key to use
   */
  aws_secret_access_key?: string | null;
  /**
   * AWS Session Token to use
   */
  aws_session_token?: string | null;
  /**
   * AWS region name to use. Uses region configured in AWS CLI if not passed
   */
  region_name?: string | null;
  /**
   * The maximum number of API retries.
   */
  max_retries?: number;
  /**
   * The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.
   */
  timeout?: number;
  /**
   * Additional kwargs for the bedrock client.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  class_name?: string;
};

export type BedrockEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "BEDROCK_EMBEDDING";
  /**
   * Configuration for the Bedrock embedding model.
   */
  component?: BedrockEmbedding;
};

export type BodyImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPut = {
  upload_file: Blob | File;
};

export type BodyRunJobOnFileApiV1ExtractionJobsFilePost = {
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The file to run the job on
   */
  file: Blob | File;
  /**
   * The data schema to override the extraction agent's data schema with as a JSON string
   */
  data_schema_override?: string | null;
  /**
   * The config to override the extraction agent's config with as a JSON string
   */
  config_override?: string | null;
};

export type BodyScreenshotApiV1ParsingScreenshotPost = {
  file?: (Blob | File) | null;
  do_not_cache?: boolean;
  http_proxy?: string;
  input_s3_path?: string;
  input_s3_region?: string;
  input_url?: string;
  invalidate_cache?: boolean;
  max_pages?: number | null;
  output_s3_path_prefix?: string;
  output_s3_region?: string;
  target_pages?: string;
  webhook_url?: string;
  webhook_configurations?: string;
  job_timeout_in_seconds?: number;
  job_timeout_extra_time_per_page_in_seconds?: number;
};

export type BodyUploadFileApiV1FilesPost = {
  upload_file: Blob | File;
};

export type BodyUploadFileApiV1ParsingUploadPost = {
  file?: (Blob | File) | null;
  adaptive_long_table?: boolean;
  annotate_links?: boolean;
  auto_mode?: boolean;
  auto_mode_trigger_on_image_in_page?: boolean;
  auto_mode_trigger_on_table_in_page?: boolean;
  auto_mode_trigger_on_text_in_page?: string;
  auto_mode_trigger_on_regexp_in_page?: string;
  auto_mode_configuration_json?: string;
  azure_openai_api_version?: string;
  azure_openai_deployment_name?: string;
  azure_openai_endpoint?: string;
  azure_openai_key?: string;
  bbox_bottom?: number;
  bbox_left?: number;
  bbox_right?: number;
  bbox_top?: number;
  compact_markdown_table?: boolean;
  disable_ocr?: boolean;
  disable_reconstruction?: boolean;
  disable_image_extraction?: boolean;
  do_not_cache?: boolean;
  do_not_unroll_columns?: boolean;
  extract_charts?: boolean;
  guess_xlsx_sheet_name?: boolean;
  high_res_ocr?: boolean;
  html_make_all_elements_visible?: boolean;
  layout_aware?: boolean;
  specialized_chart_parsing_agentic?: boolean;
  specialized_chart_parsing_plus?: boolean;
  specialized_chart_parsing_efficient?: boolean;
  specialized_image_parsing?: boolean;
  precise_bounding_box?: boolean;
  line_level_bounding_box?: boolean;
  html_remove_fixed_elements?: boolean;
  html_remove_navigation_elements?: boolean;
  http_proxy?: string;
  input_s3_path?: string;
  input_s3_region?: string;
  input_url?: string;
  invalidate_cache?: boolean;
  language?: Array<ParserLanguages>;
  extract_layout?: boolean;
  max_pages?: number | null;
  merge_tables_across_pages_in_markdown?: boolean;
  outlined_table_extraction?: boolean;
  aggressive_table_extraction?: boolean;
  output_pdf_of_document?: boolean;
  output_s3_path_prefix?: string;
  output_s3_region?: string;
  page_prefix?: string;
  page_separator?: string;
  page_suffix?: string;
  preserve_layout_alignment_across_pages?: boolean;
  preserve_very_small_text?: boolean;
  skip_diagonal_text?: boolean;
  spreadsheet_extract_sub_tables?: boolean;
  spreadsheet_force_formula_computation?: boolean;
  inline_images_in_markdown?: boolean;
  structured_output?: boolean;
  structured_output_json_schema?: string;
  structured_output_json_schema_name?: string;
  take_screenshot?: boolean;
  target_pages?: string;
  vendor_multimodal_api_key?: string;
  vendor_multimodal_model_name?: string;
  model?: string;
  webhook_url?: string;
  webhook_configurations?: string;
  preset?: string;
  parse_mode?: ParsingMode | null;
  page_error_tolerance?: number;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string;
  replace_failed_page_with_error_message_suffix?: string;
  system_prompt?: string;
  system_prompt_append?: string;
  user_prompt?: string;
  job_timeout_in_seconds?: number;
  job_timeout_extra_time_per_page_in_seconds?: number;
  strict_mode_image_extraction?: boolean;
  strict_mode_image_ocr?: boolean;
  strict_mode_reconstruction?: boolean;
  strict_mode_buggy_font?: boolean;
  save_images?: boolean;
  ignore_document_elements_for_layout_detection?: boolean;
  keep_page_separator_when_merging_tables?: boolean;
  output_tables_as_HTML?: boolean;
  markdown_table_multiline_header_separator?: string;
  use_vendor_multimodal_model?: boolean;
  bounding_box?: string;
  gpt4o_mode?: boolean;
  gpt4o_api_key?: string;
  complemental_formatting_instruction?: string;
  content_guideline_instruction?: string;
  premium_mode?: boolean;
  is_formatting_instruction?: boolean;
  continuous_mode?: boolean;
  parsing_instruction?: string;
  fast_mode?: boolean;
  formatting_instruction?: string;
  hide_headers?: boolean;
  hide_footers?: boolean;
  page_header_prefix?: string;
  page_header_suffix?: string;
  page_footer_prefix?: string;
  page_footer_suffix?: string;
  remove_hidden_text?: boolean;
  presentation_out_of_bounds_content?: boolean;
  extract_printed_page_number?: boolean;
  tier?: string;
  version?: string;
};

export type BodyUploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPost =
  {
    upload_file: Blob | File;
    unique_id?: string | null;
    display_name?: string | null;
    external_file_id?: string | null;
  };

export type BoxAuthMechanism = "developer_token" | "ccg";

export const BoxAuthMechanism = {
  DEVELOPER_TOKEN: "developer_token",
  CCG: "ccg",
} as const;

export type CharacterChunkingConfig = {
  chunk_size?: number;
  chunk_overlap?: number;
  mode?: "character";
};

export type ChatData = {
  retrieval_parameters?: PresetRetrievalParams;
  llm_parameters?: LlmParameters | null;
  class_name?: string;
};

export type ChatInputParams = {
  messages?: Array<InputMessage>;
  data?: ChatData;
  class_name?: string;
};

export type ChatMessage = {
  id: string;
  /**
   * The index of the message in the chat.
   */
  index: number;
  /**
   * Retrieval annotations for the message.
   */
  annotations?: Array<MessageAnnotation>;
  /**
   * The role of the message.
   */
  role: MessageRole;
  /**
   * Text content of the generation
   */
  content?: string | null;
  /**
   * Additional arguments passed to the model
   */
  additional_kwargs?: {
    [key: string]: string;
  };
  class_name?: string;
};

/**
 * Result of classifying a single file.
 */
export type ClassificationResult = {
  /**
   * Step-by-step explanation of why this classification was chosen and the confidence score assigned
   */
  reasoning: string;
  /**
   * Confidence score of the classification (0.0-1.0)
   */
  confidence: number;
  /**
   * The document type that best matches, or null if no match.
   */
  type: string | null;
};

/**
 * A rule for classifying documents - v0 simplified version.
 *
 * This represents a single classification rule that will be applied to documents.
 * All rules are content-based and use natural language descriptions.
 */
export type ClassifierRule = {
  /**
   * The document type to assign when this rule matches (e.g., 'invoice', 'receipt', 'contract')
   */
  type: string;
  /**
   * Natural language description of what to classify. Be specific about the content characteristics that identify this document type.
   */
  description: string;
};

/**
 * A classify job.
 */
export type ClassifyJob = {
  /**
   * The status of the classify job
   */
  status: StatusEnum;
  effective_at?: string;
  /**
   * The job record ID associated with this status, if any.
   */
  job_record_id?: string | null;
  /**
   * Error message for the latest job attempt, if any.
   */
  error_message?: string | null;
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The rules to classify the files
   */
  rules: Array<ClassifierRule>;
  /**
   * The ID of the user
   */
  user_id: string;
  /**
   * The ID of the project
   */
  project_id: string;
  /**
   * The configuration for the parsing job
   */
  parsing_configuration?: ClassifyParsingConfiguration;
};

/**
 * A classify job.
 */
export type ClassifyJobCreate = {
  /**
   * The rules to classify the files
   */
  rules: Array<ClassifierRule>;
  /**
   * The IDs of the files to classify
   */
  file_ids: Array<string>;
  /**
   * The configuration for the parsing job
   */
  parsing_configuration?: ClassifyParsingConfiguration;
};

/**
 * Response model for the classify endpoint following AIP-132 pagination standard.
 */
export type ClassifyJobResults = {
  /**
   * The list of items.
   */
  items: Array<FileClassification>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Parsing configuration for a classify job.
 */
export type ClassifyParsingConfiguration = {
  /**
   * The language to parse the files in
   */
  lang?: ParserLanguages;
  /**
   * The maximum number of pages to parse
   */
  max_pages?: number | null;
  /**
   * The pages to target for parsing (0-indexed, so first page is at 0)
   */
  target_pages?: Array<number> | null;
};

/**
 * Cloud AstraDB Vector Store.
 *
 * This class is used to store the configuration for an AstraDB vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * token (str): The Astra DB Application Token to use.
 * api_endpoint (str): The Astra DB JSON API endpoint for your database.
 * collection_name (str): Collection name to use. If not existing, it will be created.
 * embedding_dimension (int): Length of the embedding vectors in use.
 * keyspace (optional[str]): The keyspace to use. If not provided, 'default_keyspace'
 */
export type CloudAstraDbVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  /**
   * The Astra DB JSON API endpoint for your database
   */
  api_endpoint: string;
  /**
   * Collection name to use. If not existing, it will be created
   */
  collection_name: string;
  /**
   * Length of the embedding vectors in use
   */
  embedding_dimension: number;
  /**
   * The keyspace to use. If not provided, 'default_keyspace'
   */
  keyspace?: string | null;
  class_name?: string;
};

/**
 * Cloud AstraDB Vector Store.
 *
 * This class is used to store the configuration for an AstraDB vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * token (str): The Astra DB Application Token to use.
 * api_endpoint (str): The Astra DB JSON API endpoint for your database.
 * collection_name (str): Collection name to use. If not existing, it will be created.
 * embedding_dimension (int): Length of the embedding vectors in use.
 * keyspace (optional[str]): The keyspace to use. If not provided, 'default_keyspace'
 */
export type CloudAstraDbVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  /**
   * The Astra DB Application Token to use
   */
  token: string;
  /**
   * The Astra DB JSON API endpoint for your database
   */
  api_endpoint: string;
  /**
   * Collection name to use. If not existing, it will be created
   */
  collection_name: string;
  /**
   * Length of the embedding vectors in use
   */
  embedding_dimension: number;
  /**
   * The keyspace to use. If not provided, 'default_keyspace'
   */
  keyspace?: string | null;
  class_name?: string;
};

export type CloudAzStorageBlobDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The name of the Azure Storage Blob container to read from.
   */
  container_name: string;
  /**
   * The Azure Storage Blob account URL to use for authentication.
   */
  account_url: string;
  /**
   * The blob name to read from.
   */
  blob?: string | null;
  /**
   * The prefix of the Azure Storage Blob objects to read from.
   */
  prefix?: string | null;
  /**
   * The Azure Storage Blob account name to use for authentication.
   */
  account_name?: string | null;
  /**
   * The Azure Storage Blob account key to use for authentication.
   */
  account_key?: string | null;
  /**
   * The Azure AD tenant ID to use for authentication.
   */
  tenant_id?: string | null;
  /**
   * The Azure AD client ID to use for authentication.
   */
  client_id?: string | null;
  /**
   * The Azure AD client secret to use for authentication.
   */
  client_secret?: string | null;
  class_name?: string;
};

export type CloudAzStorageBlobDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The name of the Azure Storage Blob container to read from.
   */
  container_name: string;
  /**
   * The Azure Storage Blob account URL to use for authentication.
   */
  account_url: string;
  /**
   * The blob name to read from.
   */
  blob?: string | null;
  /**
   * The prefix of the Azure Storage Blob objects to read from.
   */
  prefix?: string | null;
  /**
   * The Azure Storage Blob account name to use for authentication.
   */
  account_name?: string | null;
  /**
   * The Azure Storage Blob account key to use for authentication.
   */
  account_key?: string | null;
  /**
   * The Azure AD tenant ID to use for authentication.
   */
  tenant_id?: string | null;
  /**
   * The Azure AD client ID to use for authentication.
   */
  client_id?: string | null;
  /**
   * The Azure AD client secret to use for authentication.
   */
  client_secret?: string | null;
  class_name?: string;
};

/**
 * Cloud Azure AI Search Vector Store.
 */
export type CloudAzureAiSearchVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  search_service_endpoint: string;
  search_service_api_version?: string | null;
  index_name?: string | null;
  filterable_metadata_field_keys?: {
    [key: string]: unknown;
  } | null;
  embedding_dimension?: number | null;
  client_id?: string | null;
  client_secret?: string | null;
  tenant_id?: string | null;
  class_name?: string;
};

/**
 * Cloud Azure AI Search Vector Store.
 */
export type CloudAzureAiSearchVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  search_service_api_key: string;
  search_service_endpoint: string;
  search_service_api_version?: string | null;
  index_name?: string | null;
  filterable_metadata_field_keys?: {
    [key: string]: unknown;
  } | null;
  embedding_dimension?: number | null;
  client_id?: string | null;
  client_secret?: string | null;
  tenant_id?: string | null;
  class_name?: string;
};

export type CloudBoxDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The ID of the Box folder to read from.
   */
  folder_id?: string | null;
  /**
   * The type of authentication to use (Developer Token or CCG)
   */
  authentication_mechanism: BoxAuthMechanism;
  /**
   * Developer token for authentication if authentication_mechanism is 'developer_token'.
   */
  developer_token?: string | null;
  /**
   * Box API key used for identifying the application the user is authenticating with
   */
  client_id?: string | null;
  /**
   * Box API secret used for making auth requests.
   */
  client_secret?: string | null;
  /**
   * Box User ID, if provided authenticates as user.
   */
  user_id?: string | null;
  /**
   * Box Enterprise ID, if provided authenticates as service.
   */
  enterprise_id?: string | null;
  class_name?: string;
};

export type CloudBoxDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The ID of the Box folder to read from.
   */
  folder_id?: string | null;
  /**
   * The type of authentication to use (Developer Token or CCG)
   */
  authentication_mechanism: BoxAuthMechanism;
  /**
   * Developer token for authentication if authentication_mechanism is 'developer_token'.
   */
  developer_token?: string | null;
  /**
   * Box API key used for identifying the application the user is authenticating with
   */
  client_id?: string | null;
  /**
   * Box API secret used for making auth requests.
   */
  client_secret?: string | null;
  /**
   * Box User ID, if provided authenticates as user.
   */
  user_id?: string | null;
  /**
   * Box Enterprise ID, if provided authenticates as service.
   */
  enterprise_id?: string | null;
  class_name?: string;
};

export type CloudConfluenceDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The server URL of the Confluence instance.
   */
  server_url: string;
  /**
   * Type of Authentication for connecting to Confluence APIs.
   */
  authentication_mechanism: string;
  /**
   * The username to use for authentication.
   */
  user_name?: string | null;
  /**
   * The API token to use for authentication.
   */
  api_token?: string | null;
  /**
   * The space key to read from.
   */
  space_key?: string | null;
  /**
   * The page IDs of the Confluence to read from.
   */
  page_ids?: string | null;
  /**
   * The CQL query to use for fetching pages.
   */
  cql?: string | null;
  /**
   * The label to use for fetching pages.
   */
  label?: string | null;
  /**
   * Whether to index restricted pages.
   */
  index_restricted_pages?: boolean;
  /**
   * Whether to keep the markdown format.
   */
  keep_markdown_format?: boolean;
  /**
   * Configuration for handling failures during processing. Key-value object controlling failure handling behaviors.
   *
   * Example:
   * {
   * "skip_list_failures": true
   * }
   *
   * Currently supports:
   * - skip_list_failures: Skip failed batches/lists and continue processing
   */
  failure_handling?: FailureHandlingConfig;
  class_name?: string;
};

export type CloudConfluenceDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The server URL of the Confluence instance.
   */
  server_url: string;
  /**
   * Type of Authentication for connecting to Confluence APIs.
   */
  authentication_mechanism: string;
  /**
   * The username to use for authentication.
   */
  user_name?: string | null;
  /**
   * The API token to use for authentication.
   */
  api_token?: string | null;
  /**
   * The space key to read from.
   */
  space_key?: string | null;
  /**
   * The page IDs of the Confluence to read from.
   */
  page_ids?: string | null;
  /**
   * The CQL query to use for fetching pages.
   */
  cql?: string | null;
  /**
   * The label to use for fetching pages.
   */
  label?: string | null;
  /**
   * Whether to index restricted pages.
   */
  index_restricted_pages?: boolean;
  /**
   * Whether to keep the markdown format.
   */
  keep_markdown_format?: boolean;
  /**
   * Configuration for handling failures during processing. Key-value object controlling failure handling behaviors.
   *
   * Example:
   * {
   * "skip_list_failures": true
   * }
   *
   * Currently supports:
   * - skip_list_failures: Skip failed batches/lists and continue processing
   */
  failure_handling?: FailureHandlingConfig;
  class_name?: string;
};

/**
 * Cloud document stored in S3.
 */
export type CloudDocument = {
  text: string;
  metadata: {
    [key: string]: unknown;
  };
  excluded_embed_metadata_keys?: Array<string>;
  excluded_llm_metadata_keys?: Array<string>;
  /**
   * indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].
   */
  page_positions?: Array<number> | null;
  id: string;
  status_metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Create a new cloud document.
 */
export type CloudDocumentCreate = {
  text: string;
  metadata: {
    [key: string]: unknown;
  };
  excluded_embed_metadata_keys?: Array<string>;
  excluded_llm_metadata_keys?: Array<string>;
  /**
   * indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].
   */
  page_positions?: Array<number> | null;
  id?: string | null;
};

/**
 * Cloud Jira Data Source integrating JiraReader.
 */
export type CloudJiraDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API/ Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url?: string | null;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  class_name?: string;
};

/**
 * Cloud Jira Data Source integrating JiraReader.
 */
export type CloudJiraDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API/ Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url?: string | null;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  class_name?: string;
};

/**
 * Cloud Jira Data Source integrating JiraReaderV2.
 */
export type CloudJiraDataSourceV2Readable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url: string;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * Jira REST API version to use (2 or 3). 3 supports Atlassian Document Format (ADF).
   */
  api_version?: "2" | "3";
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  /**
   * List of fields to retrieve from Jira. If None, retrieves all fields.
   */
  fields?: Array<string> | null;
  /**
   * Fields to expand in the response.
   */
  expand?: string | null;
  /**
   * Rate limit for Jira API requests per minute.
   */
  requests_per_minute?: number | null;
  /**
   * Whether to fetch project role permissions and issue-level security
   */
  get_permissions?: boolean;
  class_name?: string;
};

/**
 * Cloud Jira Data Source integrating JiraReaderV2.
 */
export type CloudJiraDataSourceV2Writable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url: string;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * Jira REST API version to use (2 or 3). 3 supports Atlassian Document Format (ADF).
   */
  api_version?: "2" | "3";
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  /**
   * List of fields to retrieve from Jira. If None, retrieves all fields.
   */
  fields?: Array<string> | null;
  /**
   * Fields to expand in the response.
   */
  expand?: string | null;
  /**
   * Rate limit for Jira API requests per minute.
   */
  requests_per_minute?: number | null;
  /**
   * Whether to fetch project role permissions and issue-level security
   */
  get_permissions?: boolean;
  class_name?: string;
};

/**
 * Cloud Milvus Vector Store.
 */
export type CloudMilvusVectorStoreReadable = {
  supports_nested_metadata_filters?: boolean;
  uri: string;
  collection_name?: string | null;
  token?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

/**
 * Cloud Milvus Vector Store.
 */
export type CloudMilvusVectorStoreWritable = {
  supports_nested_metadata_filters?: boolean;
  uri: string;
  collection_name?: string | null;
  token?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

/**
 * Cloud MongoDB Atlas Vector Store.
 *
 * This class is used to store the configuration for a MongoDB Atlas vector store,
 * so that it can be created and used in LlamaCloud.
 *
 * Args:
 * mongodb_uri (str): URI for connecting to MongoDB Atlas
 * db_name (str): name of the MongoDB database
 * collection_name (str): name of the MongoDB collection
 * vector_index_name (str): name of the MongoDB Atlas vector index
 * fulltext_index_name (str): name of the MongoDB Atlas full-text index
 */
export type CloudMongoDbAtlasVectorSearchReadable = {
  supports_nested_metadata_filters?: boolean;
  db_name: string;
  collection_name: string;
  vector_index_name?: string | null;
  fulltext_index_name?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

/**
 * Cloud MongoDB Atlas Vector Store.
 *
 * This class is used to store the configuration for a MongoDB Atlas vector store,
 * so that it can be created and used in LlamaCloud.
 *
 * Args:
 * mongodb_uri (str): URI for connecting to MongoDB Atlas
 * db_name (str): name of the MongoDB database
 * collection_name (str): name of the MongoDB collection
 * vector_index_name (str): name of the MongoDB Atlas vector index
 * fulltext_index_name (str): name of the MongoDB Atlas full-text index
 */
export type CloudMongoDbAtlasVectorSearchWritable = {
  supports_nested_metadata_filters?: boolean;
  mongodb_uri: string;
  db_name: string;
  collection_name: string;
  vector_index_name?: string | null;
  fulltext_index_name?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

export type CloudNotionPageDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The Notion Database Id to read content from.
   */
  database_ids?: string | null;
  /**
   * The Page ID's of the Notion to read from.
   */
  page_ids?: string | null;
  class_name?: string;
};

export type CloudNotionPageDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The integration token to use for authentication.
   */
  integration_token: string;
  /**
   * The Notion Database Id to read content from.
   */
  database_ids?: string | null;
  /**
   * The Page ID's of the Notion to read from.
   */
  page_ids?: string | null;
  class_name?: string;
};

export type CloudOneDriveDataSourceReadable = {
  supports_access_control?: true;
  /**
   * The user principal name to use for authentication.
   */
  user_principal_name: string;
  /**
   * The path of the OneDrive folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the OneDrive folder to read from.
   */
  folder_id?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  class_name?: string;
};

export type CloudOneDriveDataSourceWritable = {
  supports_access_control?: true;
  /**
   * The user principal name to use for authentication.
   */
  user_principal_name: string;
  /**
   * The path of the OneDrive folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the OneDrive folder to read from.
   */
  folder_id?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The client secret to use for authentication.
   */
  client_secret: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  class_name?: string;
};

/**
 * Cloud Pinecone Vector Store.
 *
 * This class is used to store the configuration for a Pinecone vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * api_key (str): API key for authenticating with Pinecone
 * index_name (str): name of the Pinecone index
 * namespace (optional[str]): namespace to use in the Pinecone index
 * insert_kwargs (optional[dict]): additional kwargs to pass during insertion
 */
export type CloudPineconeVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  index_name: string;
  namespace?: string | null;
  insert_kwargs?: {
    [key: string]: unknown;
  } | null;
  class_name?: string;
};

/**
 * Cloud Pinecone Vector Store.
 *
 * This class is used to store the configuration for a Pinecone vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * api_key (str): API key for authenticating with Pinecone
 * index_name (str): name of the Pinecone index
 * namespace (optional[str]): namespace to use in the Pinecone index
 * insert_kwargs (optional[dict]): additional kwargs to pass during insertion
 */
export type CloudPineconeVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  /**
   * The API key for authenticating with Pinecone
   */
  api_key: string;
  index_name: string;
  namespace?: string | null;
  insert_kwargs?: {
    [key: string]: unknown;
  } | null;
  class_name?: string;
};

export type CloudPostgresVectorStoreReadable = {
  supports_nested_metadata_filters?: boolean;
  database: string;
  host: string;
  port: number;
  user: string;
  table_name: string;
  schema_name: string;
  embed_dim: number;
  hybrid_search?: boolean | null;
  perform_setup?: boolean;
  /**
   * HNSW settings for PGVector index. Set to null to disable HNSW indexing in favor of a brute force indexing/exact search strategy instead.
   */
  hnsw_settings?: PgVectorHnswSettings | null;
  class_name?: string;
};

export type CloudPostgresVectorStoreWritable = {
  supports_nested_metadata_filters?: boolean;
  database: string;
  host: string;
  password: string;
  port: number;
  user: string;
  table_name: string;
  schema_name: string;
  embed_dim: number;
  hybrid_search?: boolean | null;
  perform_setup?: boolean;
  /**
   * HNSW settings for PGVector index. Set to null to disable HNSW indexing in favor of a brute force indexing/exact search strategy instead.
   */
  hnsw_settings?: PgVectorHnswSettings | null;
  class_name?: string;
};

/**
 * Cloud Qdrant Vector Store.
 *
 * This class is used to store the configuration for a Qdrant vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * collection_name (str): name of the Qdrant collection
 * url (str): url of the Qdrant instance
 * api_key (str): API key for authenticating with Qdrant
 * max_retries (int): maximum number of retries in case of a failure. Defaults to 3
 * client_kwargs (dict): additional kwargs to pass to the Qdrant client
 */
export type CloudQdrantVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  collection_name: string;
  url: string;
  max_retries?: number;
  client_kwargs?: {
    [key: string]: unknown;
  };
  class_name?: string;
};

/**
 * Cloud Qdrant Vector Store.
 *
 * This class is used to store the configuration for a Qdrant vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * collection_name (str): name of the Qdrant collection
 * url (str): url of the Qdrant instance
 * api_key (str): API key for authenticating with Qdrant
 * max_retries (int): maximum number of retries in case of a failure. Defaults to 3
 * client_kwargs (dict): additional kwargs to pass to the Qdrant client
 */
export type CloudQdrantVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  collection_name: string;
  url: string;
  api_key: string;
  max_retries?: number;
  client_kwargs?: {
    [key: string]: unknown;
  };
  class_name?: string;
};

export type CloudS3DataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The name of the S3 bucket to read from.
   */
  bucket: string;
  /**
   * The prefix of the S3 objects to read from.
   */
  prefix?: string | null;
  /**
   * The regex pattern to filter S3 objects. Must be a valid regex pattern.
   */
  regex_pattern?: string | null;
  /**
   * The AWS access ID to use for authentication.
   */
  aws_access_id?: string | null;
  /**
   * The AWS access secret to use for authentication.
   */
  aws_access_secret?: string | null;
  /**
   * The S3 endpoint URL to use for authentication.
   */
  s3_endpoint_url?: string | null;
  class_name?: string;
};

export type CloudS3DataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The name of the S3 bucket to read from.
   */
  bucket: string;
  /**
   * The prefix of the S3 objects to read from.
   */
  prefix?: string | null;
  /**
   * The regex pattern to filter S3 objects. Must be a valid regex pattern.
   */
  regex_pattern?: string | null;
  /**
   * The AWS access ID to use for authentication.
   */
  aws_access_id?: string | null;
  /**
   * The AWS access secret to use for authentication.
   */
  aws_access_secret?: string | null;
  /**
   * The S3 endpoint URL to use for authentication.
   */
  s3_endpoint_url?: string | null;
  class_name?: string;
};

export type CloudSharepointDataSourceReadable = {
  supports_access_control?: true;
  /**
   * The name of the SharePoint site to download from.
   */
  site_name?: string | null;
  /**
   * The ID of the SharePoint site to download from.
   */
  site_id?: string | null;
  /**
   * The path of the Sharepoint folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the Sharepoint folder to read from.
   */
  folder_id?: string | null;
  /**
   * The name of the Sharepoint drive to read from.
   */
  drive_name?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  /**
   * Whether to get permissions for the sharepoint site.
   */
  get_permissions?: boolean | null;
  /**
   * List of regex patterns for file paths to include. Full paths (including filename) must match at least one pattern to be included. Example: ['/reports/', '/docs/.*\.pdf$', '^Report.*\.pdf$']
   */
  include_path_patterns?: Array<string> | null;
  /**
   * List of regex patterns for file paths to exclude. Files whose paths (including filename) match any pattern will be excluded. Example: ['/temp/', '/backup/', '\.git/', '\.tmp$', '^~']
   */
  exclude_path_patterns?: Array<string> | null;
  class_name?: string;
};

export type CloudSharepointDataSourceWritable = {
  supports_access_control?: true;
  /**
   * The name of the SharePoint site to download from.
   */
  site_name?: string | null;
  /**
   * The ID of the SharePoint site to download from.
   */
  site_id?: string | null;
  /**
   * The path of the Sharepoint folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the Sharepoint folder to read from.
   */
  folder_id?: string | null;
  /**
   * The name of the Sharepoint drive to read from.
   */
  drive_name?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The client secret to use for authentication.
   */
  client_secret: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  /**
   * Whether to get permissions for the sharepoint site.
   */
  get_permissions?: boolean | null;
  /**
   * List of regex patterns for file paths to include. Full paths (including filename) must match at least one pattern to be included. Example: ['/reports/', '/docs/.*\.pdf$', '^Report.*\.pdf$']
   */
  include_path_patterns?: Array<string> | null;
  /**
   * List of regex patterns for file paths to exclude. Files whose paths (including filename) match any pattern will be excluded. Example: ['/temp/', '/backup/', '\.git/', '\.tmp$', '^~']
   */
  exclude_path_patterns?: Array<string> | null;
  class_name?: string;
};

export type CloudSlackDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * Slack Channel.
   */
  channel_ids?: string | null;
  /**
   * Latest date.
   */
  latest_date?: string | null;
  /**
   * Earliest date.
   */
  earliest_date?: string | null;
  /**
   * Earliest date timestamp.
   */
  earliest_date_timestamp?: number | null;
  /**
   * Latest date timestamp.
   */
  latest_date_timestamp?: number | null;
  /**
   * Slack Channel name pattern.
   */
  channel_patterns?: string | null;
  class_name?: string;
};

export type CloudSlackDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * Slack Bot Token.
   */
  slack_token: string;
  /**
   * Slack Channel.
   */
  channel_ids?: string | null;
  /**
   * Latest date.
   */
  latest_date?: string | null;
  /**
   * Earliest date.
   */
  earliest_date?: string | null;
  /**
   * Earliest date timestamp.
   */
  earliest_date_timestamp?: number | null;
  /**
   * Latest date timestamp.
   */
  latest_date_timestamp?: number | null;
  /**
   * Slack Channel name pattern.
   */
  channel_patterns?: string | null;
  class_name?: string;
};

export type CodeItem = {
  /**
   * Code block item type
   */
  type?: "code";
  /**
   * Bounding box coordinates [x1, y1, x2, y2]
   */
  bBox?: [number, number, number, number] | null;
  /**
   * Code content
   */
  value: string;
  /**
   * Programming language identifier
   */
  language?: string | null;
};

export type CohereEmbedding = {
  /**
   * The modelId of the Cohere model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * The Cohere API key.
   */
  api_key: string | null;
  /**
   * Truncation type - START/ END/ NONE
   */
  truncate?: string;
  /**
   * Model Input type. If not provided, search_document and search_query are used when needed.
   */
  input_type?: string | null;
  /**
   * Embedding type. If not provided float embedding_type is used when needed.
   */
  embedding_type?: string;
  class_name?: string;
};

export type CohereEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "COHERE_EMBEDDING";
  /**
   * Configuration for the Cohere embedding model.
   */
  component?: CohereEmbedding;
};

/**
 * Enum for the mode of composite retrieval.
 */
export type CompositeRetrievalMode = "routing" | "full";

/**
 * Enum for the mode of composite retrieval.
 */
export const CompositeRetrievalMode = {
  ROUTING: "routing",
  FULL: "full",
} as const;

export type CompositeRetrievalParams = {
  /**
   * The mode of composite retrieval.
   */
  mode?: CompositeRetrievalMode;
  /**
   * (use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   * @deprecated
   */
  rerank_top_n?: number | null;
  /**
   * The rerank configuration for composite retrieval.
   */
  rerank_config?: ReRankConfig;
  /**
   * The query to retrieve against.
   */
  query: string;
};

export type CompositeRetrievalResult = {
  /**
   * The retrieved nodes from the composite retrieval.
   */
  nodes?: Array<CompositeRetrievedTextNodeWithScore>;
  /**
   * The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.
   * @deprecated
   */
  image_nodes?: Array<PageScreenshotNodeWithScore>;
  /**
   * The page figure nodes retrieved by the pipeline for the given query.
   */
  page_figure_nodes?: Array<PageFigureNodeWithScore>;
};

export type CompositeRetrievedTextNode = {
  /**
   * The ID of the retrieved node.
   */
  id: string;
  /**
   * The ID of the retriever this node was retrieved from.
   */
  retriever_id: string;
  /**
   * The name of the retrieval pipeline this node was retrieved from.
   */
  retriever_pipeline_name: string;
  /**
   * The ID of the pipeline this node was retrieved from.
   */
  pipeline_id: string;
  /**
   * Metadata associated with the retrieved node.
   */
  metadata?: {
    [key: string]: unknown;
  };
  /**
   * The text of the retrieved node.
   */
  text: string;
  /**
   * The start character index of the retrieved node in the document
   */
  start_char_idx: number | null;
  /**
   * The end character index of the retrieved node in the document
   */
  end_char_idx: number | null;
};

export type CompositeRetrievedTextNodeWithScore = {
  node: CompositeRetrievedTextNode;
  score?: number | null;
  class_name?: string;
};

export type ConfigurableDataSinkNames =
  | "PINECONE"
  | "POSTGRES"
  | "QDRANT"
  | "AZUREAI_SEARCH"
  | "MONGODB_ATLAS"
  | "MILVUS"
  | "ASTRA_DB";

export const ConfigurableDataSinkNames = {
  PINECONE: "PINECONE",
  POSTGRES: "POSTGRES",
  QDRANT: "QDRANT",
  AZUREAI_SEARCH: "AZUREAI_SEARCH",
  MONGODB_ATLAS: "MONGODB_ATLAS",
  MILVUS: "MILVUS",
  ASTRA_DB: "ASTRA_DB",
} as const;

export type ConfigurableDataSourceNames =
  | "S3"
  | "AZURE_STORAGE_BLOB"
  | "GOOGLE_DRIVE"
  | "MICROSOFT_ONEDRIVE"
  | "MICROSOFT_SHAREPOINT"
  | "SLACK"
  | "NOTION_PAGE"
  | "CONFLUENCE"
  | "JIRA"
  | "JIRA_V2"
  | "BOX";

export const ConfigurableDataSourceNames = {
  S3: "S3",
  AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB",
  GOOGLE_DRIVE: "GOOGLE_DRIVE",
  MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE",
  MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT",
  SLACK: "SLACK",
  NOTION_PAGE: "NOTION_PAGE",
  CONFLUENCE: "CONFLUENCE",
  JIRA: "JIRA",
  JIRA_V2: "JIRA_V2",
  BOX: "BOX",
} as const;

/**
 * Schema for a data sink.
 */
export type DataSinkReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreReadable
    | CloudPostgresVectorStoreReadable
    | CloudQdrantVectorStoreReadable
    | CloudAzureAiSearchVectorStoreReadable
    | CloudMongoDbAtlasVectorSearchReadable
    | CloudMilvusVectorStoreReadable
    | CloudAstraDbVectorStoreReadable;
  project_id: string;
};

/**
 * Schema for a data sink.
 */
export type DataSinkWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreWritable
    | CloudPostgresVectorStoreWritable
    | CloudQdrantVectorStoreWritable
    | CloudAzureAiSearchVectorStoreWritable
    | CloudMongoDbAtlasVectorSearchWritable
    | CloudMilvusVectorStoreWritable
    | CloudAstraDbVectorStoreWritable;
  project_id: string;
};

/**
 * Schema for creating a data sink.
 */
export type DataSinkCreateReadable = {
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreReadable
    | CloudPostgresVectorStoreReadable
    | CloudQdrantVectorStoreReadable
    | CloudAzureAiSearchVectorStoreReadable
    | CloudMongoDbAtlasVectorSearchReadable
    | CloudMilvusVectorStoreReadable
    | CloudAstraDbVectorStoreReadable;
};

/**
 * Schema for creating a data sink.
 */
export type DataSinkCreateWritable = {
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreWritable
    | CloudPostgresVectorStoreWritable
    | CloudQdrantVectorStoreWritable
    | CloudAzureAiSearchVectorStoreWritable
    | CloudMongoDbAtlasVectorSearchWritable
    | CloudMilvusVectorStoreWritable
    | CloudAstraDbVectorStoreWritable;
};

/**
 * Schema for updating a data sink.
 */
export type DataSinkUpdateReadable = {
  /**
   * The name of the data sink.
   */
  name?: string | null;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreReadable
    | CloudPostgresVectorStoreReadable
    | CloudQdrantVectorStoreReadable
    | CloudAzureAiSearchVectorStoreReadable
    | CloudMongoDbAtlasVectorSearchReadable
    | CloudMilvusVectorStoreReadable
    | CloudAstraDbVectorStoreReadable
    | null;
};

/**
 * Schema for updating a data sink.
 */
export type DataSinkUpdateWritable = {
  /**
   * The name of the data sink.
   */
  name?: string | null;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreWritable
    | CloudPostgresVectorStoreWritable
    | CloudQdrantVectorStoreWritable
    | CloudAzureAiSearchVectorStoreWritable
    | CloudMongoDbAtlasVectorSearchWritable
    | CloudMilvusVectorStoreWritable
    | CloudAstraDbVectorStoreWritable
    | null;
};

/**
 * Schema for a data source.
 */
export type DataSourceReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
};

/**
 * Schema for a data source.
 */
export type DataSourceWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
};

/**
 * Schema for creating a data source.
 */
export type DataSourceCreateReadable = {
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable;
};

/**
 * Schema for creating a data source.
 */
export type DataSourceCreateWritable = {
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable;
};

export type DataSourceReaderVersionMetadata = {
  /**
   * The version of the reader to use for this data source.
   */
  reader_version?: ("1.0" | "2.0" | "2.1") | null;
};

/**
 * Request model for syncing pipeline data sources.
 *
 * Notes:
 * - This endpoint pulls from the 3p data source and parses.
 * - We accept pipeline_file_ids for now because callers (e.g. add_files_to_pipeline)
 * often have these IDs handy. Internally we map them to external IDs to filter
 * the reader, which enumerates by external ID.
 * - Likely to evolve to take external IDs directly; keeping this for convenience.
 */
export type DataSourceSyncRequest = {
  pipeline_file_ids?: Array<string> | null;
};

/**
 * Schema for updating a data source.
 */
export type DataSourceUpdateReadable = {
  /**
   * The name of the data source.
   */
  name?: string | null;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable
    | null;
};

/**
 * Schema for updating a data source.
 */
export type DataSourceUpdateWritable = {
  /**
   * The name of the data source.
   */
  name?: string | null;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable
    | null;
};

/**
 * API request body for bulk deleting agent data by query
 */
export type DeleteRequest = {
  /**
   * The agent deployment's name to delete data for
   */
  deployment_name: string;
  /**
   * The logical agent data collection to delete from
   */
  collection?: string;
  /**
   * Optional filters to select which items to delete
   */
  filter?: {
    [key: string]: FilterOperation;
  } | null;
};

/**
 * API response for bulk delete operation
 */
export type DeleteResponse = {
  deleted_count: number;
};

export type DiffingStatusDetails = {
  /**
   * Status of the diffing process
   */
  status?: "pending" | "processing" | "completed" | "failed";
  effective_at?: string;
  /**
   * The job record ID associated with this status, if any.
   */
  job_record_id?: string | null;
  /**
   * Error message for the latest job attempt, if any.
   */
  error_message?: string | null;
};

export type DirectRetrievalParams = {
  /**
   * The mode of composite retrieval.
   */
  mode?: CompositeRetrievalMode;
  /**
   * (use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   * @deprecated
   */
  rerank_top_n?: number | null;
  /**
   * The rerank configuration for composite retrieval.
   */
  rerank_config?: ReRankConfig;
  /**
   * The query to retrieve against.
   */
  query: string;
  /**
   * The pipelines to use for retrieval.
   */
  pipelines?: Array<RetrieverPipeline>;
};

/**
 * API request schema for creating a directory.
 */
export type DirectoryCreateRequest = {
  /**
   * Human-readable name for the directory.
   */
  name: string;
  /**
   * Optional description shown to users.
   */
  description?: string | null;
  /**
   * Optional data source id the directory syncs from.
   */
  data_source_id?: string | null;
};

/**
 * API request schema for creating a directory file.
 */
export type DirectoryFileCreateRequest = {
  /**
   * File ID for the storage location (required).
   */
  file_id: string;
  /**
   * Unique identifier for the file in the directory. If not provided, will use the file's external_file_id or name.
   */
  unique_id?: string | null;
  /**
   * Display name for the file. If not provided, will use the file's name.
   */
  display_name?: string | null;
};

/**
 * API query response schema for directory files.
 */
export type DirectoryFileQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<DirectoryFileResponse>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * API response schema for a directory file.
 */
export type DirectoryFileResponse = {
  /**
   * Unique identifier for the directory file.
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Project the directory file belongs to.
   */
  project_id: string;
  /**
   * Directory the file belongs to.
   */
  directory_id: string;
  /**
   * Unique identifier for the file in the directory
   */
  unique_id: string;
  /**
   * Display name for the file.
   */
  display_name: string;
  /**
   * Optional data source credential associated with the file.
   */
  data_source_id?: string | null;
  /**
   * File ID for the storage location.
   */
  file_id?: string | null;
  /**
   * Soft delete marker when the file is removed upstream or by user action.
   */
  deleted_at?: string | null;
};

/**
 * API request schema for updating a directory file.
 */
export type DirectoryFileUpdateRequest = {
  /**
   * Updated unique identifier.
   */
  unique_id?: string | null;
  /**
   * Updated display name.
   */
  display_name?: string | null;
};

/**
 * API query response schema for directories.
 */
export type DirectoryQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<DirectoryResponse>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * API response schema for a directory.
 */
export type DirectoryResponse = {
  /**
   * Unique identifier for the directory.
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Project the directory belongs to.
   */
  project_id: string;
  /**
   * Human-readable name for the directory.
   */
  name: string;
  /**
   * Optional description shown to users.
   */
  description?: string | null;
  /**
   * Optional data source id the directory syncs from. Null if just manual uploads.
   */
  data_source_id?: string | null;
  /**
   * Optional timestamp of when the directory was deleted. Null if not deleted.
   */
  deleted_at?: string | null;
};

/**
 * Schema for creating a directory sync job.
 */
export type DirectorySyncJobCreateRequest = {
  /**
   * Directory being processed
   */
  directory_id: string;
};

/**
 * Schema for a directory sync job.
 */
export type DirectorySyncJobResponse = {
  /**
   * Unique identifier for the directory sync job
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Project this job belongs to
   */
  project_id: string;
  /**
   * Directory being processed
   */
  directory_id: string;
  /**
   * Status of the listing process
   */
  listing_status_details: ListingStatusDetails;
  /**
   * Status of the diffing process
   */
  diffing_status_details: DiffingStatusDetails;
  /**
   * Status of the apply process (file updates and deletions)
   */
  apply_status_details: ApplyStatusDetails;
  /**
   * Timestamp when job processing started
   */
  started_at?: string | null;
  /**
   * Timestamp when job completed
   */
  completed_at?: string | null;
};

/**
 * API request schema for updating a directory.
 */
export type DirectoryUpdateRequest = {
  /**
   * Updated name for the directory.
   */
  name?: string | null;
  /**
   * Updated description for the directory.
   */
  description?: string | null;
};

/**
 * How to chunk documents.
 */
export type DocumentChunkMode = "PAGE" | "SECTION";

/**
 * How to chunk documents.
 */
export const DocumentChunkMode = {
  PAGE: "PAGE",
  SECTION: "SECTION",
} as const;

export type ElementSegmentationConfig = {
  mode?: "element";
};

/**
 * Schema for an embedding model config.
 */
export type EmbeddingModelConfig = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the embedding model config.
   */
  name: string;
  /**
   * The embedding configuration for the embedding model config.
   */
  embedding_config:
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
  project_id: string;
};

export type EmbeddingModelConfigCreate = {
  /**
   * The name of the embedding model config.
   */
  name: string;
  /**
   * The embedding configuration for the embedding model config.
   */
  embedding_config:
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
};

export type EmbeddingModelConfigUpdate = {
  /**
   * The name of the embedding model config.
   */
  name?: string | null;
  /**
   * The embedding configuration for the embedding model config.
   */
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
};

/**
 * Schema and configuration for an extraction agent.
 */
export type ExtractAgent = {
  /**
   * The id of the extraction agent.
   */
  id: string;
  /**
   * The name of the extraction agent.
   */
  name: string;
  /**
   * The ID of the project that the extraction agent belongs to.
   */
  project_id: string;
  /**
   * The schema of the data.
   */
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
  /**
   * The configuration parameters for the extraction agent.
   */
  config: ExtractConfig;
  /**
   * Custom configuration type for the extraction agent. Currently supports 'default'.
   */
  custom_configuration?: "default" | null;
  /**
   * The creation time of the extraction agent.
   */
  created_at?: string | null;
  /**
   * The last update time of the extraction agent.
   */
  updated_at?: string | null;
};

/**
 * Settings for creating an extraction agent.
 */
export type ExtractAgentCreate = {
  /**
   * The name of the extraction schema
   */
  name: string;
  /**
   * The schema of the data.
   */
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
  /**
   * The configuration parameters for the extraction agent.
   */
  config: ExtractConfig;
};

/**
 * Settings for updating an extraction schema.
 */
export type ExtractAgentUpdate = {
  /**
   * The schema of the data
   */
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
  /**
   * The configuration parameters for the extraction agent.
   */
  config: ExtractConfig;
};

/**
 * Configuration parameters for the extraction agent.
 */
export type ExtractConfig = {
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  /**
   * The extraction target specified.
   */
  extraction_target?: ExtractTarget;
  /**
   * The extraction mode specified (FAST, BALANCED, MULTIMODAL, PREMIUM).
   */
  extraction_mode?: ExtractMode;
  /**
   * The parse model to use for document parsing. If not provided, uses the default for the extraction mode.
   */
  parse_model?: PublicModelName | null;
  /**
   * The extract model to use for data extraction. If not provided, uses the default for the extraction mode.
   */
  extract_model?: ExtractModels | null;
  /**
   * DEPRECATED: Whether to use fast mode for multimodal extraction.
   */
  multimodal_fast_mode?: boolean;
  /**
   * The system prompt to use for the extraction.
   */
  system_prompt?: string | null;
  /**
   * Whether to use reasoning for the extraction.
   */
  use_reasoning?: boolean;
  /**
   * Whether to cite sources for the extraction.
   */
  cite_sources?: boolean;
  /**
   * Whether to fetch citation bounding boxes for the extraction. Only available in PREMIUM mode.
   */
  citation_bbox?: boolean;
  /**
   * Whether to fetch confidence scores for the extraction.
   */
  confidence_scores?: boolean;
  /**
   * The mode to use for chunking the document.
   */
  chunk_mode?: DocumentChunkMode;
  /**
   * Whether to use high resolution mode for the extraction.
   */
  high_resolution_mode?: boolean;
  /**
   * Whether to invalidate the cache for the extraction.
   */
  invalidate_cache?: boolean;
  /**
   * Number of pages to pass as context on long document extraction.
   */
  num_pages_context?: number | null;
  /**
   * Comma-separated list of page numbers or ranges to extract from (1-based, e.g., '1,3,5-7,9' or '1-3,8-10').
   */
  page_range?: string | null;
};

/**
 * Schema for an extraction job.
 */
export type ExtractJob = {
  /**
   * The id of the extraction job
   */
  id: string;
  /**
   * The agent that the job was run on.
   */
  extraction_agent: ExtractAgent;
  /**
   * The status of the extraction job
   */
  status: StatusEnum;
  /**
   * The error that occurred during extraction
   */
  error?: string | null;
  /**
   * The id of the file that the extract was extracted from
   */
  file_id?: string | null;
  /**
   * [DEPRECATED] The file that the extract was extracted from
   * @deprecated
   */
  file?: File | null;
};

/**
 * Schema for creating an extraction job.
 */
export type ExtractJobCreate = {
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The id of the file
   */
  file_id: string;
  /**
   * The data schema to override the extraction agent's data schema with
   */
  data_schema_override?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string
    | null;
  /**
   * The config to override the extraction agent's config with
   */
  config_override?: ExtractConfig | null;
};

/**
 * Schema for creating extraction jobs in batch.
 */
export type ExtractJobCreateBatch = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The ids of the files
   */
  file_ids: Array<string>;
  /**
   * The data schema to override the extraction agent's data schema with
   */
  data_schema_override?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string
    | null;
  /**
   * The config to override the extraction agent's config with
   */
  config_override?: ExtractConfig | null;
};

/**
 * Extraction mode options.
 */
export type ExtractMode = "FAST" | "BALANCED" | "PREMIUM" | "MULTIMODAL";

/**
 * Extraction mode options.
 */
export const ExtractMode = {
  FAST: "FAST",
  BALANCED: "BALANCED",
  PREMIUM: "PREMIUM",
  MULTIMODAL: "MULTIMODAL",
} as const;

/**
 * Extract model options.
 */
export type ExtractModels =
  | "openai-gpt-4-1"
  | "openai-gpt-4-1-mini"
  | "openai-gpt-4-1-nano"
  | "openai-gpt-5"
  | "openai-gpt-5-mini"
  | "gemini-2.0-flash"
  | "gemini-2.5-flash"
  | "gemini-2.5-flash-lite"
  | "gemini-2.5-pro"
  | "openai-gpt-4o"
  | "openai-gpt-4o-mini";

/**
 * Extract model options.
 */
export const ExtractModels = {
  OPENAI_GPT_4_1: "openai-gpt-4-1",
  OPENAI_GPT_4_1_MINI: "openai-gpt-4-1-mini",
  OPENAI_GPT_4_1_NANO: "openai-gpt-4-1-nano",
  OPENAI_GPT_5: "openai-gpt-5",
  OPENAI_GPT_5_MINI: "openai-gpt-5-mini",
  GEMINI_2_0_FLASH: "gemini-2.0-flash",
  GEMINI_2_5_FLASH: "gemini-2.5-flash",
  GEMINI_2_5_FLASH_LITE: "gemini-2.5-flash-lite",
  GEMINI_2_5_PRO: "gemini-2.5-pro",
  OPENAI_GPT_4O: "openai-gpt-4o",
  OPENAI_GPT_4O_MINI: "openai-gpt-4o-mini",
} as const;

/**
 * Schema for an extraction resultset.
 */
export type ExtractResultset = {
  /**
   * The id of the extraction run
   */
  run_id: string;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The data extracted from the file
   */
  data:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | Array<{
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }>
    | null;
  /**
   * The metadata extracted from the file
   */
  extraction_metadata: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
};

/**
 * Schema for an extraction run.
 */
export type ExtractRun = {
  /**
   * The id of the extraction run
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The id of the project that the extraction run belongs to
   */
  project_id: string;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The schema used for extraction
   */
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
  /**
   * The config used for extraction
   */
  config: ExtractConfig;
  /**
   * The id of the file that the extract was extracted from
   */
  file_id?: string | null;
  /**
   * [DEPRECATED] The file that the extract was extracted from
   * @deprecated
   */
  file?: File | null;
  /**
   * The status of the extraction run
   */
  status: ExtractState;
  /**
   * The error that occurred during extraction
   */
  error?: string | null;
  /**
   * The id of the job that the extraction run belongs to
   */
  job_id?: string | null;
  /**
   * The data extracted from the file
   */
  data?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | Array<{
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }>
    | null;
  /**
   * The metadata extracted from the file
   */
  extraction_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Whether this extraction run was triggered from the UI
   */
  from_ui: boolean;
};

/**
 * Request schema for generating an extraction schema.
 */
export type ExtractSchemaGenerateRequest = {
  /**
   * Natural language description of the data structure to extract
   */
  prompt?: string | null;
  /**
   * Optional file ID to analyze for schema generation
   */
  file_id?: string | null;
  /**
   * Optional schema to validate, refine, or extend during generation
   */
  data_schema?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string
    | null;
};

/**
 * Response schema for schema generation.
 */
export type ExtractSchemaGenerateResponse = {
  /**
   * The generated JSON schema
   */
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
};

/**
 * Request schema for validating an extraction schema.
 */
export type ExtractSchemaValidateRequest = {
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
};

/**
 * Response schema for schema validation.
 */
export type ExtractSchemaValidateResponse = {
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
};

export type ExtractState = "CREATED" | "PENDING" | "SUCCESS" | "ERROR";

export const ExtractState = {
  CREATED: "CREATED",
  PENDING: "PENDING",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
} as const;

/**
 * Schema for stateless extraction requests.
 */
export type ExtractStatelessRequest = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The schema of the data to extract
   */
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
  /**
   * The configuration parameters for the extraction
   */
  config: ExtractConfig;
  /**
   * The ID of the file to extract from
   */
  file_id?: string | null;
  /**
   * The text content to extract from
   */
  text?: string | null;
  /**
   * The file data with base64 content and MIME type
   */
  file?: FileData | null;
};

/**
 * Defines the extraction target scope.
 */
export type ExtractTarget = "PER_DOC" | "PER_PAGE" | "PER_TABLE_ROW";

/**
 * Defines the extraction target scope.
 */
export const ExtractTarget = {
  PER_DOC: "PER_DOC",
  PER_PAGE: "PER_PAGE",
  PER_TABLE_ROW: "PER_TABLE_ROW",
} as const;

/**
 * A summary of a single extracted region from a spreadsheet
 */
export type ExtractedRegionSummary = {
  /**
   * Unique identifier for this region within the file
   */
  region_id?: string;
  /**
   * Worksheet name where region was found
   */
  sheet_name: string;
  /**
   * Location of the region in the spreadsheet
   */
  location: string;
  /**
   * Type of the extracted region
   */
  region_type: string;
  /**
   * Generated title for the region
   */
  title?: string | null;
  /**
   * Generated description for the region
   */
  description?: string | null;
};

/**
 * Enum for representing the different available page error handling modes
 */
export type FailPageMode = "raw_text" | "blank_page" | "error_message";

/**
 * Enum for representing the different available page error handling modes
 */
export const FailPageMode = {
  RAW_TEXT: "raw_text",
  BLANK_PAGE: "blank_page",
  ERROR_MESSAGE: "error_message",
} as const;

export type FailedMarkdownPage = {
  /**
   * Page number of the document
   */
  page_number: number;
  /**
   * Error message describing the failure
   */
  error: string;
  /**
   * Failure indicator
   */
  success?: false;
};

export type FailedStructuredPage = {
  /**
   * Page number of the document
   */
  page_number: number;
  /**
   * Error message describing the failure
   */
  error: string;
  /**
   * Failure indicator
   */
  success?: false;
};

/**
 * Configuration for handling different types of failures during data source processing.
 */
export type FailureHandlingConfig = {
  /**
   * Whether to skip failed batches/lists and continue processing
   */
  skip_list_failures?: boolean;
};

/**
 * Schema for a file.
 */
export type File = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name: string;
  /**
   * The ID of the file in the external system
   */
  external_file_id?: string | null;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
  /**
   * File type (e.g. pdf, docx, etc.)
   */
  file_type?: string | null;
  /**
   * The ID of the project that the file belongs to
   */
  project_id: string;
  /**
   * The last modified time of the file
   */
  last_modified_at?: string | null;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Permission information for the file
   */
  permission_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The ID of the data source that the file belongs to
   */
  data_source_id?: string | null;
};

/**
 * A file classification.
 */
export type FileClassification = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The ID of the classify job
   */
  classify_job_id: string;
  /**
   * The ID of the classified file
   */
  file_id: string;
  /**
   * The classification result
   */
  result?: ClassificationResult | null;
};

export type FileCountByStatusResponse = {
  /**
   * The counts of files by status
   */
  counts: {
    [key: string]: number;
  };
  /**
   * The total number of files
   */
  total_count: number;
  /**
   * The ID of the pipeline that the files belong to
   */
  pipeline_id?: string | null;
  /**
   * The ID of the data source that the files belong to
   */
  data_source_id?: string | null;
  /**
   * Whether to only count manually uploaded files
   */
  only_manually_uploaded?: boolean;
};

export type FileCreate = {
  /**
   * Name that will be used for created file. If possible, always include the file extension in the name.
   */
  name: string;
  /**
   * The ID of the file in the external system
   */
  external_file_id?: string | null;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
  /**
   * The last modified time of the file
   */
  last_modified_at?: string | null;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Permission information for the file
   */
  permission_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The ID of the data source that the file belongs to
   */
  data_source_id?: string | null;
};

export type FileCreateFromUrl = {
  /**
   * Name that will be used for created file. If possible, always include the file extension in the name.
   */
  name?: string | null;
  /**
   * URL of the file to download
   */
  url: string;
  /**
   * URL of the proxy server to use for downloading the file
   */
  proxy_url?: string | null;
  /**
   * Headers to include in the request when downloading the file
   */
  request_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Whether to verify the SSL certificate when downloading the file
   */
  verify_ssl?: boolean;
  /**
   * Whether to follow redirects when downloading the file
   */
  follow_redirects?: boolean;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
};

/**
 * Schema for file data with base64 content and MIME type.
 */
export type FileData = {
  /**
   * The file content as base64-encoded string
   */
  data: string;
  /**
   * The MIME type of the file (e.g., 'application/pdf', 'text/plain')
   */
  mime_type: string;
};

/**
 * Filter parameters for file queries.
 */
export type FileFilter = {
  /**
   * Filter by project ID
   */
  project_id?: string | null;
  /**
   * Filter by specific file IDs
   */
  file_ids?: Array<string> | null;
  /**
   * Filter by file name
   */
  file_name?: string | null;
  /**
   * Filter by data source ID
   */
  data_source_id?: string | null;
  /**
   * Filter by external file ID
   */
  external_file_id?: string | null;
  /**
   * Filter only manually uploaded files (data_source_id is null)
   */
  only_manually_uploaded?: boolean | null;
};

/**
 * Schema for a presigned URL with a file ID.
 */
export type FileIdPresignedUrl = {
  /**
   * A presigned URL for IO operations against a private file
   */
  url: string;
  /**
   * The time at which the presigned URL expires
   */
  expires_at: string;
  /**
   * Form fields for a presigned POST request
   */
  form_fields?: {
    [key: string]: string;
  } | null;
  /**
   * The ID of the file associated with the presigned URL
   */
  file_id: string;
};

/**
 * Request schema for querying files with pagination and filtering.
 */
export type FileQueryRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: FileFilter | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
};

/**
 * Response schema for paginated file queries.
 */
export type FileQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<File>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Vector store filter conditions to combine different filters.
 */
export type FilterCondition = "and" | "or" | "not";

/**
 * Vector store filter conditions to combine different filters.
 */
export const FilterCondition = {
  AND: "and",
  OR: "or",
  NOT: "not",
} as const;

/**
 * API request model for a filter comparison operation.
 */
export type FilterOperation = {
  eq?: number | number | string | null;
  gt?: number | number | string | null;
  gte?: number | number | string | null;
  lt?: number | number | string | null;
  lte?: number | number | string | null;
  includes?: Array<number | number | string | null>;
};

/**
 * Vector store filter operator.
 */
export type FilterOperator =
  | "=="
  | ">"
  | "<"
  | "!="
  | ">="
  | "<="
  | "in"
  | "nin"
  | "any"
  | "all"
  | "text_match"
  | "text_match_insensitive"
  | "contains"
  | "is_empty";

/**
 * Vector store filter operator.
 */
export const FilterOperator = {
  "==": "==",
  ">": ">",
  "<": "<",
  "!=": "!=",
  ">=": ">=",
  "<=": "<=",
  IN: "in",
  NIN: "nin",
  ANY: "any",
  ALL: "all",
  TEXT_MATCH: "text_match",
  TEXT_MATCH_INSENSITIVE: "text_match_insensitive",
  CONTAINS: "contains",
  IS_EMPTY: "is_empty",
} as const;

export type GeminiEmbedding = {
  /**
   * The modelId of the Gemini model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.
   */
  title?: string | null;
  /**
   * The task for embedding model.
   */
  task_type?: string | null;
  /**
   * API key to access the model. Defaults to None.
   */
  api_key?: string | null;
  /**
   * API base to access the model. Defaults to None.
   */
  api_base?: string | null;
  /**
   * Transport to access the model. Defaults to None.
   */
  transport?: string | null;
  class_name?: string;
};

export type GeminiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "GEMINI_EMBEDDING";
  /**
   * Configuration for the Gemini embedding model.
   */
  component?: GeminiEmbedding;
};

export type HttpValidationError = {
  detail?: Array<ValidationError>;
};

export type HeadingItem = {
  /**
   * Heading item type
   */
  type?: "heading";
  /**
   * Bounding box coordinates [x1, y1, x2, y2]
   */
  bBox?: [number, number, number, number] | null;
  /**
   * Heading level (1-6)
   */
  level: number;
  /**
   * Heading text content
   */
  value: string;
};

export type HuggingFaceInferenceApiEmbedding = {
  /**
   * Hugging Face model name. If None, the task will be used.
   */
  model_name?: string | null;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Pooling strategy. If None, the model's default pooling is used.
   */
  pooling?: Pooling | null;
  /**
   * Instruction to prepend during query embedding.
   */
  query_instruction?: string | null;
  /**
   * Instruction to prepend during text embedding.
   */
  text_instruction?: string | null;
  /**
   * Hugging Face token. Will default to the locally saved token. Pass token=False if you dont want to send your token to the server.
   */
  token?: string | boolean | null;
  /**
   * The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.
   */
  timeout?: number | null;
  /**
   * Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.
   */
  headers?: {
    [key: string]: string;
  } | null;
  /**
   * Additional cookies to send to the server.
   */
  cookies?: {
    [key: string]: string;
  } | null;
  /**
   * Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.
   */
  task?: string | null;
  class_name?: string;
};

export type HuggingFaceInferenceApiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "HUGGINGFACE_API_EMBEDDING";
  /**
   * Configuration for the HuggingFace Inference API embedding model.
   */
  component?: HuggingFaceInferenceApiEmbedding;
};

export type ImageItem = {
  /**
   * Image item type
   */
  type?: "image";
  /**
   * Bounding box coordinates [x1, y1, x2, y2]
   */
  bBox?: [number, number, number, number] | null;
  /**
   * Image filename or identifier
   */
  name: string;
};

export type IngestionErrorResponse = {
  /**
   * ID of the job that failed.
   */
  job_id: string;
  /**
   * List of errors that occurred during ingestion.
   */
  message: string;
  /**
   * Name of the job that failed.
   */
  step: JobNameMapping;
};

/**
 * This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend
 */
export type InputMessage = {
  /**
   * ID of the message, if any. a UUID.
   */
  id?: string;
  role: MessageRole;
  content: string;
  /**
   * Additional data to be stored with the message.
   */
  data?: {
    [key: string]: unknown;
  } | null;
  class_name?: string;
};

/**
 * Response containing all processing results for an item.
 */
export type ItemProcessingResultsResponse = {
  /**
   * ID of the source item
   */
  item_id: string;
  /**
   * Name of the source item
   */
  item_name: string;
  /**
   * List of all processing operations performed on this item
   */
  processing_results?: Array<ProcessingResult>;
};

/**
 * Enum for mapping original job names to readable names.
 */
export type JobNameMapping =
  | "MANAGED_INGESTION"
  | "DATA_SOURCE"
  | "FILE_UPDATER"
  | "PARSE"
  | "TRANSFORM"
  | "INGESTION"
  | "METADATA_UPDATE";

/**
 * Enum for mapping original job names to readable names.
 */
export const JobNameMapping = {
  MANAGED_INGESTION: "MANAGED_INGESTION",
  DATA_SOURCE: "DATA_SOURCE",
  FILE_UPDATER: "FILE_UPDATER",
  PARSE: "PARSE",
  TRANSFORM: "TRANSFORM",
  INGESTION: "INGESTION",
  METADATA_UPDATE: "METADATA_UPDATE",
} as const;

export type LlmParameters = {
  /**
   * The name of the model to use for LLM completions.
   */
  model_name?: SupportedLlmModelNames;
  /**
   * The system prompt to use for the completion.
   */
  system_prompt?: string | null;
  /**
   * The temperature value for the model.
   */
  temperature?: number | null;
  /**
   * Whether to use chain of thought reasoning.
   */
  use_chain_of_thought_reasoning?: boolean | null;
  /**
   * Whether to show citations in the response.
   */
  use_citation?: boolean | null;
  class_name?: string;
};

export type ListItem = {
  /**
   * List item type
   */
  type?: "list";
  /**
   * Bounding box coordinates [x1, y1, x2, y2]
   */
  bBox?: [number, number, number, number] | null;
  /**
   * List of nested text or list items
   */
  items: Array<TextItem | ListItem>;
  /**
   * Whether the list is ordered or unordered
   */
  ordered: boolean;
};

export type ListingStatusDetails = {
  /**
   * Status of the listing process
   */
  status?: "pending" | "processing" | "completed" | "failed";
  effective_at?: string;
  /**
   * The job record ID associated with this status, if any.
   */
  job_record_id?: string | null;
  /**
   * Error message for the latest job attempt, if any.
   */
  error_message?: string | null;
};

/**
 * Options for agentic tier parsing (with AI agents).
 */
export type LlamaParseAgenticOptions = {
  /**
   * Options for ignoring specific text types
   */
  ignore?: LlamaParseIgnoreOptions;
  /**
   * OCR configuration parameters
   */
  ocr_parameters?: LlamaParseOcrParameters;
  /**
   * Whether to use aggressive table extraction
   */
  aggressive_table_extraction?: boolean | null;
};

export type LlamaParseCropBox = {
  /**
   * Bottom boundary of crop box as ratio (0-1)
   */
  bottom?: number | null;
  /**
   * Left boundary of crop box as ratio (0-1)
   */
  left?: number | null;
  /**
   * Right boundary of crop box as ratio (0-1)
   */
  right?: number | null;
  /**
   * Top boundary of crop box as ratio (0-1)
   */
  top?: number | null;
};

export type LlamaParseEmbeddedImagesOptions = {
  /**
   * Whether this option is enabled
   */
  enable?: boolean | null;
};

export type LlamaParseExportPdfOptions = {
  /**
   * Whether this option is enabled
   */
  enable?: boolean | null;
};

/**
 * Options for fast tier parsing (without AI).
 */
export type LlamaParseFastOptions = {
  /**
   * Options for ignoring specific text types
   */
  ignore?: LlamaParseIgnoreOptions;
  /**
   * OCR configuration parameters
   */
  ocr_parameters?: LlamaParseOcrParameters;
  /**
   * Whether to use aggressive table extraction
   */
  aggressive_table_extraction?: boolean | null;
};

/**
 * Configuration schema for file ID-based parsing endpoint.
 */
export type LlamaParseFileIdConfiguration = {
  /**
   * Name of the client making the parsing request
   */
  client_name?: string | null;
  /**
   * Parsing tier and related configuration options
   */
  parse_options: LlamaParseTierOptions;
  /**
   * List of webhook configurations for notifications
   */
  webhook_configurations?: Array<LlamaParseWebhookConfiguration>;
  /**
   * Input format-specific parsing options
   */
  input_options?: LlamaParseInputOptions;
  /**
   * Document crop box boundaries
   */
  crop_box?: LlamaParseCropBox;
  /**
   * Page range selection options
   */
  page_ranges?: LlamaParsePageRanges;
  /**
   * Whether to disable caching for this parsing job
   */
  disable_cache?: boolean | null;
  /**
   * Output format and styling options
   */
  output_options?: LlamaParseOutputOptions;
  /**
   * Job processing control and failure handling
   */
  processing_control?: LlamaParseProcessingControl;
  /**
   * ID of an existing file in the project to parse
   */
  file_id: string;
};

export type LlamaParseHtmlOptions = {
  /**
   * Make all HTML elements visible during parsing
   */
  make_all_elements_visible?: boolean | null;
  /**
   * Remove fixed position elements from HTML
   */
  remove_fixed_elements?: boolean | null;
  /**
   * Remove navigation elements from HTML
   */
  remove_navigation_elements?: boolean | null;
};

export type LlamaParseIgnoreOptions = {
  /**
   * Whether to ignore diagonal text in the document
   */
  ignore_diagonal_text?: boolean | null;
  /**
   * Whether to ignore strikethrough text in the document
   */
  ignore_strikethrough_text?: boolean | null;
  /**
   * Whether to ignore text that appears within images
   */
  ignore_text_in_image?: boolean | null;
  /**
   * Whether to ignore hidden text in the document
   */
  ignore_hidden_text?: boolean | null;
};

export type LlamaParseInputOptions = {
  /**
   * HTML-specific parsing options
   */
  html?: LlamaParseHtmlOptions;
  /**
   * PDF-specific parsing options
   */
  pdf?: LlamaParsePdfOptions;
  /**
   * Spreadsheet-specific parsing options
   */
  spreadsheet?: LlamaParseSpreadsheetOptions;
  /**
   * Presentation-specific parsing options
   */
  presentation?: LlamaParsePresentationOptions;
};

export type LlamaParseJobFailureConditions = {
  /**
   * Maximum ratio of pages allowed to fail (0-1)
   */
  allowed_page_failure_ratio?: number | null;
  /**
   * Fail job if image extraction encounters errors
   */
  fail_on_image_extraction_error?: boolean | null;
  /**
   * Fail job if image OCR encounters errors
   */
  fail_on_image_ocr_error?: boolean | null;
  /**
   * Fail job if markdown reconstruction encounters errors
   */
  fail_on_markdown_reconstruction_error?: boolean | null;
  /**
   * Fail job if buggy fonts are detected
   */
  fail_on_buggy_font?: boolean | null;
};

export type LlamaParseMarkdownOptions = {
  /**
   * Add annotations to links in markdown output
   */
  annotate_links?: boolean | null;
  /**
   * Page formatting options for markdown
   */
  pages?: LlamaParsePages;
  /**
   * Table formatting options for markdown
   */
  tables?: LlamaParseTables;
};

export type LlamaParseOcrParameters = {
  /**
   * List of languages to use for OCR processing
   */
  languages?: Array<ParserLanguages> | null;
};

export type LlamaParseOutputOptions = {
  /**
   * Markdown output formatting options
   */
  markdown?: LlamaParseMarkdownOptions;
  /**
   * Spatial text output options
   */
  spatial_text?: LlamaParseSpatialTextOptions;
  /**
   * Table export as spreadsheet options
   */
  tables_as_spreadsheet?: LlamaParseTablesAsSpreadsheetOptions;
  /**
   * Embedded image extraction options
   */
  embedded_images?: LlamaParseEmbeddedImagesOptions;
  /**
   * Screenshot generation options
   */
  screenshots?: LlamaParseScreenshotsOptions;
  /**
   * PDF export options
   */
  export_pdf?: LlamaParseExportPdfOptions;
  /**
   * Extract printed page numbers from the document
   */
  extract_printed_page_number?: boolean | null;
};

export type LlamaParsePageRanges = {
  /**
   * Maximum number of pages to process
   */
  max_pages?: number | null;
  /**
   * Specific pages to process (e.g., '1,3,5-10')
   */
  target_pages?: string | null;
};

export type LlamaParsePages = {
  /**
   * Merge tables that span across pages in markdown output
   */
  merge_tables_across_pages_in_markdown?: boolean | null;
};

/**
 * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
 */
export type LlamaParseParameters = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  languages?: Array<ParserLanguages>;
  parsing_instruction?: string | null;
  disable_ocr?: boolean | null;
  annotate_links?: boolean | null;
  adaptive_long_table?: boolean | null;
  compact_markdown_table?: boolean | null;
  disable_reconstruction?: boolean | null;
  disable_image_extraction?: boolean | null;
  invalidate_cache?: boolean | null;
  outlined_table_extraction?: boolean | null;
  aggressive_table_extraction?: boolean | null;
  merge_tables_across_pages_in_markdown?: boolean | null;
  output_pdf_of_document?: boolean | null;
  do_not_cache?: boolean | null;
  fast_mode?: boolean | null;
  skip_diagonal_text?: boolean | null;
  preserve_layout_alignment_across_pages?: boolean | null;
  preserve_very_small_text?: boolean | null;
  gpt4o_mode?: boolean | null;
  gpt4o_api_key?: string | null;
  do_not_unroll_columns?: boolean | null;
  extract_layout?: boolean | null;
  high_res_ocr?: boolean | null;
  html_make_all_elements_visible?: boolean | null;
  layout_aware?: boolean | null;
  specialized_chart_parsing_agentic?: boolean | null;
  specialized_chart_parsing_plus?: boolean | null;
  specialized_chart_parsing_efficient?: boolean | null;
  specialized_image_parsing?: boolean | null;
  precise_bounding_box?: boolean | null;
  line_level_bounding_box?: boolean | null;
  html_remove_navigation_elements?: boolean | null;
  html_remove_fixed_elements?: boolean | null;
  guess_xlsx_sheet_name?: boolean | null;
  page_separator?: string | null;
  bounding_box?: string | null;
  bbox_top?: number | null;
  bbox_right?: number | null;
  bbox_bottom?: number | null;
  bbox_left?: number | null;
  target_pages?: string | null;
  use_vendor_multimodal_model?: boolean | null;
  vendor_multimodal_model_name?: string | null;
  model?: string | null;
  vendor_multimodal_api_key?: string | null;
  page_prefix?: string | null;
  page_suffix?: string | null;
  webhook_url?: string | null;
  preset?: string | null;
  take_screenshot?: boolean | null;
  is_formatting_instruction?: boolean | null;
  premium_mode?: boolean | null;
  continuous_mode?: boolean | null;
  input_s3_path?: string | null;
  input_s3_region?: string | null;
  output_s3_path_prefix?: string | null;
  output_s3_region?: string | null;
  project_id?: string | null;
  azure_openai_deployment_name?: string | null;
  azure_openai_endpoint?: string | null;
  azure_openai_api_version?: string | null;
  azure_openai_key?: string | null;
  input_url?: string | null;
  http_proxy?: string | null;
  auto_mode?: boolean | null;
  auto_mode_trigger_on_regexp_in_page?: string | null;
  auto_mode_trigger_on_text_in_page?: string | null;
  auto_mode_trigger_on_table_in_page?: boolean | null;
  auto_mode_trigger_on_image_in_page?: boolean | null;
  auto_mode_configuration_json?: string | null;
  structured_output?: boolean | null;
  structured_output_json_schema?: string | null;
  structured_output_json_schema_name?: string | null;
  max_pages?: number | null;
  max_pages_enforced?: number | null;
  extract_charts?: boolean | null;
  formatting_instruction?: string | null;
  complemental_formatting_instruction?: string | null;
  content_guideline_instruction?: string | null;
  spreadsheet_extract_sub_tables?: boolean | null;
  spreadsheet_force_formula_computation?: boolean | null;
  inline_images_in_markdown?: boolean | null;
  job_timeout_in_seconds?: number | null;
  job_timeout_extra_time_per_page_in_seconds?: number | null;
  strict_mode_image_extraction?: boolean | null;
  strict_mode_image_ocr?: boolean | null;
  strict_mode_reconstruction?: boolean | null;
  strict_mode_buggy_font?: boolean | null;
  save_images?: boolean | null;
  hide_headers?: boolean | null;
  hide_footers?: boolean | null;
  page_header_prefix?: string | null;
  page_header_suffix?: string | null;
  page_footer_prefix?: string | null;
  page_footer_suffix?: string | null;
  remove_hidden_text?: boolean | null;
  keep_page_separator_when_merging_tables?: boolean | null;
  ignore_document_elements_for_layout_detection?: boolean | null;
  output_tables_as_HTML?: boolean | null;
  internal_is_screenshot_job?: boolean | null;
  parse_mode?: ParsingMode | null;
  system_prompt?: string | null;
  system_prompt_append?: string | null;
  user_prompt?: string | null;
  page_error_tolerance?: number | null;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string | null;
  replace_failed_page_with_error_message_suffix?: string | null;
  markdown_table_multiline_header_separator?: string | null;
  presentation_out_of_bounds_content?: boolean | null;
  tier?: string | null;
  version?: string | null;
  extract_printed_page_number?: boolean | null;
};

export type LlamaParsePdfOptions = {
  [key: string]: never;
};

export type LlamaParsePresentationOptions = {
  /**
   * Extract out of bounds content in presentation slides
   */
  out_of_bounds_content?: boolean | null;
};

export type LlamaParseProcessingControl = {
  /**
   * Timeout configuration for parsing jobs
   */
  timeouts?: LlamaParseTimeouts;
  /**
   * Conditions that determine job failure
   */
  job_failure_conditions?: LlamaParseJobFailureConditions;
};

export type LlamaParseScreenshotsOptions = {
  /**
   * Whether this option is enabled
   */
  enable?: boolean | null;
};

export type LlamaParseSpatialTextOptions = {
  /**
   * Preserve text alignment across page boundaries
   */
  preserve_layout_alignment_across_pages?: boolean | null;
  /**
   * Include very small text in spatial output
   */
  preserve_very_small_text?: boolean | null;
  /**
   * Keep column structure intact without unrolling
   */
  do_not_unroll_columns?: boolean | null;
  /**
   * Page formatting options for spatial text
   */
  pages?: LlamaParsePages | null;
};

export type LlamaParseSpreadsheetOptions = {
  /**
   * Detect and extract sub-tables within spreadsheet cells
   */
  detect_sub_tables_in_sheets?: boolean | null;
  /**
   * Force re-computation of spreadsheet cells containing formulas
   */
  force_formula_computation_in_sheets?: boolean | null;
};

export type LlamaParseSupportedFileExtensions =
  | ".pdf"
  | ".doc"
  | ".docx"
  | ".docm"
  | ".dot"
  | ".dotx"
  | ".dotm"
  | ".rtf"
  | ".wps"
  | ".wpd"
  | ".sxw"
  | ".stw"
  | ".sxg"
  | ".pages"
  | ".mw"
  | ".mcw"
  | ".uot"
  | ".uof"
  | ".uos"
  | ".uop"
  | ".ppt"
  | ".pptx"
  | ".pot"
  | ".pptm"
  | ".potx"
  | ".potm"
  | ".key"
  | ".odp"
  | ".odg"
  | ".otp"
  | ".fopd"
  | ".sxi"
  | ".sti"
  | ".epub"
  | ".jpg"
  | ".jpeg"
  | ".png"
  | ".gif"
  | ".bmp"
  | ".svg"
  | ".tiff"
  | ".webp"
  | ".html"
  | ".htm"
  | ".xls"
  | ".xlsx"
  | ".xlsm"
  | ".xlsb"
  | ".xlw"
  | ".csv"
  | ".dif"
  | ".sylk"
  | ".slk"
  | ".prn"
  | ".numbers"
  | ".et"
  | ".ods"
  | ".fods"
  | ".uos1"
  | ".uos2"
  | ".dbf"
  | ".wk1"
  | ".wk2"
  | ".wk3"
  | ".wk4"
  | ".wks"
  | ".wq1"
  | ".wq2"
  | ".wb1"
  | ".wb2"
  | ".wb3"
  | ".qpw"
  | ".xlr"
  | ".eth"
  | ".tsv";

export const LlamaParseSupportedFileExtensions = {
  ".PDF": ".pdf",
  ".DOC": ".doc",
  ".DOCX": ".docx",
  ".DOCM": ".docm",
  ".DOT": ".dot",
  ".DOTX": ".dotx",
  ".DOTM": ".dotm",
  ".RTF": ".rtf",
  ".WPS": ".wps",
  ".WPD": ".wpd",
  ".SXW": ".sxw",
  ".STW": ".stw",
  ".SXG": ".sxg",
  ".PAGES": ".pages",
  ".MW": ".mw",
  ".MCW": ".mcw",
  ".UOT": ".uot",
  ".UOF": ".uof",
  ".UOS": ".uos",
  ".UOP": ".uop",
  ".PPT": ".ppt",
  ".PPTX": ".pptx",
  ".POT": ".pot",
  ".PPTM": ".pptm",
  ".POTX": ".potx",
  ".POTM": ".potm",
  ".KEY": ".key",
  ".ODP": ".odp",
  ".ODG": ".odg",
  ".OTP": ".otp",
  ".FOPD": ".fopd",
  ".SXI": ".sxi",
  ".STI": ".sti",
  ".EPUB": ".epub",
  ".JPG": ".jpg",
  ".JPEG": ".jpeg",
  ".PNG": ".png",
  ".GIF": ".gif",
  ".BMP": ".bmp",
  ".SVG": ".svg",
  ".TIFF": ".tiff",
  ".WEBP": ".webp",
  ".HTML": ".html",
  ".HTM": ".htm",
  ".XLS": ".xls",
  ".XLSX": ".xlsx",
  ".XLSM": ".xlsm",
  ".XLSB": ".xlsb",
  ".XLW": ".xlw",
  ".CSV": ".csv",
  ".DIF": ".dif",
  ".SYLK": ".sylk",
  ".SLK": ".slk",
  ".PRN": ".prn",
  ".NUMBERS": ".numbers",
  ".ET": ".et",
  ".ODS": ".ods",
  ".FODS": ".fods",
  ".UOS1": ".uos1",
  ".UOS2": ".uos2",
  ".DBF": ".dbf",
  ".WK1": ".wk1",
  ".WK2": ".wk2",
  ".WK3": ".wk3",
  ".WK4": ".wk4",
  ".WKS": ".wks",
  ".WQ1": ".wq1",
  ".WQ2": ".wq2",
  ".WB1": ".wb1",
  ".WB2": ".wb2",
  ".WB3": ".wb3",
  ".QPW": ".qpw",
  ".XLR": ".xlr",
  ".ETH": ".eth",
  ".TSV": ".tsv",
} as const;

export type LlamaParseTables = {
  /**
   * Use compact formatting for markdown tables
   */
  compact_markdown_tables?: boolean | null;
  /**
   * Output tables in markdown format
   */
  output_tables_as_markdown?: boolean | null;
  /**
   * Separator for multiline content in markdown tables
   */
  markdown_table_multiline_separator?: string | null;
};

export type LlamaParseTablesAsSpreadsheetOptions = {
  /**
   * Whether this option is enabled
   */
  enable?: boolean | null;
  /**
   * Automatically guess sheet names when exporting tables
   */
  guess_sheet_name?: boolean;
};

/**
 * Base configuration for tier-based parsing.
 */
export type LlamaParseTierOptions = {
  /**
   * The parsing tier to use
   */
  tier: TierName;
  /**
   * Version of the tier configuration
   */
  version?: "2025-11-18" | "latest";
  /**
   * Options for fast tier parsing
   */
  fast_options?: LlamaParseFastOptions | null;
  /**
   * Options for agentic tier parsing
   */
  agentic_options?: LlamaParseAgenticOptions | null;
};

export type LlamaParseTimeouts = {
  /**
   * Base timeout in seconds (max 30 minutes)
   */
  base_in_seconds?: number | null;
  /**
   * Additional timeout per page in seconds (max 5 minutes)
   */
  extra_time_per_page_in_seconds?: number | null;
};

/**
 * Configuration schema for URL-based parsing endpoint.
 */
export type LlamaParseUrlConfiguration = {
  /**
   * Name of the client making the parsing request
   */
  client_name?: string | null;
  /**
   * Parsing tier and related configuration options
   */
  parse_options: LlamaParseTierOptions;
  /**
   * List of webhook configurations for notifications
   */
  webhook_configurations?: Array<LlamaParseWebhookConfiguration>;
  /**
   * Input format-specific parsing options
   */
  input_options?: LlamaParseInputOptions;
  /**
   * Document crop box boundaries
   */
  crop_box?: LlamaParseCropBox;
  /**
   * Page range selection options
   */
  page_ranges?: LlamaParsePageRanges;
  /**
   * Whether to disable caching for this parsing job
   */
  disable_cache?: boolean | null;
  /**
   * Output format and styling options
   */
  output_options?: LlamaParseOutputOptions;
  /**
   * Job processing control and failure handling
   */
  processing_control?: LlamaParseProcessingControl;
  /**
   * Source URL to fetch document from
   */
  source_url: string;
  /**
   * HTTP proxy URL for network requests
   */
  http_proxy?: string | null;
};

export type LlamaParseWebhookConfiguration = {
  /**
   * Webhook URL for receiving parsing notifications
   */
  webhook_url?: string | null;
  /**
   * Custom headers to include in webhook requests
   */
  webhook_headers?: {
    [key: string]: unknown;
  } | null;
  /**
   * List of events that trigger webhook notifications
   */
  webhook_events?: Array<string> | null;
};

/**
 * Status of managed ingestion with partial Updates.
 */
export type ManagedIngestionStatus =
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "SUCCESS"
  | "ERROR"
  | "PARTIAL_SUCCESS"
  | "CANCELLED";

/**
 * Status of managed ingestion with partial Updates.
 */
export const ManagedIngestionStatus = {
  NOT_STARTED: "NOT_STARTED",
  IN_PROGRESS: "IN_PROGRESS",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  PARTIAL_SUCCESS: "PARTIAL_SUCCESS",
  CANCELLED: "CANCELLED",
} as const;

export type ManagedIngestionStatusResponse = {
  /**
   * ID of the latest job.
   */
  job_id?: string | null;
  /**
   * Date of the deployment.
   */
  deployment_date?: string | null;
  /**
   * Status of the ingestion.
   */
  status: ManagedIngestionStatus;
  /**
   * List of errors that occurred during ingestion.
   */
  error?: Array<IngestionErrorResponse> | null;
  /**
   * When the status is effective
   */
  effective_at?: string | null;
};

export type ManagedOpenAiEmbedding = {
  /**
   * The name of the OpenAI embedding model.
   */
  model_name?: "openai-text-embedding-3-small";
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  class_name?: string;
};

export type ManagedOpenAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "MANAGED_OPENAI_EMBEDDING";
  /**
   * Configuration for the Managed OpenAI embedding model.
   */
  component?: ManagedOpenAiEmbedding;
};

export type MarkdownResult = {
  /**
   * List of markdown pages or failed page entries
   */
  pages: Array<MarkdownResultPage | FailedMarkdownPage>;
};

export type MarkdownResultPage = {
  /**
   * Page number of the document
   */
  page_number: number;
  /**
   * Markdown content of the page
   */
  markdown: string;
  /**
   * Success indicator
   */
  success?: true;
};

export type MessageAnnotation = {
  type: string;
  data: string;
  class_name?: string;
};

/**
 * Message role.
 */
export type MessageRole =
  | "system"
  | "developer"
  | "user"
  | "assistant"
  | "function"
  | "tool"
  | "chatbot"
  | "model";

/**
 * Message role.
 */
export const MessageRole = {
  SYSTEM: "system",
  DEVELOPER: "developer",
  USER: "user",
  ASSISTANT: "assistant",
  FUNCTION: "function",
  TOOL: "tool",
  CHATBOT: "chatbot",
  MODEL: "model",
} as const;

/**
 * Comprehensive metadata filter for vector stores to support more operators.
 *
 * Value uses Strict types, as int, float and str are compatible types and were all
 * converted to string before.
 *
 * See: https://docs.pydantic.dev/latest/usage/types/#strict-types
 */
export type MetadataFilter = {
  key: string;
  value:
    | number
    | number
    | string
    | Array<string>
    | Array<number>
    | Array<number>
    | null;
  operator?: FilterOperator;
};

/**
 * Metadata filters for vector stores.
 */
export type MetadataFilters = {
  filters: Array<MetadataFilter | MetadataFilters>;
  condition?: FilterCondition | null;
};

/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */
export type NodeRelationship = "1" | "2" | "3" | "4" | "5";

/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */
export const NodeRelationship = {
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
} as const;

export type NoneChunkingConfig = {
  mode?: "none";
};

export type NoneSegmentationConfig = {
  mode?: "none";
};

export type ObjectType = "1" | "2" | "3" | "4" | "5";

export const ObjectType = {
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
} as const;

export type OpenAiEmbedding = {
  /**
   * The name of the OpenAI embedding model.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Additional kwargs for the OpenAI API.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  /**
   * The OpenAI API key.
   */
  api_key?: string | null;
  /**
   * The base URL for OpenAI API.
   */
  api_base?: string | null;
  /**
   * The version for OpenAI API.
   */
  api_version?: string | null;
  /**
   * Maximum number of retries.
   */
  max_retries?: number;
  /**
   * Timeout for each request.
   */
  timeout?: number;
  /**
   * The default headers for API requests.
   */
  default_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
   */
  reuse_client?: boolean;
  /**
   * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
   */
  dimensions?: number | null;
  class_name?: string;
};

export type OpenAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "OPENAI_EMBEDDING";
  /**
   * Configuration for the OpenAI embedding model.
   */
  component?: OpenAiEmbedding;
};

/**
 * Schema for an organization.
 */
export type Organization = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * A name for the organization.
   */
  name: string;
  /**
   * [Deprecated] Whether the organization is a Parse Premium customer.
   */
  parse_plan_level?: ParsePlanLevel;
  /**
   * The Stripe customer ID for the organization.
   */
  stripe_customer_id?: string | null;
  /**
   * Feature flags for the organization.
   */
  feature_flags?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Distance methods for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export type PgVectorDistanceMethod =
  | "l2"
  | "ip"
  | "cosine"
  | "l1"
  | "hamming"
  | "jaccard";

/**
 * Distance methods for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export const PgVectorDistanceMethod = {
  L2: "l2",
  IP: "ip",
  COSINE: "cosine",
  L1: "l1",
  HAMMING: "hamming",
  JACCARD: "jaccard",
} as const;

/**
 * HNSW settings for PGVector.
 */
export type PgVectorHnswSettings = {
  /**
   * The number of edges to use during the construction phase.
   */
  ef_construction?: number;
  /**
   * The number of edges to use during the search phase.
   */
  ef_search?: number;
  /**
   * The number of bi-directional links created for each new element.
   */
  m?: number;
  /**
   * The type of vector to use.
   */
  vector_type?: PgVectorVectorType;
  /**
   * The distance method to use.
   */
  distance_method?: PgVectorDistanceMethod;
};

/**
 * Vector storage formats for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export type PgVectorVectorType = "vector" | "half_vec" | "bit" | "sparse_vec";

/**
 * Vector storage formats for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export const PgVectorVectorType = {
  VECTOR: "vector",
  HALF_VEC: "half_vec",
  BIT: "bit",
  SPARSE_VEC: "sparse_vec",
} as const;

export type PageFigureMetadata = {
  /**
   * The name of the figure
   */
  figure_name: string;
  /**
   * The ID of the file that the figure was taken from
   */
  file_id: string;
  /**
   * The index of the page for which the figure is taken (0-indexed)
   */
  page_index: number;
  /**
   * The size of the figure in bytes
   */
  figure_size: number;
  /**
   * Whether the figure is likely to be noise
   */
  is_likely_noise?: boolean;
  /**
   * The confidence of the figure
   */
  confidence: number;
  /**
   * Metadata for the figure
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Page figure metadata with score
 */
export type PageFigureNodeWithScore = {
  node: PageFigureMetadata;
  /**
   * The score of the figure node
   */
  score: number;
  class_name?: string;
};

export type PageScreenshotMetadata = {
  /**
   * The index of the page for which the screenshot is taken (0-indexed)
   */
  page_index: number;
  /**
   * The ID of the file that the page screenshot was taken from
   */
  file_id: string;
  /**
   * The size of the image in bytes
   */
  image_size: number;
  /**
   * Metadata for the screenshot
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Page screenshot metadata with score
 */
export type PageScreenshotNodeWithScore = {
  node: PageScreenshotMetadata;
  /**
   * The score of the screenshot node
   */
  score: number;
  class_name?: string;
};

export type PageSegmentationConfig = {
  mode?: "page";
  page_separator?: string;
};

/**
 * Schema for paginated extraction runs response.
 */
export type PaginatedExtractRunsResponse = {
  /**
   * The list of extraction runs
   */
  items: Array<ExtractRun>;
  /**
   * The total number of extraction runs
   */
  total: number;
  /**
   * The number of extraction runs skipped
   */
  skip: number;
  /**
   * The maximum number of extraction runs returned
   */
  limit: number;
};

export type PaginatedListCloudDocumentsResponse = {
  /**
   * The documents to list
   */
  documents: Array<CloudDocument>;
  /**
   * The limit of the documents
   */
  limit: number;
  /**
   * The offset of the documents
   */
  offset: number;
  /**
   * The total number of documents
   */
  total_count: number;
};

export type PaginatedListPipelineFilesResponse = {
  /**
   * The files to list
   */
  files: Array<PipelineFile>;
  /**
   * The limit of the files
   */
  limit: number;
  /**
   * The offset of the files
   */
  offset: number;
  /**
   * The total number of files
   */
  total_count: number;
};

export type PaginatedResponseAgentData = {
  /**
   * The list of items.
   */
  items: Array<AgentData>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type PaginatedResponseAggregateGroup = {
  /**
   * The list of items.
   */
  items: Array<AggregateGroup>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type PaginatedResponseClassifyJob = {
  /**
   * The list of items.
   */
  items: Array<ClassifyJob>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type PaginatedResponseSpreadsheetJob = {
  /**
   * The list of items.
   */
  items: Array<SpreadsheetJob>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Parse configuration schema.
 */
export type ParseConfiguration = {
  /**
   * Unique identifier for the parse configuration
   */
  id: string;
  /**
   * Name of the parse configuration
   */
  name: string;
  /**
   * Type of the source (e.g., 'project')
   */
  source_type: string;
  /**
   * ID of the source
   */
  source_id: string;
  /**
   * Creator of the configuration
   */
  creator?: string | null;
  /**
   * Version of the configuration
   */
  version: string;
  /**
   * LlamaParseParameters configuration
   */
  parameters: LlamaParseParameters;
  /**
   * Creation timestamp
   */
  created_at: string;
  /**
   * Last update timestamp
   */
  updated_at: string;
};

/**
 * Schema for creating a new parse configuration (API boundary).
 */
export type ParseConfigurationCreate = {
  /**
   * Name of the parse configuration
   */
  name: string;
  /**
   * Type of the source (e.g., 'project')
   */
  source_type?: string | null;
  /**
   * ID of the source
   */
  source_id?: string | null;
  /**
   * Creator of the configuration
   */
  creator?: string | null;
  /**
   * Version of the configuration
   */
  version: string;
  /**
   * LlamaParseParameters configuration
   */
  parameters: LlamaParseParameters;
};

/**
 * Response schema for paginated parse configuration queries.
 */
export type ParseConfigurationQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<ParseConfiguration>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Schema for updating an existing parse configuration.
 */
export type ParseConfigurationUpdate = {
  /**
   * Updated LlamaParseParameters configuration
   */
  parameters?: LlamaParseParameters | null;
};

/**
 * Enum for the Parse plan level.
 */
export type ParsePlanLevel = "DEFAULT" | "PREMIUM";

/**
 * Enum for the Parse plan level.
 */
export const ParsePlanLevel = {
  DEFAULT: "DEFAULT",
  PREMIUM: "PREMIUM",
} as const;

/**
 * Enum for representing the languages supported by the parser
 */
export type ParserLanguages =
  | "af"
  | "az"
  | "bs"
  | "cs"
  | "cy"
  | "da"
  | "de"
  | "en"
  | "es"
  | "et"
  | "fr"
  | "ga"
  | "hr"
  | "hu"
  | "id"
  | "is"
  | "it"
  | "ku"
  | "la"
  | "lt"
  | "lv"
  | "mi"
  | "ms"
  | "mt"
  | "nl"
  | "no"
  | "oc"
  | "pi"
  | "pl"
  | "pt"
  | "ro"
  | "rs_latin"
  | "sk"
  | "sl"
  | "sq"
  | "sv"
  | "sw"
  | "tl"
  | "tr"
  | "uz"
  | "vi"
  | "ar"
  | "fa"
  | "ug"
  | "ur"
  | "bn"
  | "as"
  | "mni"
  | "ru"
  | "rs_cyrillic"
  | "be"
  | "bg"
  | "uk"
  | "mn"
  | "abq"
  | "ady"
  | "kbd"
  | "ava"
  | "dar"
  | "inh"
  | "che"
  | "lbe"
  | "lez"
  | "tab"
  | "tjk"
  | "hi"
  | "mr"
  | "ne"
  | "bh"
  | "mai"
  | "ang"
  | "bho"
  | "mah"
  | "sck"
  | "new"
  | "gom"
  | "sa"
  | "bgc"
  | "th"
  | "ch_sim"
  | "ch_tra"
  | "ja"
  | "ko"
  | "ta"
  | "te"
  | "kn";

/**
 * Enum for representing the languages supported by the parser
 */
export const ParserLanguages = {
  AF: "af",
  AZ: "az",
  BS: "bs",
  CS: "cs",
  CY: "cy",
  DA: "da",
  DE: "de",
  EN: "en",
  ES: "es",
  ET: "et",
  FR: "fr",
  GA: "ga",
  HR: "hr",
  HU: "hu",
  ID: "id",
  IS: "is",
  IT: "it",
  KU: "ku",
  LA: "la",
  LT: "lt",
  LV: "lv",
  MI: "mi",
  MS: "ms",
  MT: "mt",
  NL: "nl",
  NO: "no",
  OC: "oc",
  PI: "pi",
  PL: "pl",
  PT: "pt",
  RO: "ro",
  RS_LATIN: "rs_latin",
  SK: "sk",
  SL: "sl",
  SQ: "sq",
  SV: "sv",
  SW: "sw",
  TL: "tl",
  TR: "tr",
  UZ: "uz",
  VI: "vi",
  AR: "ar",
  FA: "fa",
  UG: "ug",
  UR: "ur",
  BN: "bn",
  AS: "as",
  MNI: "mni",
  RU: "ru",
  RS_CYRILLIC: "rs_cyrillic",
  BE: "be",
  BG: "bg",
  UK: "uk",
  MN: "mn",
  ABQ: "abq",
  ADY: "ady",
  KBD: "kbd",
  AVA: "ava",
  DAR: "dar",
  INH: "inh",
  CHE: "che",
  LBE: "lbe",
  LEZ: "lez",
  TAB: "tab",
  TJK: "tjk",
  HI: "hi",
  MR: "mr",
  NE: "ne",
  BH: "bh",
  MAI: "mai",
  ANG: "ang",
  BHO: "bho",
  MAH: "mah",
  SCK: "sck",
  NEW: "new",
  GOM: "gom",
  SA: "sa",
  BGC: "bgc",
  TH: "th",
  CH_SIM: "ch_sim",
  CH_TRA: "ch_tra",
  JA: "ja",
  KO: "ko",
  TA: "ta",
  TE: "te",
  KN: "kn",
} as const;

export type ParsingJob = {
  id: string;
  status: StatusEnum;
  error_code?: string | null;
  error_message?: string | null;
};

export type ParsingJobJsonResult = {
  /**
   * The json result of the parsing job
   */
  pages: unknown;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

export type ParsingJobMarkdownResult = {
  /**
   * The markdown result of the parsing job
   */
  markdown: string;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

export type ParsingJobStructuredResult = {
  /**
   * The json result of the structured parsing job
   */
  structured: unknown;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

export type ParsingJobTextResult = {
  /**
   * The text result of the parsing job
   */
  text: string;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

/**
 * Enum for representing the mode of parsing to be used
 */
export type ParsingMode =
  | "parse_page_without_llm"
  | "parse_page_with_llm"
  | "parse_page_with_lvm"
  | "parse_page_with_agent"
  | "parse_page_with_layout_agent"
  | "parse_document_with_llm"
  | "parse_document_with_lvm"
  | "parse_document_with_agent";

/**
 * Enum for representing the mode of parsing to be used
 */
export const ParsingMode = {
  PARSE_PAGE_WITHOUT_LLM: "parse_page_without_llm",
  PARSE_PAGE_WITH_LLM: "parse_page_with_llm",
  PARSE_PAGE_WITH_LVM: "parse_page_with_lvm",
  PARSE_PAGE_WITH_AGENT: "parse_page_with_agent",
  PARSE_PAGE_WITH_LAYOUT_AGENT: "parse_page_with_layout_agent",
  PARSE_DOCUMENT_WITH_LLM: "parse_document_with_llm",
  PARSE_DOCUMENT_WITH_LVM: "parse_document_with_lvm",
  PARSE_DOCUMENT_WITH_AGENT: "parse_document_with_agent",
} as const;

/**
 * Enum for dataset partition names.
 */
export type PartitionNames =
  | "data_source_id_partition"
  | "pipeline_id_partition"
  | "eval_dataset_id_partition"
  | "file_id_partition"
  | "pipeline_file_id_partition"
  | "file_parsing_id_partition"
  | "extraction_schema_id_partition";

/**
 * Enum for dataset partition names.
 */
export const PartitionNames = {
  DATA_SOURCE_ID_PARTITION: "data_source_id_partition",
  PIPELINE_ID_PARTITION: "pipeline_id_partition",
  EVAL_DATASET_ID_PARTITION: "eval_dataset_id_partition",
  FILE_ID_PARTITION: "file_id_partition",
  PIPELINE_FILE_ID_PARTITION: "pipeline_file_id_partition",
  FILE_PARSING_ID_PARTITION: "file_parsing_id_partition",
  EXTRACTION_SCHEMA_ID_PARTITION: "extraction_schema_id_partition",
} as const;

/**
 * Schema for a pipeline.
 */
export type PipelineReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name: string;
  project_id: string;
  /**
   * The ID of the EmbeddingModelConfig this pipeline is using.
   */
  embedding_model_config_id?: string | null;
  /**
   * The embedding model configuration for this pipeline.
   */
  embedding_model_config?: EmbeddingModelConfig | null;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
  embedding_config:
    | ({
        type: "MANAGED_OPENAI_EMBEDDING";
      } & ManagedOpenAiEmbeddingConfig)
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Hashes for the configuration of the pipeline.
   */
  config_hash?: PipelineConfigurationHashes | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.
   */
  data_sink?: DataSinkReadable | null;
  /**
   * Status of the pipeline.
   */
  status?: ("CREATED" | "DELETING") | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
};

/**
 * Schema for a pipeline.
 */
export type PipelineWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name: string;
  project_id: string;
  /**
   * The ID of the EmbeddingModelConfig this pipeline is using.
   */
  embedding_model_config_id?: string | null;
  /**
   * The embedding model configuration for this pipeline.
   */
  embedding_model_config?: EmbeddingModelConfig | null;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
  embedding_config:
    | ({
        type: "MANAGED_OPENAI_EMBEDDING";
      } & ManagedOpenAiEmbeddingConfig)
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Hashes for the configuration of the pipeline.
   */
  config_hash?: PipelineConfigurationHashes | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.
   */
  data_sink?: DataSinkWritable | null;
  /**
   * Status of the pipeline.
   */
  status?: ("CREATED" | "DELETING") | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
};

/**
 * Hashes for the configuration of a pipeline.
 */
export type PipelineConfigurationHashes = {
  /**
   * Hash of the embedding config.
   */
  embedding_config_hash?: string | null;
  /**
   * Hash of the llama parse parameters.
   */
  parsing_config_hash?: string | null;
  /**
   * Hash of the transform config.
   */
  transform_config_hash?: string | null;
};

/**
 * Schema for creating a pipeline.
 */
export type PipelineCreateReadable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateReadable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  llama_parse_parameters?: LlamaParseParameters;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name: string;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * Schema for creating a pipeline.
 */
export type PipelineCreateWritable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateWritable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  llama_parse_parameters?: LlamaParseParameters;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name: string;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * Schema for a data source in a pipeline.
 */
export type PipelineDataSourceReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
  /**
   * The ID of the data source.
   */
  data_source_id: string;
  /**
   * The ID of the pipeline.
   */
  pipeline_id: string;
  /**
   * The last time the data source was automatically synced.
   */
  last_synced_at: string;
  /**
   * The interval at which the data source should be synced.
   */
  sync_interval?: number | null;
  /**
   * The id of the user who set the sync schedule.
   */
  sync_schedule_set_by?: string | null;
  /**
   * The status of the data source in the pipeline.
   */
  status?:
    | ("NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "CANCELLED")
    | null;
  /**
   * The last time the status was updated.
   */
  status_updated_at?: string | null;
};

/**
 * Schema for a data source in a pipeline.
 */
export type PipelineDataSourceWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
  /**
   * The ID of the data source.
   */
  data_source_id: string;
  /**
   * The ID of the pipeline.
   */
  pipeline_id: string;
  /**
   * The last time the data source was automatically synced.
   */
  last_synced_at: string;
  /**
   * The interval at which the data source should be synced.
   */
  sync_interval?: number | null;
  /**
   * The id of the user who set the sync schedule.
   */
  sync_schedule_set_by?: string | null;
  /**
   * The status of the data source in the pipeline.
   */
  status?:
    | ("NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "CANCELLED")
    | null;
  /**
   * The last time the status was updated.
   */
  status_updated_at?: string | null;
};

/**
 * Schema for creating an association between a data source and a pipeline.
 */
export type PipelineDataSourceCreate = {
  /**
   * The ID of the data source.
   */
  data_source_id: string;
  /**
   * The interval at which the data source should be synced. Valid values are: 21600, 43200, 86400
   */
  sync_interval?: number | null;
};

/**
 * Schema for updating an association between a data source and a pipeline.
 */
export type PipelineDataSourceUpdate = {
  /**
   * The interval at which the data source should be synced.
   */
  sync_interval?: number | null;
};

/**
 * Schema for a file that is associated with a pipeline.
 */
export type PipelineFile = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Name of the file
   */
  name?: string | null;
  /**
   * The ID of the file in the external system
   */
  external_file_id?: string | null;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
  /**
   * File type (e.g. pdf, docx, etc.)
   */
  file_type?: string | null;
  /**
   * The ID of the project that the file belongs to
   */
  project_id?: string | null;
  /**
   * The last modified time of the file
   */
  last_modified_at?: string | null;
  /**
   * The ID of the file
   */
  file_id?: string | null;
  /**
   * The ID of the pipeline that the file is associated with
   */
  pipeline_id: string;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Permission information for the file
   */
  permission_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Custom metadata for the file
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The ID of the data source that the file belongs to
   */
  data_source_id?: string | null;
  /**
   * Hashes for the configuration of the pipeline.
   */
  config_hash?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The number of pages that have been indexed for this file
   */
  indexed_page_count?: number | null;
  /**
   * Status of the pipeline file
   */
  status?:
    | ("NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "CANCELLED")
    | null;
  /**
   * The last time the status was updated
   */
  status_updated_at?: string | null;
};

/**
 * Schema for creating a file that is associated with a pipeline.
 */
export type PipelineFileCreate = {
  /**
   * The ID of the file
   */
  file_id: string;
  /**
   * Custom metadata for the file
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
};

/**
 * Schema for updating a file that is associated with a pipeline.
 */
export type PipelineFileUpdate = {
  /**
   * Custom metadata for the file
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
};

export type PipelineMetadataConfig = {
  /**
   * List of metadata keys to exclude from embeddings
   */
  excluded_embed_metadata_keys?: Array<string>;
  /**
   * List of metadata keys to exclude from LLM during retrieval
   */
  excluded_llm_metadata_keys?: Array<string>;
};

/**
 * Enum for representing the type of a pipeline
 */
export type PipelineType = "PLAYGROUND" | "MANAGED";

/**
 * Enum for representing the type of a pipeline
 */
export const PipelineType = {
  PLAYGROUND: "PLAYGROUND",
  MANAGED: "MANAGED",
} as const;

/**
 * Schema for updating a pipeline.
 */
export type PipelineUpdateReadable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateReadable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams | null;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   * @deprecated
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name?: string | null;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * Schema for updating a pipeline.
 */
export type PipelineUpdateWritable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateWritable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams | null;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   * @deprecated
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name?: string | null;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * A playground session for a user.
 */
export type PlaygroundSession = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  pipeline_id: string;
  user_id: string;
  llm_params_id: string;
  /**
   * LLM parameters last used in this session.
   */
  llm_params?: LlmParameters;
  retrieval_params_id: string;
  /**
   * Preset retrieval parameters last used in this session.
   */
  retrieval_params?: PresetRetrievalParams;
  /**
   * Chat message history for this session.
   */
  chat_messages?: Array<ChatMessage>;
};

/**
 * Enum of possible pooling choices with pooling behaviors.
 */
export type Pooling = "cls" | "mean" | "last";

/**
 * Enum of possible pooling choices with pooling behaviors.
 */
export const Pooling = {
  CLS: "cls",
  MEAN: "mean",
  LAST: "last",
} as const;

/**
 * Schema for the search params for an retrieval execution that can be preset for a pipeline.
 */
export type PresetRetrievalParams = {
  /**
   * Number of nodes for dense retrieval.
   */
  dense_similarity_top_k?: number | null;
  /**
   * Minimum similarity score wrt query for retrieval
   */
  dense_similarity_cutoff?: number | null;
  /**
   * Number of nodes for sparse retrieval.
   */
  sparse_similarity_top_k?: number | null;
  /**
   * Enable reranking for retrieval
   */
  enable_reranking?: boolean | null;
  /**
   * Number of reranked nodes for returning.
   */
  rerank_top_n?: number | null;
  /**
   * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
   */
  alpha?: number | null;
  /**
   * Search filters for retrieval.
   */
  search_filters?: MetadataFilters | null;
  /**
   * JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.
   */
  search_filters_inference_schema?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
   */
  files_top_k?: number | null;
  /**
   * The retrieval mode for the query.
   */
  retrieval_mode?: RetrievalMode;
  /**
   * Whether to retrieve image nodes.
   * @deprecated
   */
  retrieve_image_nodes?: boolean;
  /**
   * Whether to retrieve page screenshot nodes.
   */
  retrieve_page_screenshot_nodes?: boolean;
  /**
   * Whether to retrieve page figure nodes.
   */
  retrieve_page_figure_nodes?: boolean;
  class_name?: string;
};

/**
 * Schema for a presigned URL.
 */
export type PresignedUrl = {
  /**
   * A presigned URL for IO operations against a private file
   */
  url: string;
  /**
   * The time at which the presigned URL expires
   */
  expires_at: string;
  /**
   * Form fields for a presigned POST request
   */
  form_fields?: {
    [key: string]: string;
  } | null;
};

/**
 * A processing result with lineage information.
 */
export type ProcessingResult = {
  /**
   * Unique identifier for this result
   */
  result_id: string;
  /**
   * Source item that was processed
   */
  item_id: string;
  /**
   * Type of processing performed
   */
  job_type: BatchJobType;
  /**
   * Job configuration used for processing
   */
  job_config: BatchParseJobRecordCreate | ClassifyJob;
  /**
   * Hash of parameters for deduplication
   */
  parameters_hash: string;
  /**
   * S3 location of processing output
   */
  output_s3_path: string;
  /**
   * Summary statistics about the output
   */
  output_metadata?: ProcessingResultMetadata | null;
  /**
   * When this processing occurred
   */
  processed_at: string;
};

/**
 * Metadata about processing output.
 *
 * Currently empty - will be populated with job-type-specific metadata fields in the future.
 */
export type ProcessingResultMetadata = {
  [key: string]: unknown;
};

/**
 * Schema for a project.
 */
export type Project = {
  name: string;
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  ad_hoc_eval_dataset_id?: string | null;
  /**
   * The Organization ID the project is under.
   */
  organization_id: string;
  /**
   * Whether this project is the default project for the user.
   */
  is_default?: boolean;
};

/**
 * Public model names.
 */
export type PublicModelName =
  | "openai-gpt-4o"
  | "openai-gpt-4o-mini"
  | "openai-gpt-4-1"
  | "openai-gpt-4-1-mini"
  | "openai-gpt-4-1-nano"
  | "openai-gpt-5"
  | "openai-gpt-5-mini"
  | "openai-gpt-5-nano"
  | "openai-text-embedding-3-large"
  | "openai-text-embedding-3-small"
  | "openai-whisper-1"
  | "anthropic-sonnet-3.5"
  | "anthropic-sonnet-3.5-v2"
  | "anthropic-sonnet-3.7"
  | "anthropic-sonnet-4.0"
  | "anthropic-sonnet-4.5"
  | "anthropic-haiku-3.5"
  | "anthropic-haiku-4.5"
  | "gemini-2.5-flash"
  | "gemini-3.0-pro"
  | "gemini-2.5-pro"
  | "gemini-2.0-flash"
  | "gemini-2.0-flash-lite"
  | "gemini-2.5-flash-lite"
  | "gemini-1.5-flash"
  | "gemini-1.5-pro";

/**
 * Public model names.
 */
export const PublicModelName = {
  OPENAI_GPT_4O: "openai-gpt-4o",
  OPENAI_GPT_4O_MINI: "openai-gpt-4o-mini",
  OPENAI_GPT_4_1: "openai-gpt-4-1",
  OPENAI_GPT_4_1_MINI: "openai-gpt-4-1-mini",
  OPENAI_GPT_4_1_NANO: "openai-gpt-4-1-nano",
  OPENAI_GPT_5: "openai-gpt-5",
  OPENAI_GPT_5_MINI: "openai-gpt-5-mini",
  OPENAI_GPT_5_NANO: "openai-gpt-5-nano",
  OPENAI_TEXT_EMBEDDING_3_LARGE: "openai-text-embedding-3-large",
  OPENAI_TEXT_EMBEDDING_3_SMALL: "openai-text-embedding-3-small",
  OPENAI_WHISPER_1: "openai-whisper-1",
  ANTHROPIC_SONNET_3_5: "anthropic-sonnet-3.5",
  ANTHROPIC_SONNET_3_5_V2: "anthropic-sonnet-3.5-v2",
  ANTHROPIC_SONNET_3_7: "anthropic-sonnet-3.7",
  ANTHROPIC_SONNET_4_0: "anthropic-sonnet-4.0",
  ANTHROPIC_SONNET_4_5: "anthropic-sonnet-4.5",
  ANTHROPIC_HAIKU_3_5: "anthropic-haiku-3.5",
  ANTHROPIC_HAIKU_4_5: "anthropic-haiku-4.5",
  GEMINI_2_5_FLASH: "gemini-2.5-flash",
  GEMINI_3_0_PRO: "gemini-3.0-pro",
  GEMINI_2_5_PRO: "gemini-2.5-pro",
  GEMINI_2_0_FLASH: "gemini-2.0-flash",
  GEMINI_2_0_FLASH_LITE: "gemini-2.0-flash-lite",
  GEMINI_2_5_FLASH_LITE: "gemini-2.5-flash-lite",
  GEMINI_1_5_FLASH: "gemini-1.5-flash",
  GEMINI_1_5_PRO: "gemini-1.5-pro",
} as const;

export type ReRankConfig = {
  /**
   * The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   */
  top_n?: number;
  /**
   * The type of reranker to use.
   */
  type?: ReRankerType;
};

/**
 * Enum for the reranker type.
 */
export type ReRankerType =
  | "system_default"
  | "llm"
  | "cohere"
  | "bedrock"
  | "score"
  | "disabled";

/**
 * Enum for the reranker type.
 */
export const ReRankerType = {
  SYSTEM_DEFAULT: "system_default",
  LLM: "llm",
  COHERE: "cohere",
  BEDROCK: "bedrock",
  SCORE: "score",
  DISABLED: "disabled",
} as const;

export type RelatedNodeInfo = {
  node_id: string;
  node_type?: ObjectType | string | null;
  metadata?: {
    [key: string]: unknown;
  };
  hash?: string | null;
  class_name?: string;
};

export type RetrievalMode =
  | "chunks"
  | "files_via_metadata"
  | "files_via_content"
  | "auto_routed";

export const RetrievalMode = {
  CHUNKS: "chunks",
  FILES_VIA_METADATA: "files_via_metadata",
  FILES_VIA_CONTENT: "files_via_content",
  AUTO_ROUTED: "auto_routed",
} as const;

/**
 * Schema for the search params for an retrieval execution.
 */
export type RetrievalParams = {
  /**
   * Number of nodes for dense retrieval.
   */
  dense_similarity_top_k?: number | null;
  /**
   * Minimum similarity score wrt query for retrieval
   */
  dense_similarity_cutoff?: number | null;
  /**
   * Number of nodes for sparse retrieval.
   */
  sparse_similarity_top_k?: number | null;
  /**
   * Enable reranking for retrieval
   */
  enable_reranking?: boolean | null;
  /**
   * Number of reranked nodes for returning.
   */
  rerank_top_n?: number | null;
  /**
   * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
   */
  alpha?: number | null;
  /**
   * Search filters for retrieval.
   */
  search_filters?: MetadataFilters | null;
  /**
   * JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.
   */
  search_filters_inference_schema?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
   */
  files_top_k?: number | null;
  /**
   * The retrieval mode for the query.
   */
  retrieval_mode?: RetrievalMode;
  /**
   * Whether to retrieve image nodes.
   * @deprecated
   */
  retrieve_image_nodes?: boolean;
  /**
   * Whether to retrieve page screenshot nodes.
   */
  retrieve_page_screenshot_nodes?: boolean;
  /**
   * Whether to retrieve page figure nodes.
   */
  retrieve_page_figure_nodes?: boolean;
  /**
   * The query to retrieve against.
   */
  query: string;
  class_name?: string;
};

/**
 * Schema for the result of an retrieval execution.
 */
export type RetrieveResults = {
  /**
   * The ID of the pipeline that the query was retrieved against.
   */
  pipeline_id: string;
  /**
   * The nodes retrieved by the pipeline for the given query.
   */
  retrieval_nodes: Array<TextNodeWithScore>;
  /**
   * The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.
   * @deprecated
   */
  image_nodes?: Array<PageScreenshotNodeWithScore>;
  /**
   * The page figure nodes retrieved by the pipeline for the given query.
   */
  page_figure_nodes?: Array<PageFigureNodeWithScore>;
  /**
   * The end-to-end latency for retrieval and reranking.
   */
  retrieval_latency?: {
    [key: string]: number;
  };
  /**
   * Metadata associated with the retrieval execution
   */
  metadata?: {
    [key: string]: string;
  };
  /**
   * The inferred search filters for the query.
   */
  inferred_search_filters?: MetadataFilters | null;
  class_name?: string;
};

/**
 * An entity that retrieves context nodes from several sub RetrieverTools.
 */
export type Retriever = {
  /**
   * A name for the retriever tool. Will default to the pipeline name if not provided.
   */
  name: string;
  /**
   * The pipelines this retriever uses.
   */
  pipelines?: Array<RetrieverPipeline>;
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The ID of the project this retriever resides in.
   */
  project_id: string;
};

export type RetrieverCreate = {
  /**
   * A name for the retriever tool. Will default to the pipeline name if not provided.
   */
  name: string;
  /**
   * The pipelines this retriever uses.
   */
  pipelines?: Array<RetrieverPipeline>;
};

export type RetrieverPipeline = {
  /**
   * A name for the retriever tool. Will default to the pipeline name if not provided.
   */
  name: string | null;
  /**
   * A description of the retriever tool.
   */
  description: string | null;
  /**
   * The ID of the pipeline this tool uses.
   */
  pipeline_id: string;
  /**
   * Parameters for retrieval configuration.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
};

export type RetrieverUpdate = {
  /**
   * A name for the retriever.
   */
  name?: string | null;
  /**
   * The pipelines this retriever uses.
   */
  pipelines: Array<RetrieverPipeline> | null;
};

/**
 * API request body for searching agent data
 */
export type SearchRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: {
    [key: string]: FilterOperation;
  } | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
  /**
   * The agent deployment's name to search within
   */
  deployment_name: string;
  /**
   * The logical agent data collection to search within
   */
  collection?: string;
  /**
   * Whether to include the total number of items in the response
   */
  include_total?: boolean;
  /**
   * The offset to start from. If not provided, the first page is returned
   */
  offset?: number | null;
};

export type SemanticChunkingConfig = {
  mode?: "semantic";
  buffer_size?: number;
  breakpoint_percentile_threshold?: number;
};

export type SentenceChunkingConfig = {
  chunk_size?: number;
  chunk_overlap?: number;
  mode?: "sentence";
  separator?: string;
  paragraph_separator?: string;
};

/**
 * Configuration for sparse embedding models used in hybrid search.
 *
 * This allows users to choose between Splade and BM25 models for
 * sparse retrieval in managed data sinks.
 */
export type SparseModelConfig = {
  /**
   * The sparse model type to use. 'bm25' uses Qdrant's FastEmbed BM25 model (default for new pipelines), 'splade' uses HuggingFace Splade model, 'auto' selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade).
   */
  model_type?: SparseModelType;
  class_name?: string;
};

/**
 * Enum for sparse model types supported in LlamaCloud.
 *
 * SPLADE: Uses HuggingFace Splade model for sparse embeddings
 * BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
 * AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)
 */
export type SparseModelType = "splade" | "bm25" | "auto";

/**
 * Enum for sparse model types supported in LlamaCloud.
 *
 * SPLADE: Uses HuggingFace Splade model for sparse embeddings
 * BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
 * AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)
 */
export const SparseModelType = {
  SPLADE: "splade",
  BM25: "bm25",
  AUTO: "auto",
} as const;

/**
 * Category definition for document splitting.
 */
export type SplitCategory = {
  /**
   * Name of the category.
   */
  name: string;
  /**
   * Optional description of what content belongs in this category.
   */
  description?: string | null;
};

/**
 * Request to create a document split job.
 */
export type SplitCreateRequest = {
  /**
   * Document to be split.
   */
  document_input: SplitDocumentInput;
  /**
   * Categories to split the document into.
   */
  categories: Array<SplitCategory>;
  /**
   * Strategy for splitting the document.
   */
  splitting_strategy?: SplitStrategy;
};

/**
 * Document input specification.
 */
export type SplitDocumentInput = {
  /**
   * Type of document input. Valid values are: file_id
   */
  type: string;
  /**
   * Document identifier.
   */
  value: string;
};

/**
 * Paginated list of split jobs.
 */
export type SplitJobQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<SplitJobResponse>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * A document split job.
 */
export type SplitJobResponse = {
  /**
   * Unique identifier for the split job.
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Project ID this job belongs to.
   */
  project_id: string;
  /**
   * User ID who created this job.
   */
  user_id: string;
  /**
   * Document that was split.
   */
  document_input: SplitDocumentInput;
  /**
   * Categories used for splitting.
   */
  categories: Array<SplitCategory>;
  /**
   * Current status of the job. Valid values are: pending, processing, completed, failed.
   */
  status: string;
  /**
   * Split result (available when status is COMPLETED).
   */
  result?: SplitResultResponse | null;
  /**
   * Error message if the job failed.
   */
  error_message?: string | null;
};

/**
 * Result of a completed split job.
 */
export type SplitResultResponse = {
  /**
   * List of document segments.
   */
  segments: Array<SplitSegmentResponse>;
};

/**
 * A segment of the split document.
 */
export type SplitSegmentResponse = {
  /**
   * Category name this split belongs to.
   */
  category: string;
  /**
   * 1-indexed page numbers in this split.
   */
  pages: Array<number>;
  /**
   * Categorical confidence level. Valid values are: high, medium, low.
   */
  confidence_category: string;
};

/**
 * Configuration for how to split the document.
 */
export type SplitStrategy = {
  /**
   * Whether to allow pages that don't match any category to be grouped as 'uncategorized'. If False, all pages must be assigned to a defined category.
   */
  allow_uncategorized?: boolean;
};

/**
 * A spreadsheet parsing job
 */
export type SpreadsheetJob = {
  /**
   * The ID of the job
   */
  id: string;
  /**
   * The ID of the user
   */
  user_id: string;
  /**
   * The ID of the project
   */
  project_id: string;
  /**
   * Configuration for the parsing job
   */
  config: SpreadsheetParsingConfig;
  /**
   * The status of the parsing job
   */
  status: StatusEnum;
  /**
   * When the job was created
   */
  created_at: string;
  /**
   * When the job was last updated
   */
  updated_at: string;
  /**
   * Whether the job completed successfully
   */
  success?: boolean | null;
  /**
   * All extracted regions (populated when job is complete)
   */
  regions?: Array<ExtractedRegionSummary>;
  /**
   * Metadata for each processed worksheet (populated when job is complete)
   */
  worksheet_metadata?: Array<WorksheetMetadata>;
  /**
   * Any errors encountered
   */
  errors?: Array<string>;
  /**
   * The ID of the input file
   */
  file_id: string | null;
  /**
   * The file that was parsed
   * @deprecated
   */
  file?: File | null;
};

/**
 * Request to create a spreadsheet parsing job
 */
export type SpreadsheetJobCreate = {
  /**
   * The ID of the file to parse
   */
  file_id: string;
  /**
   * Configuration for the parsing job
   */
  config?: SpreadsheetParsingConfig;
};

/**
 * Configuration for spreadsheet parsing and region extraction
 */
export type SpreadsheetParsingConfig = {
  /**
   * The names of the sheets to extract regions from. If empty, all sheets will be processed.
   */
  sheet_names?: Array<string> | null;
  /**
   * Whether to include hidden cells when extracting regions from the spreadsheet.
   */
  include_hidden_cells?: boolean;
  /**
   * A1 notation of the range to extract a single region from. If None, the entire sheet is used.
   */
  extraction_range?: string | null;
  /**
   * Whether to generate additional metadata (title, description) for each extracted region.
   */
  generate_additional_metadata?: boolean;
  /**
   * Enables experimental processing. Accuracy may be impacted.
   */
  use_experimental_processing?: boolean;
};

export type SpreadsheetResultType = "table" | "extra" | "cell_metadata";

export const SpreadsheetResultType = {
  TABLE: "table",
  EXTRA: "extra",
  CELL_METADATA: "cell_metadata",
} as const;

/**
 * Enum for representing the status of a job
 */
export type StatusEnum =
  | "PENDING"
  | "SUCCESS"
  | "ERROR"
  | "PARTIAL_SUCCESS"
  | "CANCELLED";

/**
 * Enum for representing the status of a job
 */
export const StatusEnum = {
  PENDING: "PENDING",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  PARTIAL_SUCCESS: "PARTIAL_SUCCESS",
  CANCELLED: "CANCELLED",
} as const;

export type StructuredResult = {
  /**
   * List of structured pages or failed page entries
   */
  pages: Array<StructuredResultPage | FailedStructuredPage>;
};

export type StructuredResultPage = {
  /**
   * Page number of the document
   */
  page_number: number;
  /**
   * List of structured items on the page
   */
  items: Array<
    | ({
        type: "text";
      } & TextItem)
    | ({
        type: "heading";
      } & HeadingItem)
    | ({
        type: "list";
      } & ListItem)
    | ({
        type: "code";
      } & CodeItem)
    | ({
        type: "table";
      } & TableItem)
    | ({
        type: "image";
      } & ImageItem)
  >;
  /**
   * Success indicator
   */
  success?: true;
};

export type SupportedLlmModelNames =
  | "GPT_4O"
  | "GPT_4O_MINI"
  | "GPT_4_1"
  | "GPT_4_1_NANO"
  | "GPT_4_1_MINI"
  | "AZURE_OPENAI_GPT_4O"
  | "AZURE_OPENAI_GPT_4O_MINI"
  | "AZURE_OPENAI_GPT_4_1"
  | "AZURE_OPENAI_GPT_4_1_MINI"
  | "AZURE_OPENAI_GPT_4_1_NANO"
  | "CLAUDE_3_5_SONNET"
  | "CLAUDE_4_5_SONNET"
  | "BEDROCK_CLAUDE_3_5_SONNET_V1"
  | "BEDROCK_CLAUDE_3_5_SONNET_V2"
  | "VERTEX_AI_CLAUDE_3_5_SONNET_V2";

export const SupportedLlmModelNames = {
  GPT_4O: "GPT_4O",
  GPT_4O_MINI: "GPT_4O_MINI",
  GPT_4_1: "GPT_4_1",
  GPT_4_1_NANO: "GPT_4_1_NANO",
  GPT_4_1_MINI: "GPT_4_1_MINI",
  AZURE_OPENAI_GPT_4O: "AZURE_OPENAI_GPT_4O",
  AZURE_OPENAI_GPT_4O_MINI: "AZURE_OPENAI_GPT_4O_MINI",
  AZURE_OPENAI_GPT_4_1: "AZURE_OPENAI_GPT_4_1",
  AZURE_OPENAI_GPT_4_1_MINI: "AZURE_OPENAI_GPT_4_1_MINI",
  AZURE_OPENAI_GPT_4_1_NANO: "AZURE_OPENAI_GPT_4_1_NANO",
  CLAUDE_3_5_SONNET: "CLAUDE_3_5_SONNET",
  CLAUDE_4_5_SONNET: "CLAUDE_4_5_SONNET",
  BEDROCK_CLAUDE_3_5_SONNET_V1: "BEDROCK_CLAUDE_3_5_SONNET_V1",
  BEDROCK_CLAUDE_3_5_SONNET_V2: "BEDROCK_CLAUDE_3_5_SONNET_V2",
  VERTEX_AI_CLAUDE_3_5_SONNET_V2: "VERTEX_AI_CLAUDE_3_5_SONNET_V2",
} as const;

export type TableItem = {
  /**
   * Table item type
   */
  type?: "table";
  /**
   * Bounding box coordinates [x1, y1, x2, y2]
   */
  bBox?: [number, number, number, number] | null;
  /**
   * Table data as array of string arrays
   */
  rows: Array<Array<string>>;
  /**
   * HTML representation of the table
   */
  html: string;
  /**
   * Markdown representation of the table
   */
  md: string;
  /**
   * CSV representation of the table
   */
  csv: string;
};

export type TextItem = {
  /**
   * Text item type
   */
  type?: "text";
  /**
   * Bounding box coordinates [x1, y1, x2, y2]
   */
  bBox?: [number, number, number, number] | null;
  /**
   * Text content
   */
  value: string;
};

/**
 * Provided for backward compatibility.
 *
 * Note: we keep the field with the typo "seperator" to maintain backward compatibility for
 * serialized objects.
 */
export type TextNode = {
  /**
   * Unique ID of the node.
   */
  id_?: string;
  /**
   * Embedding of the node.
   */
  embedding?: Array<number> | null;
  /**
   * A flat dictionary of metadata fields
   */
  extra_info?: {
    [key: string]: unknown;
  };
  /**
   * Metadata keys that are excluded from text for the embed model.
   */
  excluded_embed_metadata_keys?: Array<string>;
  /**
   * Metadata keys that are excluded from text for the LLM.
   */
  excluded_llm_metadata_keys?: Array<string>;
  /**
   * A mapping of relationships to other node information.
   */
  relationships?: {
    [key: string]: RelatedNodeInfo | Array<RelatedNodeInfo>;
  };
  /**
   * Template for how metadata is formatted, with {key} and {value} placeholders.
   */
  metadata_template?: string;
  /**
   * Separator between metadata fields when converting to string.
   */
  metadata_seperator?: string;
  /**
   * Text content of the node.
   */
  text?: string;
  /**
   * MIME type of the node content.
   */
  mimetype?: string;
  /**
   * Start char index of the node.
   */
  start_char_idx?: number | null;
  /**
   * End char index of the node.
   */
  end_char_idx?: number | null;
  /**
   * Template for how text is formatted, with {content} and {metadata_str} placeholders.
   */
  text_template?: string;
  class_name?: string;
};

/**
 * Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
 * FastAPI doesn't accept abstract classes like BaseNode.
 */
export type TextNodeWithScore = {
  node: TextNode;
  score?: number | null;
  class_name?: string;
};

export type TextResult = {
  /**
   * List of text pages
   */
  pages: Array<TextResultPage>;
};

export type TextResultPage = {
  /**
   * Page number of the document
   */
  page_number: number;
  /**
   * Plain text content of the page
   */
  text: string;
};

/**
 * Enum for representing the tier names
 */
export type TierName = "fast" | "cost_effective" | "agentic" | "agentic_plus";

/**
 * Enum for representing the tier names
 */
export const TierName = {
  FAST: "fast",
  COST_EFFECTIVE: "cost_effective",
  AGENTIC: "agentic",
  AGENTIC_PLUS: "agentic_plus",
} as const;

export type TokenChunkingConfig = {
  chunk_size?: number;
  chunk_overlap?: number;
  mode?: "token";
  separator?: string;
};

/**
 * API boundary representation of a usage metric.
 */
export type UsageMetric = {
  /**
   * The system-generated UUID for the metric
   */
  id: string;
  /**
   * The ID of the user
   */
  user_id: string;
  /**
   * The event type that is emitted
   */
  event_type:
    | "pages_indexed"
    | "pages_embedded"
    | "pages_parsed"
    | "set_total_pages_indexed"
    | "set_total_indexes"
    | "layout_extracted"
    | "layout_aware_parsing"
    | "layout_aware_chart_extraction"
    | "chart_parsing_agentic"
    | "chart_parsing_plus"
    | "chart_parsing_efficient"
    | "image_classified"
    | "precise_bbox_extraction"
    | "audio_seconds_parsed"
    | "extraction_num_pages"
    | "extraction_num_pages_parsed";
  /**
   * The project ID
   */
  project_id: string;
  /**
   * The organization ID
   */
  organization_id: string;
  /**
   * The unit measurement associated with the event type
   */
  value: number;
  /**
   * Properties associated with the metric
   */
  properties?: {
    [key: string]: unknown;
  };
  /**
   * The day the metric was emitted [UTC], in the format 'YYYY-MM-DD'
   */
  day: string;
  /**
   * The source job identifier, i.e. job_id or file_id
   */
  event_aggregation_key: string;
  /**
   * The source job aggregation type, i.e. pdf
   */
  event_aggregation_type: string;
};

/**
 * Paginated response containing usage metrics.
 */
export type UsageMetricQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<UsageMetric>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type VertexAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "VERTEXAI_EMBEDDING";
  /**
   * Configuration for the VertexAI embedding model.
   */
  component?: VertexTextEmbedding;
};

/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */
export type VertexEmbeddingMode =
  | "default"
  | "classification"
  | "clustering"
  | "similarity"
  | "retrieval";

/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */
export const VertexEmbeddingMode = {
  DEFAULT: "default",
  CLASSIFICATION: "classification",
  CLUSTERING: "clustering",
  SIMILARITY: "similarity",
  RETRIEVAL: "retrieval",
} as const;

export type VertexTextEmbedding = {
  /**
   * The modelId of the VertexAI model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * The default location to use when making API calls.
   */
  location: string;
  /**
   * The default GCP project to use when making Vertex API calls.
   */
  project: string;
  /**
   * The embedding mode to use.
   */
  embed_mode?: VertexEmbeddingMode;
  /**
   * Additional kwargs for the Vertex.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  /**
   * The client email for the VertexAI credentials.
   */
  client_email: string | null;
  /**
   * The token URI for the VertexAI credentials.
   */
  token_uri: string | null;
  /**
   * The private key ID for the VertexAI credentials.
   */
  private_key_id: string | null;
  /**
   * The private key for the VertexAI credentials.
   */
  private_key: string | null;
  class_name?: string;
};

/**
 * Allows the user to configure webhook options for notifications and callbacks.
 */
export type WebhookConfiguration = {
  /**
   * The URL to send webhook notifications to.
   */
  webhook_url?: string | null;
  /**
   * Custom HTTP headers to include with webhook requests.
   */
  webhook_headers?: {
    [key: string]: string;
  } | null;
  /**
   * List of event names to subscribe to
   */
  webhook_events?: Array<
    | "extract.pending"
    | "extract.success"
    | "extract.error"
    | "extract.partial_success"
    | "extract.cancelled"
    | "parse.pending"
    | "parse.success"
    | "parse.error"
    | "parse.partial_success"
    | "parse.cancelled"
    | "unmapped_event"
  > | null;
  /**
   * The output format to use for the webhook. Defaults to string if none supplied. Currently supported values: string, json
   */
  webhook_output_format?: string | null;
};

/**
 * Metadata about a worksheet in a spreadsheet
 */
export type WorksheetMetadata = {
  /**
   * Name of the worksheet
   */
  sheet_name: string;
  /**
   * Generated title for the worksheet
   */
  title?: string | null;
  /**
   * Generated description of the worksheet
   */
  description?: string | null;
};

export type ListDataSinksApiV1DataSinksGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sinks";
};

export type ListDataSinksApiV1DataSinksGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDataSinksApiV1DataSinksGetError =
  ListDataSinksApiV1DataSinksGetErrors[keyof ListDataSinksApiV1DataSinksGetErrors];

export type ListDataSinksApiV1DataSinksGetResponses = {
  /**
   * Successful Response
   */
  200: Array<DataSinkReadable>;
};

export type ListDataSinksApiV1DataSinksGetResponse =
  ListDataSinksApiV1DataSinksGetResponses[keyof ListDataSinksApiV1DataSinksGetResponses];

export type CreateDataSinkApiV1DataSinksPostData = {
  body: DataSinkCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sinks";
};

export type CreateDataSinkApiV1DataSinksPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateDataSinkApiV1DataSinksPostError =
  CreateDataSinkApiV1DataSinksPostErrors[keyof CreateDataSinkApiV1DataSinksPostErrors];

export type CreateDataSinkApiV1DataSinksPostResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type CreateDataSinkApiV1DataSinksPostResponse =
  CreateDataSinkApiV1DataSinksPostResponses[keyof CreateDataSinkApiV1DataSinksPostResponses];

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData = {
  body?: never;
  path: {
    data_sink_id: string;
  };
  query?: never;
  url: "/api/v1/data-sinks/{data_sink_id}";
};

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteError =
  DeleteDataSinkApiV1DataSinksDataSinkIdDeleteErrors[keyof DeleteDataSinkApiV1DataSinksDataSinkIdDeleteErrors];

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse =
  DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponses[keyof DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponses];

export type GetDataSinkApiV1DataSinksDataSinkIdGetData = {
  body?: never;
  path: {
    data_sink_id: string;
  };
  query?: never;
  url: "/api/v1/data-sinks/{data_sink_id}";
};

export type GetDataSinkApiV1DataSinksDataSinkIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDataSinkApiV1DataSinksDataSinkIdGetError =
  GetDataSinkApiV1DataSinksDataSinkIdGetErrors[keyof GetDataSinkApiV1DataSinksDataSinkIdGetErrors];

export type GetDataSinkApiV1DataSinksDataSinkIdGetResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type GetDataSinkApiV1DataSinksDataSinkIdGetResponse =
  GetDataSinkApiV1DataSinksDataSinkIdGetResponses[keyof GetDataSinkApiV1DataSinksDataSinkIdGetResponses];

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutData = {
  body: DataSinkUpdateWritable;
  path: {
    data_sink_id: string;
  };
  query?: never;
  url: "/api/v1/data-sinks/{data_sink_id}";
};

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutError =
  UpdateDataSinkApiV1DataSinksDataSinkIdPutErrors[keyof UpdateDataSinkApiV1DataSinksDataSinkIdPutErrors];

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse =
  UpdateDataSinkApiV1DataSinksDataSinkIdPutResponses[keyof UpdateDataSinkApiV1DataSinksDataSinkIdPutResponses];

export type ListDataSourcesApiV1DataSourcesGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sources";
};

export type ListDataSourcesApiV1DataSourcesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDataSourcesApiV1DataSourcesGetError =
  ListDataSourcesApiV1DataSourcesGetErrors[keyof ListDataSourcesApiV1DataSourcesGetErrors];

export type ListDataSourcesApiV1DataSourcesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<DataSourceReadable>;
};

export type ListDataSourcesApiV1DataSourcesGetResponse =
  ListDataSourcesApiV1DataSourcesGetResponses[keyof ListDataSourcesApiV1DataSourcesGetResponses];

export type CreateDataSourceApiV1DataSourcesPostData = {
  body: DataSourceCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sources";
};

export type CreateDataSourceApiV1DataSourcesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateDataSourceApiV1DataSourcesPostError =
  CreateDataSourceApiV1DataSourcesPostErrors[keyof CreateDataSourceApiV1DataSourcesPostErrors];

export type CreateDataSourceApiV1DataSourcesPostResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type CreateDataSourceApiV1DataSourcesPostResponse =
  CreateDataSourceApiV1DataSourcesPostResponses[keyof CreateDataSourceApiV1DataSourcesPostResponses];

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData = {
  body?: never;
  path: {
    data_source_id: string;
  };
  query?: never;
  url: "/api/v1/data-sources/{data_source_id}";
};

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteError =
  DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteErrors[keyof DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteErrors];

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse =
  DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponses[keyof DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponses];

export type GetDataSourceApiV1DataSourcesDataSourceIdGetData = {
  body?: never;
  path: {
    data_source_id: string;
  };
  query?: never;
  url: "/api/v1/data-sources/{data_source_id}";
};

export type GetDataSourceApiV1DataSourcesDataSourceIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDataSourceApiV1DataSourcesDataSourceIdGetError =
  GetDataSourceApiV1DataSourcesDataSourceIdGetErrors[keyof GetDataSourceApiV1DataSourcesDataSourceIdGetErrors];

export type GetDataSourceApiV1DataSourcesDataSourceIdGetResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type GetDataSourceApiV1DataSourcesDataSourceIdGetResponse =
  GetDataSourceApiV1DataSourcesDataSourceIdGetResponses[keyof GetDataSourceApiV1DataSourcesDataSourceIdGetResponses];

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutData = {
  body: DataSourceUpdateWritable;
  path: {
    data_source_id: string;
  };
  query?: never;
  url: "/api/v1/data-sources/{data_source_id}";
};

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutError =
  UpdateDataSourceApiV1DataSourcesDataSourceIdPutErrors[keyof UpdateDataSourceApiV1DataSourcesDataSourceIdPutErrors];

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse =
  UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponses[keyof UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponses];

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/embedding-model-configs";
};

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetError =
  ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetErrors[keyof ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetErrors];

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<EmbeddingModelConfig>;
};

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponse =
  ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponses[keyof ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponses];

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostData = {
  body: EmbeddingModelConfigCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/embedding-model-configs";
};

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostError =
  CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostErrors[keyof CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostErrors];

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponses =
  {
    /**
     * Successful Response
     */
    201: EmbeddingModelConfig;
  };

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponse =
  CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponses[keyof CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponses];

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteData =
  {
    body?: never;
    path: {
      embedding_model_config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/embedding-model-configs/{embedding_model_config_id}";
  };

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteError =
  DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteErrors[keyof DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteErrors];

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponse =
  DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponses[keyof DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponses];

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutData =
  {
    body: EmbeddingModelConfigUpdate;
    path: {
      embedding_model_config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/embedding-model-configs/{embedding_model_config_id}";
  };

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutError =
  UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutErrors[keyof UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutErrors];

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: EmbeddingModelConfig;
  };

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponse =
  UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponses[keyof UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponses];

export type ListOrganizationsApiV1OrganizationsGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/organizations";
};

export type ListOrganizationsApiV1OrganizationsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListOrganizationsApiV1OrganizationsGetError =
  ListOrganizationsApiV1OrganizationsGetErrors[keyof ListOrganizationsApiV1OrganizationsGetErrors];

export type ListOrganizationsApiV1OrganizationsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Organization>;
};

export type ListOrganizationsApiV1OrganizationsGetResponse =
  ListOrganizationsApiV1OrganizationsGetResponses[keyof ListOrganizationsApiV1OrganizationsGetResponses];

export type GetOrganizationApiV1OrganizationsOrganizationIdGetData = {
  body?: never;
  path: {
    organization_id: string;
  };
  query?: never;
  url: "/api/v1/organizations/{organization_id}";
};

export type GetOrganizationApiV1OrganizationsOrganizationIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetOrganizationApiV1OrganizationsOrganizationIdGetError =
  GetOrganizationApiV1OrganizationsOrganizationIdGetErrors[keyof GetOrganizationApiV1OrganizationsOrganizationIdGetErrors];

export type GetOrganizationApiV1OrganizationsOrganizationIdGetResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type GetOrganizationApiV1OrganizationsOrganizationIdGetResponse =
  GetOrganizationApiV1OrganizationsOrganizationIdGetResponses[keyof GetOrganizationApiV1OrganizationsOrganizationIdGetResponses];

export type ListProjectsApiV1ProjectsGetData = {
  body?: never;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_name?: string | null;
  };
  url: "/api/v1/projects";
};

export type ListProjectsApiV1ProjectsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListProjectsApiV1ProjectsGetError =
  ListProjectsApiV1ProjectsGetErrors[keyof ListProjectsApiV1ProjectsGetErrors];

export type ListProjectsApiV1ProjectsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Project>;
};

export type ListProjectsApiV1ProjectsGetResponse =
  ListProjectsApiV1ProjectsGetResponses[keyof ListProjectsApiV1ProjectsGetResponses];

export type GetProjectApiV1ProjectsProjectIdGetData = {
  body?: never;
  path: {
    project_id: string | null;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/projects/{project_id}";
};

export type GetProjectApiV1ProjectsProjectIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetProjectApiV1ProjectsProjectIdGetError =
  GetProjectApiV1ProjectsProjectIdGetErrors[keyof GetProjectApiV1ProjectsProjectIdGetErrors];

export type GetProjectApiV1ProjectsProjectIdGetResponses = {
  /**
   * Successful Response
   */
  200: Project;
};

export type GetProjectApiV1ProjectsProjectIdGetResponse =
  GetProjectApiV1ProjectsProjectIdGetResponses[keyof GetProjectApiV1ProjectsProjectIdGetResponses];

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page_screenshots";
};

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetError =
  ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetErrors[keyof ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetErrors];

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PageScreenshotMetadata>;
};

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponse =
  ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponses[keyof ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponses];

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetData = {
  body?: never;
  path: {
    id: string;
    page_index: number;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page_screenshots/{page_index}";
};

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetError =
  GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetErrors[keyof GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetErrors];

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostData =
  {
    body?: never;
    path: {
      id: string;
      page_index: number;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/files/{id}/page_screenshots/{page_index}/presigned_url";
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostError =
  GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostErrors[keyof GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostErrors];

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponses =
  {
    /**
     * Successful Response
     */
    200: PresignedUrl;
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponse =
  GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponses[keyof GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponses];

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page-figures";
};

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetError =
  ListFilePagesFiguresApiV1FilesIdPageFiguresGetErrors[keyof ListFilePagesFiguresApiV1FilesIdPageFiguresGetErrors];

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PageFigureMetadata>;
};

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponse =
  ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponses[keyof ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponses];

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetData = {
  body?: never;
  path: {
    id: string;
    page_index: number;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page-figures/{page_index}";
};

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetError =
  ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetErrors[keyof ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetErrors];

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PageFigureMetadata>;
};

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponse =
  ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponses[keyof ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponses];

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetData =
  {
    body?: never;
    path: {
      id: string;
      page_index: number;
      figure_name: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/files/{id}/page-figures/{page_index}/{figure_name}";
  };

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetError =
  GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetErrors[keyof GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetErrors];

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostData =
  {
    body?: never;
    path: {
      id: string;
      page_index: number;
      figure_name: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/files/{id}/page-figures/{page_index}/{figure_name}/presigned_url";
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostError =
  GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostErrors[keyof GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostErrors];

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponses =
  {
    /**
     * Successful Response
     */
    200: PresignedUrl;
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponse =
  GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponses[keyof GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponses];

export type DeleteFileApiV1FilesIdDeleteData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}";
};

export type DeleteFileApiV1FilesIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteFileApiV1FilesIdDeleteError =
  DeleteFileApiV1FilesIdDeleteErrors[keyof DeleteFileApiV1FilesIdDeleteErrors];

export type DeleteFileApiV1FilesIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteFileApiV1FilesIdDeleteResponse =
  DeleteFileApiV1FilesIdDeleteResponses[keyof DeleteFileApiV1FilesIdDeleteResponses];

export type GetFileApiV1FilesIdGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}";
};

export type GetFileApiV1FilesIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetFileApiV1FilesIdGetError =
  GetFileApiV1FilesIdGetErrors[keyof GetFileApiV1FilesIdGetErrors];

export type GetFileApiV1FilesIdGetResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type GetFileApiV1FilesIdGetResponse =
  GetFileApiV1FilesIdGetResponses[keyof GetFileApiV1FilesIdGetResponses];

export type UploadFileApiV1FilesPostData = {
  body: BodyUploadFileApiV1FilesPost;
  path?: never;
  query?: {
    external_file_id?: string | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files";
};

export type UploadFileApiV1FilesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileApiV1FilesPostError =
  UploadFileApiV1FilesPostErrors[keyof UploadFileApiV1FilesPostErrors];

export type UploadFileApiV1FilesPostResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type UploadFileApiV1FilesPostResponse =
  UploadFileApiV1FilesPostResponses[keyof UploadFileApiV1FilesPostResponses];

export type GeneratePresignedUrlApiV1FilesPutData = {
  body: FileCreate;
  path?: never;
  query?: {
    expires_at_seconds?: number | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files";
};

export type GeneratePresignedUrlApiV1FilesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GeneratePresignedUrlApiV1FilesPutError =
  GeneratePresignedUrlApiV1FilesPutErrors[keyof GeneratePresignedUrlApiV1FilesPutErrors];

export type GeneratePresignedUrlApiV1FilesPutResponses = {
  /**
   * Successful Response
   */
  200: FileIdPresignedUrl;
};

export type GeneratePresignedUrlApiV1FilesPutResponse =
  GeneratePresignedUrlApiV1FilesPutResponses[keyof GeneratePresignedUrlApiV1FilesPutResponses];

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutData = {
  body: FileCreateFromUrl;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/upload_from_url";
};

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutError =
  UploadFileFromUrlApiV1FilesUploadFromUrlPutErrors[keyof UploadFileFromUrlApiV1FilesUploadFromUrlPutErrors];

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutResponse =
  UploadFileFromUrlApiV1FilesUploadFromUrlPutResponses[keyof UploadFileFromUrlApiV1FilesUploadFromUrlPutResponses];

export type ReadFileContentApiV1FilesIdContentGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    expires_at_seconds?: number | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/content";
};

export type ReadFileContentApiV1FilesIdContentGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ReadFileContentApiV1FilesIdContentGetError =
  ReadFileContentApiV1FilesIdContentGetErrors[keyof ReadFileContentApiV1FilesIdContentGetErrors];

export type ReadFileContentApiV1FilesIdContentGetResponses = {
  /**
   * Successful Response
   */
  200: PresignedUrl;
};

export type ReadFileContentApiV1FilesIdContentGetResponse =
  ReadFileContentApiV1FilesIdContentGetResponses[keyof ReadFileContentApiV1FilesIdContentGetResponses];

export type SearchPipelinesApiV1PipelinesGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    project_name?: string | null;
    pipeline_name?: string | null;
    pipeline_type?: PipelineType | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines";
};

export type SearchPipelinesApiV1PipelinesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SearchPipelinesApiV1PipelinesGetError =
  SearchPipelinesApiV1PipelinesGetErrors[keyof SearchPipelinesApiV1PipelinesGetErrors];

export type SearchPipelinesApiV1PipelinesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PipelineReadable>;
};

export type SearchPipelinesApiV1PipelinesGetResponse =
  SearchPipelinesApiV1PipelinesGetResponses[keyof SearchPipelinesApiV1PipelinesGetResponses];

export type CreatePipelineApiV1PipelinesPostData = {
  body: PipelineCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines";
};

export type CreatePipelineApiV1PipelinesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreatePipelineApiV1PipelinesPostError =
  CreatePipelineApiV1PipelinesPostErrors[keyof CreatePipelineApiV1PipelinesPostErrors];

export type CreatePipelineApiV1PipelinesPostResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type CreatePipelineApiV1PipelinesPostResponse =
  CreatePipelineApiV1PipelinesPostResponses[keyof CreatePipelineApiV1PipelinesPostResponses];

export type UpsertPipelineApiV1PipelinesPutData = {
  body: PipelineCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines";
};

export type UpsertPipelineApiV1PipelinesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertPipelineApiV1PipelinesPutError =
  UpsertPipelineApiV1PipelinesPutErrors[keyof UpsertPipelineApiV1PipelinesPutErrors];

export type UpsertPipelineApiV1PipelinesPutResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type UpsertPipelineApiV1PipelinesPutResponse =
  UpsertPipelineApiV1PipelinesPutResponses[keyof UpsertPipelineApiV1PipelinesPutResponses];

export type DeletePipelineApiV1PipelinesPipelineIdDeleteData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}";
};

export type DeletePipelineApiV1PipelinesPipelineIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeletePipelineApiV1PipelinesPipelineIdDeleteError =
  DeletePipelineApiV1PipelinesPipelineIdDeleteErrors[keyof DeletePipelineApiV1PipelinesPipelineIdDeleteErrors];

export type DeletePipelineApiV1PipelinesPipelineIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeletePipelineApiV1PipelinesPipelineIdDeleteResponse =
  DeletePipelineApiV1PipelinesPipelineIdDeleteResponses[keyof DeletePipelineApiV1PipelinesPipelineIdDeleteResponses];

export type GetPipelineApiV1PipelinesPipelineIdGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}";
};

export type GetPipelineApiV1PipelinesPipelineIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetPipelineApiV1PipelinesPipelineIdGetError =
  GetPipelineApiV1PipelinesPipelineIdGetErrors[keyof GetPipelineApiV1PipelinesPipelineIdGetErrors];

export type GetPipelineApiV1PipelinesPipelineIdGetResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type GetPipelineApiV1PipelinesPipelineIdGetResponse =
  GetPipelineApiV1PipelinesPipelineIdGetResponses[keyof GetPipelineApiV1PipelinesPipelineIdGetResponses];

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutData = {
  body: PipelineUpdateWritable;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}";
};

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutError =
  UpdateExistingPipelineApiV1PipelinesPipelineIdPutErrors[keyof UpdateExistingPipelineApiV1PipelinesPipelineIdPutErrors];

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse =
  UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponses[keyof UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponses];

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: {
    full_details?: boolean | null;
  };
  url: "/api/v1/pipelines/{pipeline_id}/status";
};

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetError =
  GetPipelineStatusApiV1PipelinesPipelineIdStatusGetErrors[keyof GetPipelineStatusApiV1PipelinesPipelineIdStatusGetErrors];

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponses = {
  /**
   * Successful Response
   */
  200: ManagedIngestionStatusResponse;
};

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse =
  GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponses[keyof GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponses];

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/sync";
};

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostError =
  SyncPipelineApiV1PipelinesPipelineIdSyncPostErrors[keyof SyncPipelineApiV1PipelinesPipelineIdSyncPostErrors];

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse =
  SyncPipelineApiV1PipelinesPipelineIdSyncPostResponses[keyof SyncPipelineApiV1PipelinesPipelineIdSyncPostResponses];

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/sync/cancel";
};

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostError =
  CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostErrors[keyof CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostErrors];

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineReadable;
  };

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponse =
  CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponses[keyof CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponses];

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/force-delete";
};

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostError =
  ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostErrors[keyof ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostErrors];

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponse =
  ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponses[keyof ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponses];

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/copy";
};

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostError =
  CopyPipelineApiV1PipelinesPipelineIdCopyPostErrors[keyof CopyPipelineApiV1PipelinesPipelineIdCopyPostErrors];

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse =
  CopyPipelineApiV1PipelinesPipelineIdCopyPostResponses[keyof CopyPipelineApiV1PipelinesPipelineIdCopyPostResponses];

export type RunSearchApiV1PipelinesPipelineIdRetrievePostData = {
  body: RetrievalParams;
  path: {
    pipeline_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines/{pipeline_id}/retrieve";
};

export type RunSearchApiV1PipelinesPipelineIdRetrievePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunSearchApiV1PipelinesPipelineIdRetrievePostError =
  RunSearchApiV1PipelinesPipelineIdRetrievePostErrors[keyof RunSearchApiV1PipelinesPipelineIdRetrievePostErrors];

export type RunSearchApiV1PipelinesPipelineIdRetrievePostResponses = {
  /**
   * Successful Response
   */
  200: RetrieveResults;
};

export type RunSearchApiV1PipelinesPipelineIdRetrievePostResponse =
  RunSearchApiV1PipelinesPipelineIdRetrievePostResponses[keyof RunSearchApiV1PipelinesPipelineIdRetrievePostResponses];

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/playground-session";
  };

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetError =
  GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetErrors[keyof GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetErrors];

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponses =
  {
    /**
     * Successful Response
     */
    200: PlaygroundSession;
  };

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponse =
  GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponses[keyof GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponses];

export type ChatApiV1PipelinesPipelineIdChatPostData = {
  body: ChatInputParams;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/chat";
};

export type ChatApiV1PipelinesPipelineIdChatPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ChatApiV1PipelinesPipelineIdChatPostError =
  ChatApiV1PipelinesPipelineIdChatPostErrors[keyof ChatApiV1PipelinesPipelineIdChatPostErrors];

export type ChatApiV1PipelinesPipelineIdChatPostResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources";
  };

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetError =
  ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetErrors[keyof ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetErrors];

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<PipelineDataSourceReadable>;
  };

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse =
  ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponses[keyof ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponses];

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData =
  {
    body: Array<PipelineDataSourceCreate>;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources";
  };

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutError =
  AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutErrors[keyof AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutErrors];

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponses =
  {
    /**
     * Successful Response
     */
    200: Array<PipelineDataSourceReadable>;
  };

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse =
  AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponses[keyof AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponses];

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutData =
  {
    body: PipelineDataSourceUpdate;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}";
  };

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutError =
  UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutErrors[keyof UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutErrors];

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineDataSourceReadable;
  };

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponse =
  UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponses[keyof UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponses];

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData =
  {
    body?: DataSourceSyncRequest | null;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/sync";
  };

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostError =
  SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostErrors[keyof SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostErrors];

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineReadable;
  };

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse =
  SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponses[keyof SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponses];

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetData =
  {
    body?: never;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/status";
  };

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetError =
  GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetErrors[keyof GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetErrors];

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponses =
  {
    /**
     * Successful Response
     */
    200: ManagedIngestionStatusResponse;
  };

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponse =
  GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponses[keyof GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponses];

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: {
    data_source_id?: string | null;
    only_manually_uploaded?: boolean;
    file_name_contains?: string | null;
    limit?: number | null;
    offset?: number | null;
    order_by?: string | null;
  };
  url: "/api/v1/pipelines/{pipeline_id}/files2";
};

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetError =
  ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetErrors[keyof ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetErrors];

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedListPipelineFilesResponse;
};

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponse =
  ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponses[keyof ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponses];

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: {
      data_source_id?: string | null;
      only_manually_uploaded?: boolean;
    };
    url: "/api/v1/pipelines/{pipeline_id}/files/status-counts";
  };

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetError =
  GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetErrors[keyof GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetErrors];

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponses =
  {
    /**
     * Successful Response
     */
    200: FileCountByStatusResponse;
  };

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponse =
  GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponses[keyof GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponses];

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData =
  {
    body?: never;
    path: {
      file_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}/status";
  };

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetError =
  GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetErrors[keyof GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetErrors];

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponses =
  {
    /**
     * Successful Response
     */
    200: ManagedIngestionStatusResponse;
  };

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse =
  GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponses[keyof GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponses];

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutData = {
  body: Array<PipelineFileCreate>;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/files";
};

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutError =
  AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutErrors[keyof AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutErrors];

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponses = {
  /**
   * Successful Response
   */
  200: Array<PipelineFile>;
};

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponse =
  AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponses[keyof AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponses];

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData = {
  body?: never;
  path: {
    file_id: string;
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}";
};

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteError =
  DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteErrors[keyof DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteErrors];

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse =
  DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponses[keyof DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponses];

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData = {
  body: PipelineFileUpdate;
  path: {
    file_id: string;
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}";
};

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutError =
  UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutErrors[keyof UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutErrors];

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineFile;
  };

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse =
  UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponses[keyof UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponses];

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/metadata";
  };

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteError =
  DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteErrors[keyof DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteErrors];

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse =
  DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponses[keyof DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponses];

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData = {
  body: BodyImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPut;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/metadata";
};

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutError =
  ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutErrors[keyof ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutErrors];

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponses =
  {
    /**
     * Successful Response
     */
    200: {
      [key: string]: string;
    };
  };

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse =
  ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponses[keyof ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponses];

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: {
    skip?: number;
    limit?: number;
    file_id?: string | null;
    only_direct_upload?: boolean | null;
    only_api_data_source_documents?: boolean | null;
    status_refresh_policy?: "cached" | "ttl";
  };
  url: "/api/v1/pipelines/{pipeline_id}/documents";
};

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetError =
  ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetErrors[keyof ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetErrors];

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<CloudDocument>;
  };

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse =
  ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponses[keyof ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponses];

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData =
  {
    body: Array<CloudDocumentCreate>;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents";
  };

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostError =
  CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostErrors[keyof CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostErrors];

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponses =
  {
    /**
     * Successful Response
     */
    200: Array<CloudDocument>;
  };

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse =
  CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponses[keyof CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponses];

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData =
  {
    body: Array<CloudDocumentCreate>;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents";
  };

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutError =
  UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutErrors[keyof UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutErrors];

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponses =
  {
    /**
     * Successful Response
     */
    200: Array<CloudDocument>;
  };

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse =
  UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponses[keyof UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponses];

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: {
      skip?: number;
      limit?: number;
      file_id?: string | null;
      only_direct_upload?: boolean | null;
      only_api_data_source_documents?: boolean | null;
      status_refresh_policy?: "cached" | "ttl";
    };
    url: "/api/v1/pipelines/{pipeline_id}/documents/paginated";
  };

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetError =
  PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetErrors[keyof PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetErrors];

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponses =
  {
    /**
     * Successful Response
     */
    200: PaginatedListCloudDocumentsResponse;
  };

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponse =
  PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponses[keyof PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponses];

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}";
  };

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteError =
  DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteErrors[keyof DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteErrors];

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse =
  DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponses[keyof DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponses];

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}";
  };

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetError =
  GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetErrors[keyof GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetErrors];

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: CloudDocument;
  };

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse =
  GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponses[keyof GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponses];

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/status";
  };

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetError =
  GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetErrors[keyof GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetErrors];

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponses =
  {
    /**
     * Successful Response
     */
    200: ManagedIngestionStatusResponse;
  };

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse =
  GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponses[keyof GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponses];

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/sync";
  };

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostError =
  SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostErrors[keyof SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostErrors];

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/chunks";
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetError =
  ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetErrors[keyof ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetErrors];

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<TextNode>;
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse =
  ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponses[keyof ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponses];

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: {
      batch_size?: number;
      /**
       * Only sync retriable documents (failed/cancelled/not-started/stalled-in-progress)
       */
      only_failed?: boolean;
    };
    url: "/api/v1/pipelines/{pipeline_id}/documents/force-sync-all";
  };

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostError =
  ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostErrors[keyof ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostErrors];

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostResponses =
  {
    /**
     * Successful Response
     */
    202: unknown;
  };

export type ListRetrieversApiV1RetrieversGetData = {
  body?: never;
  path?: never;
  query?: {
    name?: string | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers";
};

export type ListRetrieversApiV1RetrieversGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListRetrieversApiV1RetrieversGetError =
  ListRetrieversApiV1RetrieversGetErrors[keyof ListRetrieversApiV1RetrieversGetErrors];

export type ListRetrieversApiV1RetrieversGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Retriever>;
};

export type ListRetrieversApiV1RetrieversGetResponse =
  ListRetrieversApiV1RetrieversGetResponses[keyof ListRetrieversApiV1RetrieversGetResponses];

export type CreateRetrieverApiV1RetrieversPostData = {
  body: RetrieverCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers";
};

export type CreateRetrieverApiV1RetrieversPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateRetrieverApiV1RetrieversPostError =
  CreateRetrieverApiV1RetrieversPostErrors[keyof CreateRetrieverApiV1RetrieversPostErrors];

export type CreateRetrieverApiV1RetrieversPostResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type CreateRetrieverApiV1RetrieversPostResponse =
  CreateRetrieverApiV1RetrieversPostResponses[keyof CreateRetrieverApiV1RetrieversPostResponses];

export type UpsertRetrieverApiV1RetrieversPutData = {
  body: RetrieverCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers";
};

export type UpsertRetrieverApiV1RetrieversPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertRetrieverApiV1RetrieversPutError =
  UpsertRetrieverApiV1RetrieversPutErrors[keyof UpsertRetrieverApiV1RetrieversPutErrors];

export type UpsertRetrieverApiV1RetrieversPutResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type UpsertRetrieverApiV1RetrieversPutResponse =
  UpsertRetrieverApiV1RetrieversPutResponses[keyof UpsertRetrieverApiV1RetrieversPutResponses];

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteData = {
  body?: never;
  path: {
    retriever_id: string;
  };
  query?: never;
  url: "/api/v1/retrievers/{retriever_id}";
};

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteError =
  DeleteRetrieverApiV1RetrieversRetrieverIdDeleteErrors[keyof DeleteRetrieverApiV1RetrieversRetrieverIdDeleteErrors];

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponse =
  DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponses[keyof DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponses];

export type GetRetrieverApiV1RetrieversRetrieverIdGetData = {
  body?: never;
  path: {
    retriever_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers/{retriever_id}";
};

export type GetRetrieverApiV1RetrieversRetrieverIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetRetrieverApiV1RetrieversRetrieverIdGetError =
  GetRetrieverApiV1RetrieversRetrieverIdGetErrors[keyof GetRetrieverApiV1RetrieversRetrieverIdGetErrors];

export type GetRetrieverApiV1RetrieversRetrieverIdGetResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type GetRetrieverApiV1RetrieversRetrieverIdGetResponse =
  GetRetrieverApiV1RetrieversRetrieverIdGetResponses[keyof GetRetrieverApiV1RetrieversRetrieverIdGetResponses];

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutData = {
  body: RetrieverUpdate;
  path: {
    retriever_id: string;
  };
  query?: never;
  url: "/api/v1/retrievers/{retriever_id}";
};

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutError =
  UpdateRetrieverApiV1RetrieversRetrieverIdPutErrors[keyof UpdateRetrieverApiV1RetrieversRetrieverIdPutErrors];

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutResponse =
  UpdateRetrieverApiV1RetrieversRetrieverIdPutResponses[keyof UpdateRetrieverApiV1RetrieversRetrieverIdPutResponses];

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostData = {
  body: CompositeRetrievalParams;
  path: {
    retriever_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers/{retriever_id}/retrieve";
};

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostError =
  RetrieveApiV1RetrieversRetrieverIdRetrievePostErrors[keyof RetrieveApiV1RetrieversRetrieverIdRetrievePostErrors];

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostResponses = {
  /**
   * Successful Response
   */
  200: CompositeRetrievalResult;
};

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostResponse =
  RetrieveApiV1RetrieversRetrieverIdRetrievePostResponses[keyof RetrieveApiV1RetrieversRetrieverIdRetrievePostResponses];

export type DirectRetrieveApiV1RetrieversRetrievePostData = {
  body: DirectRetrievalParams;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers/retrieve";
};

export type DirectRetrieveApiV1RetrieversRetrievePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DirectRetrieveApiV1RetrieversRetrievePostError =
  DirectRetrieveApiV1RetrieversRetrievePostErrors[keyof DirectRetrieveApiV1RetrieversRetrievePostErrors];

export type DirectRetrieveApiV1RetrieversRetrievePostResponses = {
  /**
   * Successful Response
   */
  200: CompositeRetrievalResult;
};

export type DirectRetrieveApiV1RetrieversRetrievePostResponse =
  DirectRetrieveApiV1RetrieversRetrievePostResponses[keyof DirectRetrieveApiV1RetrieversRetrievePostResponses];

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData = {
  body?: never;
  path: {
    job_id: string;
    name: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/image/{name}";
};

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetError =
  GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetErrors[keyof GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetErrors];

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetData =
  {
    body?: never;
    path?: never;
    query?: never;
    url: "/api/v1/parsing/supported_file_extensions";
  };

export type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<LlamaParseSupportedFileExtensions>;
  };

export type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse =
  GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponses[keyof GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponses];

export type ScreenshotApiV1ParsingScreenshotPostData = {
  body?: BodyScreenshotApiV1ParsingScreenshotPost;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/v1/parsing/screenshot";
};

export type ScreenshotApiV1ParsingScreenshotPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ScreenshotApiV1ParsingScreenshotPostError =
  ScreenshotApiV1ParsingScreenshotPostErrors[keyof ScreenshotApiV1ParsingScreenshotPostErrors];

export type ScreenshotApiV1ParsingScreenshotPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type ScreenshotApiV1ParsingScreenshotPostResponse =
  ScreenshotApiV1ParsingScreenshotPostResponses[keyof ScreenshotApiV1ParsingScreenshotPostResponses];

export type UploadFileApiV1ParsingUploadPostData = {
  body?: BodyUploadFileApiV1ParsingUploadPost;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/v1/parsing/upload";
};

export type UploadFileApiV1ParsingUploadPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileApiV1ParsingUploadPostError =
  UploadFileApiV1ParsingUploadPostErrors[keyof UploadFileApiV1ParsingUploadPostErrors];

export type UploadFileApiV1ParsingUploadPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileApiV1ParsingUploadPostResponse =
  UploadFileApiV1ParsingUploadPostResponses[keyof UploadFileApiV1ParsingUploadPostResponses];

export type GetJobApiV1ParsingJobJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}";
};

export type GetJobApiV1ParsingJobJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobApiV1ParsingJobJobIdGetError =
  GetJobApiV1ParsingJobJobIdGetErrors[keyof GetJobApiV1ParsingJobJobIdGetErrors];

export type GetJobApiV1ParsingJobJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type GetJobApiV1ParsingJobJobIdGetResponse =
  GetJobApiV1ParsingJobJobIdGetResponses[keyof GetJobApiV1ParsingJobJobIdGetResponses];

export type GetJobParametersApiV1ParsingJobJobIdParametersGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/parameters";
};

export type GetJobParametersApiV1ParsingJobJobIdParametersGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobParametersApiV1ParsingJobJobIdParametersGetError =
  GetJobParametersApiV1ParsingJobJobIdParametersGetErrors[keyof GetJobParametersApiV1ParsingJobJobIdParametersGetErrors];

export type GetJobParametersApiV1ParsingJobJobIdParametersGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/details";
};

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetError =
  GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetErrors[keyof GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetErrors];

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/parsing/job/{job_id}/result/text";
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetError =
  GetJobTextResultApiV1ParsingJobJobIdResultTextGetErrors[keyof GetJobTextResultApiV1ParsingJobJobIdResultTextGetErrors];

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobTextResult;
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse =
  GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponses[keyof GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponses];

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/pdf";
};

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetError =
  GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetErrors[keyof GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetErrors];

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetData =
  {
    body?: never;
    path: {
      job_id: string;
    };
    query?: {
      organization_id?: string | null;
    };
    url: "/api/v1/parsing/job/{job_id}/result/structured";
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetError =
  GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetErrors[keyof GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetErrors];

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponses =
  {
    /**
     * Successful Response
     */
    200: ParsingJobStructuredResult;
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponse =
  GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponses[keyof GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponses];

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/xlsx";
};

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetError =
  GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetErrors[keyof GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetErrors];

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/parsing/job/{job_id}/result/markdown";
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetError =
  GetJobResultApiV1ParsingJobJobIdResultMarkdownGetErrors[keyof GetJobResultApiV1ParsingJobJobIdResultMarkdownGetErrors];

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobMarkdownResult;
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse =
  GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponses[keyof GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponses];

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/parsing/job/{job_id}/result/json";
};

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetError =
  GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetErrors[keyof GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetErrors];

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobJsonResult;
};

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse =
  GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponses[keyof GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponses];

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData = {
  body?: never;
  path: {
    job_id: string;
    filename: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/read/{filename}";
};

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetError =
  GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetErrors[keyof GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetErrors];

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponses = {
  /**
   * Successful Response
   */
  200: PresignedUrl;
};

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse =
  GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponses[keyof GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponses];

export type ListClassifyJobsApiV1ClassifierJobsGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
    page_size?: number | null;
    page_token?: string | null;
  };
  url: "/api/v1/classifier/jobs";
};

export type ListClassifyJobsApiV1ClassifierJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListClassifyJobsApiV1ClassifierJobsGetError =
  ListClassifyJobsApiV1ClassifierJobsGetErrors[keyof ListClassifyJobsApiV1ClassifierJobsGetErrors];

export type ListClassifyJobsApiV1ClassifierJobsGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseClassifyJob;
};

export type ListClassifyJobsApiV1ClassifierJobsGetResponse =
  ListClassifyJobsApiV1ClassifierJobsGetResponses[keyof ListClassifyJobsApiV1ClassifierJobsGetResponses];

export type CreateClassifyJobApiV1ClassifierJobsPostData = {
  body: ClassifyJobCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/classifier/jobs";
};

export type CreateClassifyJobApiV1ClassifierJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateClassifyJobApiV1ClassifierJobsPostError =
  CreateClassifyJobApiV1ClassifierJobsPostErrors[keyof CreateClassifyJobApiV1ClassifierJobsPostErrors];

export type CreateClassifyJobApiV1ClassifierJobsPostResponses = {
  /**
   * Successful Response
   */
  200: ClassifyJob;
};

export type CreateClassifyJobApiV1ClassifierJobsPostResponse =
  CreateClassifyJobApiV1ClassifierJobsPostResponses[keyof CreateClassifyJobApiV1ClassifierJobsPostResponses];

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetData = {
  body?: never;
  path: {
    classify_job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/classifier/jobs/{classify_job_id}";
};

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetError =
  GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetErrors[keyof GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetErrors];

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ClassifyJob;
};

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponse =
  GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponses[keyof GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponses];

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetData =
  {
    body?: never;
    path: {
      classify_job_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/classifier/jobs/{classify_job_id}/results";
  };

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetError =
  GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetErrors[keyof GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetErrors];

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponses =
  {
    /**
     * Successful Response
     */
    200: ClassifyJobResults;
  };

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponse =
  GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponses[keyof GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponses];

export type ListJobsApiV1ExtractionJobsGetData = {
  body?: never;
  path?: never;
  query: {
    extraction_agent_id: string;
  };
  url: "/api/v1/extraction/jobs";
};

export type ListJobsApiV1ExtractionJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListJobsApiV1ExtractionJobsGetError =
  ListJobsApiV1ExtractionJobsGetErrors[keyof ListJobsApiV1ExtractionJobsGetErrors];

export type ListJobsApiV1ExtractionJobsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ExtractJob>;
};

export type ListJobsApiV1ExtractionJobsGetResponse =
  ListJobsApiV1ExtractionJobsGetResponses[keyof ListJobsApiV1ExtractionJobsGetResponses];

export type RunJobApiV1ExtractionJobsPostData = {
  body: ExtractJobCreate;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs";
};

export type RunJobApiV1ExtractionJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunJobApiV1ExtractionJobsPostError =
  RunJobApiV1ExtractionJobsPostErrors[keyof RunJobApiV1ExtractionJobsPostErrors];

export type RunJobApiV1ExtractionJobsPostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type RunJobApiV1ExtractionJobsPostResponse =
  RunJobApiV1ExtractionJobsPostResponses[keyof RunJobApiV1ExtractionJobsPostResponses];

export type GetJobApiV1ExtractionJobsJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/extraction/jobs/{job_id}";
};

export type GetJobApiV1ExtractionJobsJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobApiV1ExtractionJobsJobIdGetError =
  GetJobApiV1ExtractionJobsJobIdGetErrors[keyof GetJobApiV1ExtractionJobsJobIdGetErrors];

export type GetJobApiV1ExtractionJobsJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type GetJobApiV1ExtractionJobsJobIdGetResponse =
  GetJobApiV1ExtractionJobsJobIdGetResponses[keyof GetJobApiV1ExtractionJobsJobIdGetResponses];

export type RunJobOnFileApiV1ExtractionJobsFilePostData = {
  body: BodyRunJobOnFileApiV1ExtractionJobsFilePost;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs/file";
};

export type RunJobOnFileApiV1ExtractionJobsFilePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunJobOnFileApiV1ExtractionJobsFilePostError =
  RunJobOnFileApiV1ExtractionJobsFilePostErrors[keyof RunJobOnFileApiV1ExtractionJobsFilePostErrors];

export type RunJobOnFileApiV1ExtractionJobsFilePostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type RunJobOnFileApiV1ExtractionJobsFilePostResponse =
  RunJobOnFileApiV1ExtractionJobsFilePostResponses[keyof RunJobOnFileApiV1ExtractionJobsFilePostResponses];

export type RunBatchJobsApiV1ExtractionJobsBatchPostData = {
  body: ExtractJobCreateBatch;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs/batch";
};

export type RunBatchJobsApiV1ExtractionJobsBatchPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunBatchJobsApiV1ExtractionJobsBatchPostError =
  RunBatchJobsApiV1ExtractionJobsBatchPostErrors[keyof RunBatchJobsApiV1ExtractionJobsBatchPostErrors];

export type RunBatchJobsApiV1ExtractionJobsBatchPostResponses = {
  /**
   * Successful Response
   */
  200: Array<ExtractJob>;
};

export type RunBatchJobsApiV1ExtractionJobsBatchPostResponse =
  RunBatchJobsApiV1ExtractionJobsBatchPostResponses[keyof RunBatchJobsApiV1ExtractionJobsBatchPostResponses];

export type GetJobResultApiV1ExtractionJobsJobIdResultGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/jobs/{job_id}/result";
};

export type GetJobResultApiV1ExtractionJobsJobIdResultGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobResultApiV1ExtractionJobsJobIdResultGetError =
  GetJobResultApiV1ExtractionJobsJobIdResultGetErrors[keyof GetJobResultApiV1ExtractionJobsJobIdResultGetErrors];

export type GetJobResultApiV1ExtractionJobsJobIdResultGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractResultset;
};

export type GetJobResultApiV1ExtractionJobsJobIdResultGetResponse =
  GetJobResultApiV1ExtractionJobsJobIdResultGetResponses[keyof GetJobResultApiV1ExtractionJobsJobIdResultGetResponses];

export type ListExtractRunsApiV1ExtractionRunsGetData = {
  body?: never;
  path?: never;
  query: {
    extraction_agent_id: string;
    skip?: number;
    limit?: number;
  };
  url: "/api/v1/extraction/runs";
};

export type ListExtractRunsApiV1ExtractionRunsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListExtractRunsApiV1ExtractionRunsGetError =
  ListExtractRunsApiV1ExtractionRunsGetErrors[keyof ListExtractRunsApiV1ExtractionRunsGetErrors];

export type ListExtractRunsApiV1ExtractionRunsGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedExtractRunsResponse;
};

export type ListExtractRunsApiV1ExtractionRunsGetResponse =
  ListExtractRunsApiV1ExtractionRunsGetResponses[keyof ListExtractRunsApiV1ExtractionRunsGetResponses];

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetData = {
  body?: never;
  path?: never;
  query: {
    extraction_agent_id: string;
  };
  url: "/api/v1/extraction/runs/latest-from-ui";
};

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetError =
  GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetErrors[keyof GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetErrors];

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractRun | null;
};

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponse =
  GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponses[keyof GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponses];

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/runs/by-job/{job_id}";
};

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetError =
  GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetErrors[keyof GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetErrors];

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractRun;
};

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponse =
  GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponses[keyof GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponses];

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteData = {
  body?: never;
  path: {
    run_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/runs/{run_id}";
};

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteError =
  DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteErrors[keyof DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteErrors];

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetRunApiV1ExtractionRunsRunIdGetData = {
  body?: never;
  path: {
    run_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/runs/{run_id}";
};

export type GetRunApiV1ExtractionRunsRunIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetRunApiV1ExtractionRunsRunIdGetError =
  GetRunApiV1ExtractionRunsRunIdGetErrors[keyof GetRunApiV1ExtractionRunsRunIdGetErrors];

export type GetRunApiV1ExtractionRunsRunIdGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractRun;
};

export type GetRunApiV1ExtractionRunsRunIdGetResponse =
  GetRunApiV1ExtractionRunsRunIdGetResponses[keyof GetRunApiV1ExtractionRunsRunIdGetResponses];

export type ExtractStatelessApiV1ExtractionRunPostData = {
  body: ExtractStatelessRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/run";
};

export type ExtractStatelessApiV1ExtractionRunPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ExtractStatelessApiV1ExtractionRunPostError =
  ExtractStatelessApiV1ExtractionRunPostErrors[keyof ExtractStatelessApiV1ExtractionRunPostErrors];

export type ExtractStatelessApiV1ExtractionRunPostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type ExtractStatelessApiV1ExtractionRunPostResponse =
  ExtractStatelessApiV1ExtractionRunPostResponses[keyof ExtractStatelessApiV1ExtractionRunPostResponses];

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Whether to include default agents in the results
     */
    include_default?: boolean;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/extraction-agents";
};

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetError =
  ListExtractionAgentsApiV1ExtractionExtractionAgentsGetErrors[keyof ListExtractionAgentsApiV1ExtractionExtractionAgentsGetErrors];

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ExtractAgent>;
};

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponse =
  ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponses[keyof ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponses];

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostData = {
  body: ExtractAgentCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/extraction-agents";
};

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostError =
  CreateExtractionAgentApiV1ExtractionExtractionAgentsPostErrors[keyof CreateExtractionAgentApiV1ExtractionExtractionAgentsPostErrors];

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponse =
  CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponses[keyof CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponses];

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostData =
  {
    body: ExtractSchemaValidateRequest;
    path?: never;
    query?: never;
    url: "/api/v1/extraction/extraction-agents/schema/validation";
  };

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostError =
  ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostErrors[keyof ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostErrors];

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractSchemaValidateResponse;
  };

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponse =
  ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponses[keyof ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponses];

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostData =
  {
    body: ExtractSchemaGenerateRequest;
    path?: never;
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/extraction/extraction-agents/schema/generate";
  };

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostError =
  GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostErrors[keyof GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostErrors];

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractSchemaGenerateResponse;
  };

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponse =
  GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponses[keyof GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponses];

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetData =
  {
    body?: never;
    path: {
      name: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/extraction/extraction-agents/by-name/{name}";
  };

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetError =
  GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetErrors[keyof GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetErrors];

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponse =
  GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponses[keyof GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponses];

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetData =
  {
    body?: never;
    path?: never;
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/extraction/extraction-agents/default";
  };

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetError =
  GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetErrors[keyof GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetErrors];

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponse =
  GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponses[keyof GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponses];

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteData =
  {
    body?: never;
    path: {
      extraction_agent_id: string;
    };
    query?: never;
    url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}";
  };

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteError =
  DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteErrors[keyof DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteErrors];

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetData =
  {
    body?: never;
    path: {
      extraction_agent_id: string;
    };
    query?: never;
    url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}";
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetError =
  GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetErrors[keyof GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetErrors];

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponse =
  GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponses[keyof GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponses];

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutData =
  {
    body: ExtractAgentUpdate;
    path: {
      extraction_agent_id: string;
    };
    query?: never;
    url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}";
  };

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutError =
  UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutErrors[keyof UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutErrors];

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponse =
  UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponses[keyof UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponses];

export type ListUsageMetricsApiV1BetaUsageMetricsGetData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Number of items per page
     */
    page_size?: number | null;
    /**
     * Token for pagination
     */
    page_token?: string | null;
    /**
     * Include total count in response
     */
    include_total?: boolean;
    /**
     * Filter by project ID
     */
    project_id?: string | null;
    /**
     * Filter by user ID
     */
    user_id?: string | null;
    /**
     * Filter by event types
     */
    event_types?: Array<string> | null;
    /**
     * Filter by specific days (YYYY-MM-DD)
     */
    days?: Array<string> | null;
    /**
     * Filter by days on or before this date (YYYY-MM-DD)
     */
    day_on_or_before?: string | null;
    /**
     * Filter by days on or after this date (YYYY-MM-DD)
     */
    day_on_or_after?: string | null;
    /**
     * Filter by event aggregation type
     */
    event_aggregation_type?: string | null;
    /**
     * Filter by event aggregation key
     */
    event_aggregation_key?: string | null;
    organization_id: string;
  };
  url: "/api/v1/beta/usage-metrics";
};

export type ListUsageMetricsApiV1BetaUsageMetricsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListUsageMetricsApiV1BetaUsageMetricsGetError =
  ListUsageMetricsApiV1BetaUsageMetricsGetErrors[keyof ListUsageMetricsApiV1BetaUsageMetricsGetErrors];

export type ListUsageMetricsApiV1BetaUsageMetricsGetResponses = {
  /**
   * Successful Response
   */
  200: UsageMetricQueryResponse;
};

export type ListUsageMetricsApiV1BetaUsageMetricsGetResponse =
  ListUsageMetricsApiV1BetaUsageMetricsGetResponses[keyof ListUsageMetricsApiV1BetaUsageMetricsGetResponses];

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteData = {
  body?: never;
  path: {
    item_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/{item_id}";
};

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteError =
  DeleteAgentDataApiV1BetaAgentDataItemIdDeleteErrors[keyof DeleteAgentDataApiV1BetaAgentDataItemIdDeleteErrors];

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponses = {
  /**
   * Successful Response
   */
  200: {
    [key: string]: string;
  };
};

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponse =
  DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponses[keyof DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponses];

export type GetAgentDataApiV1BetaAgentDataItemIdGetData = {
  body?: never;
  path: {
    item_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/{item_id}";
};

export type GetAgentDataApiV1BetaAgentDataItemIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetAgentDataApiV1BetaAgentDataItemIdGetError =
  GetAgentDataApiV1BetaAgentDataItemIdGetErrors[keyof GetAgentDataApiV1BetaAgentDataItemIdGetErrors];

export type GetAgentDataApiV1BetaAgentDataItemIdGetResponses = {
  /**
   * Successful Response
   */
  200: AgentData;
};

export type GetAgentDataApiV1BetaAgentDataItemIdGetResponse =
  GetAgentDataApiV1BetaAgentDataItemIdGetResponses[keyof GetAgentDataApiV1BetaAgentDataItemIdGetResponses];

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutData = {
  body: AgentDataUpdate;
  path: {
    item_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/{item_id}";
};

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutError =
  UpdateAgentDataApiV1BetaAgentDataItemIdPutErrors[keyof UpdateAgentDataApiV1BetaAgentDataItemIdPutErrors];

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutResponses = {
  /**
   * Successful Response
   */
  200: AgentData;
};

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutResponse =
  UpdateAgentDataApiV1BetaAgentDataItemIdPutResponses[keyof UpdateAgentDataApiV1BetaAgentDataItemIdPutResponses];

export type CreateAgentDataApiV1BetaAgentDataPostData = {
  body: AgentDataCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data";
};

export type CreateAgentDataApiV1BetaAgentDataPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateAgentDataApiV1BetaAgentDataPostError =
  CreateAgentDataApiV1BetaAgentDataPostErrors[keyof CreateAgentDataApiV1BetaAgentDataPostErrors];

export type CreateAgentDataApiV1BetaAgentDataPostResponses = {
  /**
   * Successful Response
   */
  200: AgentData;
};

export type CreateAgentDataApiV1BetaAgentDataPostResponse =
  CreateAgentDataApiV1BetaAgentDataPostResponses[keyof CreateAgentDataApiV1BetaAgentDataPostResponses];

export type SearchAgentDataApiV1BetaAgentDataSearchPostData = {
  body: SearchRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/:search";
};

export type SearchAgentDataApiV1BetaAgentDataSearchPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SearchAgentDataApiV1BetaAgentDataSearchPostError =
  SearchAgentDataApiV1BetaAgentDataSearchPostErrors[keyof SearchAgentDataApiV1BetaAgentDataSearchPostErrors];

export type SearchAgentDataApiV1BetaAgentDataSearchPostResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseAgentData;
};

export type SearchAgentDataApiV1BetaAgentDataSearchPostResponse =
  SearchAgentDataApiV1BetaAgentDataSearchPostResponses[keyof SearchAgentDataApiV1BetaAgentDataSearchPostResponses];

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostData = {
  body: AggregateRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/:aggregate";
};

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostError =
  AggregateAgentDataApiV1BetaAgentDataAggregatePostErrors[keyof AggregateAgentDataApiV1BetaAgentDataAggregatePostErrors];

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseAggregateGroup;
};

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostResponse =
  AggregateAgentDataApiV1BetaAgentDataAggregatePostResponses[keyof AggregateAgentDataApiV1BetaAgentDataAggregatePostResponses];

export type DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostData = {
  body: DeleteRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/:delete";
};

export type DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostError =
  DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostErrors[keyof DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostErrors];

export type DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostResponses = {
  /**
   * Successful Response
   */
  200: DeleteResponse;
};

export type DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostResponse =
  DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostResponses[keyof DeleteAgentDataByQueryApiV1BetaAgentDataDeletePostResponses];

export type CreateFileApiV1BetaFilesPostData = {
  body: FileCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files";
};

export type CreateFileApiV1BetaFilesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateFileApiV1BetaFilesPostError =
  CreateFileApiV1BetaFilesPostErrors[keyof CreateFileApiV1BetaFilesPostErrors];

export type CreateFileApiV1BetaFilesPostResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type CreateFileApiV1BetaFilesPostResponse =
  CreateFileApiV1BetaFilesPostResponses[keyof CreateFileApiV1BetaFilesPostResponses];

export type UpsertFileApiV1BetaFilesPutData = {
  body: FileCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files";
};

export type UpsertFileApiV1BetaFilesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertFileApiV1BetaFilesPutError =
  UpsertFileApiV1BetaFilesPutErrors[keyof UpsertFileApiV1BetaFilesPutErrors];

export type UpsertFileApiV1BetaFilesPutResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type UpsertFileApiV1BetaFilesPutResponse =
  UpsertFileApiV1BetaFilesPutResponses[keyof UpsertFileApiV1BetaFilesPutResponses];

export type QueryFilesApiV1BetaFilesQueryPostData = {
  body: FileQueryRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files/query";
};

export type QueryFilesApiV1BetaFilesQueryPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type QueryFilesApiV1BetaFilesQueryPostError =
  QueryFilesApiV1BetaFilesQueryPostErrors[keyof QueryFilesApiV1BetaFilesQueryPostErrors];

export type QueryFilesApiV1BetaFilesQueryPostResponses = {
  /**
   * Successful Response
   */
  200: FileQueryResponse;
};

export type QueryFilesApiV1BetaFilesQueryPostResponse =
  QueryFilesApiV1BetaFilesQueryPostResponses[keyof QueryFilesApiV1BetaFilesQueryPostResponses];

export type DeleteFileApiV1BetaFilesFileIdDeleteData = {
  body?: never;
  path: {
    file_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files/{file_id}";
};

export type DeleteFileApiV1BetaFilesFileIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteFileApiV1BetaFilesFileIdDeleteError =
  DeleteFileApiV1BetaFilesFileIdDeleteErrors[keyof DeleteFileApiV1BetaFilesFileIdDeleteErrors];

export type DeleteFileApiV1BetaFilesFileIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteFileApiV1BetaFilesFileIdDeleteResponse =
  DeleteFileApiV1BetaFilesFileIdDeleteResponses[keyof DeleteFileApiV1BetaFilesFileIdDeleteResponses];

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetData = {
  body?: never;
  path?: never;
  query?: {
    page_size?: number | null;
    page_token?: string | null;
    name?: string | null;
    creator?: string | null;
    version?: string | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations";
};

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetError =
  ListParseConfigurationsApiV1BetaParseConfigurationsGetErrors[keyof ListParseConfigurationsApiV1BetaParseConfigurationsGetErrors];

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetResponses = {
  /**
   * Successful Response
   */
  200: ParseConfigurationQueryResponse;
};

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetResponse =
  ListParseConfigurationsApiV1BetaParseConfigurationsGetResponses[keyof ListParseConfigurationsApiV1BetaParseConfigurationsGetResponses];

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostData = {
  body: ParseConfigurationCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations";
};

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostError =
  CreateParseConfigurationApiV1BetaParseConfigurationsPostErrors[keyof CreateParseConfigurationApiV1BetaParseConfigurationsPostErrors];

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostResponses =
  {
    /**
     * Successful Response
     */
    201: ParseConfiguration;
  };

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostResponse =
  CreateParseConfigurationApiV1BetaParseConfigurationsPostResponses[keyof CreateParseConfigurationApiV1BetaParseConfigurationsPostResponses];

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteData =
  {
    body?: never;
    path: {
      config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/parse-configurations/{config_id}";
  };

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteError =
  DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteErrors[keyof DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteErrors];

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponse =
  DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponses[keyof DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponses];

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetData = {
  body?: never;
  path: {
    config_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations/{config_id}";
};

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetError =
  GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetErrors[keyof GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetErrors];

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: ParseConfiguration;
  };

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponse =
  GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponses[keyof GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponses];

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutData =
  {
    body: ParseConfigurationUpdate;
    path: {
      config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/parse-configurations/{config_id}";
  };

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutError =
  UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutErrors[keyof UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutErrors];

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: ParseConfiguration;
  };

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponse =
  UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponses[keyof UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponses];

export type ListSpreadsheetJobsApiV1BetaSheetsJobsGetData = {
  body?: never;
  path?: never;
  query?: {
    include_results?: boolean;
    project_id?: string | null;
    organization_id?: string | null;
    page_size?: number | null;
    page_token?: string | null;
  };
  url: "/api/v1/beta/sheets/jobs";
};

export type ListSpreadsheetJobsApiV1BetaSheetsJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListSpreadsheetJobsApiV1BetaSheetsJobsGetError =
  ListSpreadsheetJobsApiV1BetaSheetsJobsGetErrors[keyof ListSpreadsheetJobsApiV1BetaSheetsJobsGetErrors];

export type ListSpreadsheetJobsApiV1BetaSheetsJobsGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseSpreadsheetJob;
};

export type ListSpreadsheetJobsApiV1BetaSheetsJobsGetResponse =
  ListSpreadsheetJobsApiV1BetaSheetsJobsGetResponses[keyof ListSpreadsheetJobsApiV1BetaSheetsJobsGetResponses];

export type CreateSpreadsheetJobApiV1BetaSheetsJobsPostData = {
  body: SpreadsheetJobCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/sheets/jobs";
};

export type CreateSpreadsheetJobApiV1BetaSheetsJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateSpreadsheetJobApiV1BetaSheetsJobsPostError =
  CreateSpreadsheetJobApiV1BetaSheetsJobsPostErrors[keyof CreateSpreadsheetJobApiV1BetaSheetsJobsPostErrors];

export type CreateSpreadsheetJobApiV1BetaSheetsJobsPostResponses = {
  /**
   * Successful Response
   */
  200: SpreadsheetJob;
};

export type CreateSpreadsheetJobApiV1BetaSheetsJobsPostResponse =
  CreateSpreadsheetJobApiV1BetaSheetsJobsPostResponses[keyof CreateSpreadsheetJobApiV1BetaSheetsJobsPostResponses];

export type DeleteSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdDeleteData =
  {
    body?: never;
    path: {
      spreadsheet_job_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/sheets/jobs/{spreadsheet_job_id}";
  };

export type DeleteSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdDeleteError =
  DeleteSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdDeleteErrors[keyof DeleteSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdDeleteErrors];

export type DeleteSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetData = {
  body?: never;
  path: {
    spreadsheet_job_id: string;
  };
  query?: {
    include_results?: boolean;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/sheets/jobs/{spreadsheet_job_id}";
};

export type GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetError =
  GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetErrors[keyof GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetErrors];

export type GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: SpreadsheetJob;
};

export type GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetResponse =
  GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetResponses[keyof GetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetResponses];

export type GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetData =
  {
    body?: never;
    path: {
      spreadsheet_job_id: string;
      region_id: string;
      region_type: SpreadsheetResultType;
    };
    query?: {
      expires_at_seconds?: number | null;
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/sheets/jobs/{spreadsheet_job_id}/regions/{region_id}/result/{region_type}";
  };

export type GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetError =
  GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetErrors[keyof GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetErrors];

export type GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetResponses =
  {
    /**
     * Successful Response
     */
    200: PresignedUrl;
  };

export type GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetResponse =
  GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetResponses[keyof GetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetResponses];

export type ListDirectoriesApiV1BetaDirectoriesGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
    name?: string | null;
    data_source_id?: string | null;
    include_deleted?: boolean;
    page_size?: number | null;
    page_token?: string | null;
  };
  url: "/api/v1/beta/directories";
};

export type ListDirectoriesApiV1BetaDirectoriesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDirectoriesApiV1BetaDirectoriesGetError =
  ListDirectoriesApiV1BetaDirectoriesGetErrors[keyof ListDirectoriesApiV1BetaDirectoriesGetErrors];

export type ListDirectoriesApiV1BetaDirectoriesGetResponses = {
  /**
   * Successful Response
   */
  200: DirectoryQueryResponse;
};

export type ListDirectoriesApiV1BetaDirectoriesGetResponse =
  ListDirectoriesApiV1BetaDirectoriesGetResponses[keyof ListDirectoriesApiV1BetaDirectoriesGetResponses];

export type CreateDirectoryApiV1BetaDirectoriesPostData = {
  body: DirectoryCreateRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directories";
};

export type CreateDirectoryApiV1BetaDirectoriesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateDirectoryApiV1BetaDirectoriesPostError =
  CreateDirectoryApiV1BetaDirectoriesPostErrors[keyof CreateDirectoryApiV1BetaDirectoriesPostErrors];

export type CreateDirectoryApiV1BetaDirectoriesPostResponses = {
  /**
   * Successful Response
   */
  201: DirectoryResponse;
};

export type CreateDirectoryApiV1BetaDirectoriesPostResponse =
  CreateDirectoryApiV1BetaDirectoriesPostResponses[keyof CreateDirectoryApiV1BetaDirectoriesPostResponses];

export type DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteData = {
  body?: never;
  path: {
    directory_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directories/{directory_id}";
};

export type DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteError =
  DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteErrors[keyof DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteErrors];

export type DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteResponse =
  DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteResponses[keyof DeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteResponses];

export type GetDirectoryApiV1BetaDirectoriesDirectoryIdGetData = {
  body?: never;
  path: {
    directory_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directories/{directory_id}";
};

export type GetDirectoryApiV1BetaDirectoriesDirectoryIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDirectoryApiV1BetaDirectoriesDirectoryIdGetError =
  GetDirectoryApiV1BetaDirectoriesDirectoryIdGetErrors[keyof GetDirectoryApiV1BetaDirectoriesDirectoryIdGetErrors];

export type GetDirectoryApiV1BetaDirectoriesDirectoryIdGetResponses = {
  /**
   * Successful Response
   */
  200: DirectoryResponse;
};

export type GetDirectoryApiV1BetaDirectoriesDirectoryIdGetResponse =
  GetDirectoryApiV1BetaDirectoriesDirectoryIdGetResponses[keyof GetDirectoryApiV1BetaDirectoriesDirectoryIdGetResponses];

export type UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchData = {
  body: DirectoryUpdateRequest;
  path: {
    directory_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directories/{directory_id}";
};

export type UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchError =
  UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchErrors[keyof UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchErrors];

export type UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchResponses = {
  /**
   * Successful Response
   */
  200: DirectoryResponse;
};

export type UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchResponse =
  UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchResponses[keyof UpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchResponses];

export type CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostData = {
  body: DirectorySyncJobCreateRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directory-sync-jobs/";
};

export type CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostError =
  CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostErrors[keyof CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostErrors];

export type CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostResponses = {
  /**
   * Successful Response
   */
  201: DirectorySyncJobResponse;
};

export type CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostResponse =
  CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostResponses[keyof CreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostResponses];

export type GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directory-sync-jobs/{job_id}";
};

export type GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetError =
  GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetErrors[keyof GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetErrors];

export type GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: DirectorySyncJobResponse;
};

export type GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetResponse =
  GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetResponses[keyof GetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetResponses];

export type ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetData = {
  body?: never;
  path: {
    directory_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
    display_name?: string | null;
    display_name_contains?: string | null;
    unique_id?: string | null;
    file_id?: string | null;
    include_deleted?: boolean;
    page_size?: number | null;
    page_token?: string | null;
  };
  url: "/api/v1/beta/directories/{directory_id}/files";
};

export type ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetError =
  ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetErrors[keyof ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetErrors];

export type ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetResponses =
  {
    /**
     * Successful Response
     */
    200: DirectoryFileQueryResponse;
  };

export type ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetResponse =
  ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetResponses[keyof ListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetResponses];

export type AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostData = {
  body: DirectoryFileCreateRequest;
  path: {
    directory_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/directories/{directory_id}/files";
};

export type AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostError =
  AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostErrors[keyof AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostErrors];

export type AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostResponses =
  {
    /**
     * Successful Response
     */
    201: DirectoryFileResponse;
  };

export type AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostResponse =
  AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostResponses[keyof AddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostResponses];

export type UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostData =
  {
    body: BodyUploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPost;
    path: {
      directory_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/directories/{directory_id}/files/upload";
  };

export type UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostError =
  UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostErrors[keyof UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostErrors];

export type UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostResponses =
  {
    /**
     * Successful Response
     */
    201: DirectoryFileResponse;
  };

export type UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostResponse =
  UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostResponses[keyof UploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostResponses];

export type DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteData =
  {
    body?: never;
    path: {
      directory_id: string;
      directory_file_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/directories/{directory_id}/files/{directory_file_id}";
  };

export type DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteError =
  DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteErrors[keyof DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteErrors];

export type DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteResponse =
  DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteResponses[keyof DeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteResponses];

export type GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetData =
  {
    body?: never;
    path: {
      directory_id: string;
      directory_file_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/directories/{directory_id}/files/{directory_file_id}";
  };

export type GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetError =
  GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetErrors[keyof GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetErrors];

export type GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: DirectoryFileResponse;
  };

export type GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetResponse =
  GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetResponses[keyof GetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetResponses];

export type UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchData =
  {
    body: DirectoryFileUpdateRequest;
    path: {
      directory_id: string;
      directory_file_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/directories/{directory_id}/files/{directory_file_id}";
  };

export type UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchError =
  UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchErrors[keyof UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchErrors];

export type UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchResponses =
  {
    /**
     * Successful Response
     */
    200: DirectoryFileResponse;
  };

export type UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchResponse =
  UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchResponses[keyof UpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchResponses];

export type ListSplitJobsApiV1BetaSplitJobsGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
    page_size?: number | null;
    page_token?: string | null;
  };
  url: "/api/v1/beta/split/jobs";
};

export type ListSplitJobsApiV1BetaSplitJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListSplitJobsApiV1BetaSplitJobsGetError =
  ListSplitJobsApiV1BetaSplitJobsGetErrors[keyof ListSplitJobsApiV1BetaSplitJobsGetErrors];

export type ListSplitJobsApiV1BetaSplitJobsGetResponses = {
  /**
   * Successful Response
   */
  200: SplitJobQueryResponse;
};

export type ListSplitJobsApiV1BetaSplitJobsGetResponse =
  ListSplitJobsApiV1BetaSplitJobsGetResponses[keyof ListSplitJobsApiV1BetaSplitJobsGetResponses];

export type CreateSplitJobApiV1BetaSplitJobsPostData = {
  body: SplitCreateRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/split/jobs";
};

export type CreateSplitJobApiV1BetaSplitJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateSplitJobApiV1BetaSplitJobsPostError =
  CreateSplitJobApiV1BetaSplitJobsPostErrors[keyof CreateSplitJobApiV1BetaSplitJobsPostErrors];

export type CreateSplitJobApiV1BetaSplitJobsPostResponses = {
  /**
   * Successful Response
   */
  201: SplitJobResponse;
};

export type CreateSplitJobApiV1BetaSplitJobsPostResponse =
  CreateSplitJobApiV1BetaSplitJobsPostResponses[keyof CreateSplitJobApiV1BetaSplitJobsPostResponses];

export type GetSplitJobApiV1BetaSplitJobsSplitJobIdGetData = {
  body?: never;
  path: {
    split_job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/split/jobs/{split_job_id}";
};

export type GetSplitJobApiV1BetaSplitJobsSplitJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetSplitJobApiV1BetaSplitJobsSplitJobIdGetError =
  GetSplitJobApiV1BetaSplitJobsSplitJobIdGetErrors[keyof GetSplitJobApiV1BetaSplitJobsSplitJobIdGetErrors];

export type GetSplitJobApiV1BetaSplitJobsSplitJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: SplitJobResponse;
};

export type GetSplitJobApiV1BetaSplitJobsSplitJobIdGetResponse =
  GetSplitJobApiV1BetaSplitJobsSplitJobIdGetResponses[keyof GetSplitJobApiV1BetaSplitJobsSplitJobIdGetResponses];

export type ListBatchJobsApiV1BetaBatchProcessingGetData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by directory ID
     */
    directory_id?: string | null;
    /**
     * Filter by job type (PARSE, EXTRACT, CLASSIFY)
     */
    job_type?: BatchJobType | null;
    /**
     * Filter by job status (PENDING, RUNNING, COMPLETED, FAILED, CANCELLED)
     */
    status?: BatchJobStatus | null;
    /**
     * Maximum number of jobs to return
     */
    limit?: number;
    /**
     * Number of jobs to skip for pagination
     */
    offset?: number;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batch-processing";
};

export type ListBatchJobsApiV1BetaBatchProcessingGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListBatchJobsApiV1BetaBatchProcessingGetError =
  ListBatchJobsApiV1BetaBatchProcessingGetErrors[keyof ListBatchJobsApiV1BetaBatchProcessingGetErrors];

export type ListBatchJobsApiV1BetaBatchProcessingGetResponses = {
  /**
   * Successful Response
   */
  200: BatchJobQueryResponse;
};

export type ListBatchJobsApiV1BetaBatchProcessingGetResponse =
  ListBatchJobsApiV1BetaBatchProcessingGetResponses[keyof ListBatchJobsApiV1BetaBatchProcessingGetResponses];

export type CreateBatchJobApiV1BetaBatchProcessingPostData = {
  body: BatchJobCreateRequest;
  headers?: {
    "temporal-namespace"?: string | null;
  };
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batch-processing";
};

export type CreateBatchJobApiV1BetaBatchProcessingPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateBatchJobApiV1BetaBatchProcessingPostError =
  CreateBatchJobApiV1BetaBatchProcessingPostErrors[keyof CreateBatchJobApiV1BetaBatchProcessingPostErrors];

export type CreateBatchJobApiV1BetaBatchProcessingPostResponses = {
  /**
   * Successful Response
   */
  201: BatchJobResponse;
};

export type CreateBatchJobApiV1BetaBatchProcessingPostResponse =
  CreateBatchJobApiV1BetaBatchProcessingPostResponses[keyof CreateBatchJobApiV1BetaBatchProcessingPostResponses];

export type GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batch-processing/{job_id}";
};

export type GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetError =
  GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetErrors[keyof GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetErrors];

export type GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: BatchJobStatusResponse;
};

export type GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetResponse =
  GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetResponses[keyof GetBatchJobStatusApiV1BetaBatchProcessingJobIdGetResponses];

export type ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    /**
     * Filter items by status
     */
    status?: BatchFileStatus | null;
    /**
     * Maximum number of items to return
     */
    limit?: number;
    /**
     * Number of items to skip
     */
    offset?: number;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batch-processing/{job_id}/items";
};

export type ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetError =
  ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetErrors[keyof ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetErrors];

export type ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetResponses = {
  /**
   * Successful Response
   */
  200: BatchItemListResponse;
};

export type ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetResponse =
  ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetResponses[keyof ListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetResponses];

export type CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostData = {
  body: BatchJobCancelRequest;
  headers?: {
    "temporal-namespace"?: string | null;
  };
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batch-processing/{job_id}/cancel";
};

export type CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostError =
  CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostErrors[keyof CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostErrors];

export type CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostResponses = {
  /**
   * Successful Response
   */
  200: BatchJobCancelResponse;
};

export type CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostResponse =
  CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostResponses[keyof CancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostResponses];

export type GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetData =
  {
    body?: never;
    path: {
      item_id: string;
    };
    query?: {
      /**
       * Filter results by job type
       */
      job_type?: BatchJobType | null;
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/batch-processing/items/{item_id}/processing-results";
  };

export type GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetError =
  GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetErrors[keyof GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetErrors];

export type GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetResponses =
  {
    /**
     * Successful Response
     */
    200: ItemProcessingResultsResponse;
  };

export type GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetResponse =
  GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetResponses[keyof GetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetResponses];

export type UploadFileMultipartApiV2Alpha1ParseUploadPostData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v2alpha1/parse/upload";
};

export type UploadFileMultipartApiV2Alpha1ParseUploadPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileMultipartApiV2Alpha1ParseUploadPostError =
  UploadFileMultipartApiV2Alpha1ParseUploadPostErrors[keyof UploadFileMultipartApiV2Alpha1ParseUploadPostErrors];

export type UploadFileMultipartApiV2Alpha1ParseUploadPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileMultipartApiV2Alpha1ParseUploadPostResponse =
  UploadFileMultipartApiV2Alpha1ParseUploadPostResponses[keyof UploadFileMultipartApiV2Alpha1ParseUploadPostResponses];

export type UploadFileByIdApiV2Alpha1ParsePostData = {
  body: LlamaParseFileIdConfiguration;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v2alpha1/parse/";
};

export type UploadFileByIdApiV2Alpha1ParsePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileByIdApiV2Alpha1ParsePostError =
  UploadFileByIdApiV2Alpha1ParsePostErrors[keyof UploadFileByIdApiV2Alpha1ParsePostErrors];

export type UploadFileByIdApiV2Alpha1ParsePostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileByIdApiV2Alpha1ParsePostResponse =
  UploadFileByIdApiV2Alpha1ParsePostResponses[keyof UploadFileByIdApiV2Alpha1ParsePostResponses];

export type UploadFileByUrlApiV2Alpha1ParseUrlPostData = {
  body: LlamaParseUrlConfiguration;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v2alpha1/parse/url";
};

export type UploadFileByUrlApiV2Alpha1ParseUrlPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileByUrlApiV2Alpha1ParseUrlPostError =
  UploadFileByUrlApiV2Alpha1ParseUrlPostErrors[keyof UploadFileByUrlApiV2Alpha1ParseUrlPostErrors];

export type UploadFileByUrlApiV2Alpha1ParseUrlPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileByUrlApiV2Alpha1ParseUrlPostResponse =
  UploadFileByUrlApiV2Alpha1ParseUrlPostResponses[keyof UploadFileByUrlApiV2Alpha1ParseUrlPostResponses];

export type GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v2alpha1/parse/job/{job_id}/result/markdown";
};

export type GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetError =
  GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetErrors[keyof GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetErrors];

export type GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetResponses =
  {
    /**
     * Successful Response
     */
    200: MarkdownResult;
  };

export type GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetResponse =
  GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetResponses[keyof GetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetResponses];

export type GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v2alpha1/parse/job/{job_id}/result/text";
};

export type GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetError =
  GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetErrors[keyof GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetErrors];

export type GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetResponses = {
  /**
   * Successful Response
   */
  200: TextResult;
};

export type GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetResponse =
  GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetResponses[keyof GetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetResponses];

export type GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetData =
  {
    body?: never;
    path: {
      job_id: string;
    };
    query?: {
      organization_id?: string | null;
    };
    url: "/api/v2alpha1/parse/job/{job_id}/result/structured";
  };

export type GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetError =
  GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetErrors[keyof GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetErrors];

export type GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetResponses =
  {
    /**
     * Successful Response
     */
    200: StructuredResult;
  };

export type GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetResponse =
  GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetResponses[keyof GetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetResponses];

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {});
};
