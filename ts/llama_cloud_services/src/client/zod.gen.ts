// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zNoneSegmentationConfig = z.object({
  mode: z.literal("none").optional().default("none"),
});

export const zPageSegmentationConfig = z.object({
  mode: z.literal("page").optional().default("page"),
  page_separator: z.string().optional().default(`
---
`),
});

export const zElementSegmentationConfig = z.object({
  mode: z.literal("element").optional().default("element"),
});

export const zNoneChunkingConfig = z.object({
  mode: z.literal("none").optional().default("none"),
});

export const zCharacterChunkingConfig = z.object({
  chunk_size: z.number().int().optional().default(1024),
  chunk_overlap: z.number().int().optional().default(200),
  mode: z.literal("character").optional().default("character"),
});

export const zTokenChunkingConfig = z.object({
  chunk_size: z.number().int().optional().default(1024),
  chunk_overlap: z.number().int().optional().default(200),
  mode: z.literal("token").optional().default("token"),
  separator: z.string().optional().default(" "),
});

export const zSentenceChunkingConfig = z.object({
  chunk_size: z.number().int().optional().default(1024),
  chunk_overlap: z.number().int().optional().default(200),
  mode: z.literal("sentence").optional().default("sentence"),
  separator: z.string().optional().default(" "),
  paragraph_separator: z.string().optional().default(`


`),
});

export const zSemanticChunkingConfig = z.object({
  mode: z.literal("semantic").optional().default("semantic"),
  buffer_size: z.number().int().optional().default(1),
  breakpoint_percentile_threshold: z.number().int().optional().default(95),
});

export const zAdvancedModeTransformConfig = z.object({
  mode: z.literal("advanced").optional().default("advanced"),
  segmentation_config: z
    .union([
      zNoneSegmentationConfig,
      zPageSegmentationConfig,
      zElementSegmentationConfig,
    ])
    .optional(),
  chunking_config: z
    .union([
      zNoneChunkingConfig,
      zCharacterChunkingConfig,
      zTokenChunkingConfig,
      zSentenceChunkingConfig,
      zSemanticChunkingConfig,
    ])
    .optional(),
});

export const zAgentData = z.object({
  id: z.union([z.string(), z.null()]).optional(),
  deployment_name: z.string(),
  project_id: z.union([z.string(), z.null()]).optional(),
  collection: z.string().optional().default("default"),
  data: z.object({}),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zAgentDataCreate = z.object({
  deployment_name: z.string(),
  collection: z.string().optional().default("default"),
  data: z.object({}),
});

export const zAgentDataUpdate = z.object({
  data: z.object({}),
});

export const zAggregateGroup = z.object({
  group_key: z.object({}),
  count: z.union([z.number().int(), z.null()]).optional(),
  first_item: z.union([z.object({}), z.null()]).optional(),
});

export const zAggregateRequest = z.object({
  page_size: z.union([z.number().int(), z.null()]).optional(),
  page_token: z.union([z.string(), z.null()]).optional(),
  filter: z.union([z.object({}), z.null()]).optional(),
  order_by: z.union([z.string(), z.null()]).optional(),
  deployment_name: z.string(),
  collection: z.string().optional().default("default"),
  group_by: z.union([z.array(z.string()), z.null()]).optional(),
  count: z.union([z.boolean(), z.null()]).optional(),
  first: z.union([z.boolean(), z.null()]).optional(),
  offset: z.union([z.number().int().gte(0).lte(1000), z.null()]).optional(),
});

export const zApplyStatusDetails = z.object({
  status: z.enum(["pending", "processing", "completed", "failed"]).optional(),
  effective_at: z.string().datetime().optional(),
  job_record_id: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
});

export const zAutoTransformConfig = z.object({
  mode: z.literal("auto").optional().default("auto"),
  chunk_size: z.number().int().optional().default(1024),
  chunk_overlap: z.number().int().optional().default(200),
});

export const zAzureOpenAiEmbedding = z.object({
  model_name: z.string().optional().default("text-embedding-ada-002"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  additional_kwargs: z.object({}).optional(),
  api_key: z.union([z.string(), z.null()]).optional(),
  api_base: z.string().optional().default(""),
  api_version: z.string().optional().default(""),
  max_retries: z.number().int().optional().default(10),
  timeout: z.number().optional().default(60),
  default_headers: z.union([z.object({}), z.null()]).optional(),
  reuse_client: z.boolean().optional().default(true),
  dimensions: z.union([z.number().int(), z.null()]).optional(),
  azure_endpoint: z.union([z.string(), z.null()]).optional(),
  azure_deployment: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("AzureOpenAIEmbedding"),
});

export const zAzureOpenAiEmbeddingConfig = z.object({
  type: z.literal("AZURE_EMBEDDING").optional().default("AZURE_EMBEDDING"),
  component: zAzureOpenAiEmbedding.optional(),
});

export const zBatchFileStatus = z.enum([
  "pending",
  "processing",
  "completed",
  "failed",
  "skipped",
  "cancelled",
]);

export const zBatchItemDetail = z.object({
  status: zBatchFileStatus,
  effective_at: z.string().datetime().optional(),
  job_record_id: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
  item_id: z.string(),
  item_name: z.string(),
  job_id: z.union([z.string(), z.null()]).optional(),
  skip_reason: z.union([z.string(), z.null()]).optional(),
  started_at: z.union([z.string().datetime(), z.null()]).optional(),
  completed_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zBatchItemListResponse = z.object({
  items: z.array(zBatchItemDetail).optional(),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zBatchJobCancelRequest = z.object({
  reason: z.union([z.string(), z.null()]).optional(),
});

export const zBatchJobStatus = z.enum([
  "pending",
  "running",
  "dispatched",
  "completed",
  "failed",
  "cancelled",
]);

export const zBatchJobCancelResponse = z.object({
  job_id: z.string(),
  status: zBatchJobStatus,
  processed_items: z.number().int(),
  message: z.string(),
});

export const zParserLanguages = z.enum([
  "af",
  "az",
  "bs",
  "cs",
  "cy",
  "da",
  "de",
  "en",
  "es",
  "et",
  "fr",
  "ga",
  "hr",
  "hu",
  "id",
  "is",
  "it",
  "ku",
  "la",
  "lt",
  "lv",
  "mi",
  "ms",
  "mt",
  "nl",
  "no",
  "oc",
  "pi",
  "pl",
  "pt",
  "ro",
  "rs_latin",
  "sk",
  "sl",
  "sq",
  "sv",
  "sw",
  "tl",
  "tr",
  "uz",
  "vi",
  "ar",
  "fa",
  "ug",
  "ur",
  "bn",
  "as",
  "mni",
  "ru",
  "rs_cyrillic",
  "be",
  "bg",
  "uk",
  "mn",
  "abq",
  "ady",
  "kbd",
  "ava",
  "dar",
  "inh",
  "che",
  "lbe",
  "lez",
  "tab",
  "tjk",
  "hi",
  "mr",
  "ne",
  "bh",
  "mai",
  "ang",
  "bho",
  "mah",
  "sck",
  "new",
  "gom",
  "sa",
  "bgc",
  "th",
  "ch_sim",
  "ch_tra",
  "ja",
  "ko",
  "ta",
  "te",
  "kn",
]);

export const zParsingMode = z.enum([
  "parse_page_without_llm",
  "parse_page_with_llm",
  "parse_page_with_lvm",
  "parse_page_with_agent",
  "parse_page_with_layout_agent",
  "parse_document_with_llm",
  "parse_document_with_lvm",
  "parse_document_with_agent",
]);

export const zFailPageMode = z.enum([
  "raw_text",
  "blank_page",
  "error_message",
]);

export const zBatchParseJobConfig = z.object({
  priority: z
    .union([z.enum(["low", "medium", "high", "critical"]), z.null()])
    .optional(),
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
  resource_info: z.union([z.object({}), z.null()]).optional(),
  languages: z.array(zParserLanguages).min(1).optional(),
  parsing_instruction: z.union([z.string(), z.null()]).optional(),
  disable_ocr: z.union([z.boolean(), z.null()]).optional(),
  annotate_links: z.union([z.boolean(), z.null()]).optional(),
  adaptive_long_table: z.union([z.boolean(), z.null()]).optional(),
  compact_markdown_table: z.union([z.boolean(), z.null()]).optional(),
  disable_reconstruction: z.union([z.boolean(), z.null()]).optional(),
  disable_image_extraction: z.union([z.boolean(), z.null()]).optional(),
  invalidate_cache: z.union([z.boolean(), z.null()]).optional(),
  outlined_table_extraction: z.union([z.boolean(), z.null()]).optional(),
  aggressive_table_extraction: z.union([z.boolean(), z.null()]).optional(),
  merge_tables_across_pages_in_markdown: z
    .union([z.boolean(), z.null()])
    .optional(),
  output_pdf_of_document: z.union([z.boolean(), z.null()]).optional(),
  do_not_cache: z.union([z.boolean(), z.null()]).optional(),
  fast_mode: z.union([z.boolean(), z.null()]).optional(),
  skip_diagonal_text: z.union([z.boolean(), z.null()]).optional(),
  preserve_layout_alignment_across_pages: z
    .union([z.boolean(), z.null()])
    .optional(),
  preserve_very_small_text: z.union([z.boolean(), z.null()]).optional(),
  gpt4o_mode: z.union([z.boolean(), z.null()]).optional(),
  gpt4o_api_key: z.union([z.string(), z.null()]).optional(),
  do_not_unroll_columns: z.union([z.boolean(), z.null()]).optional(),
  extract_layout: z.union([z.boolean(), z.null()]).optional(),
  high_res_ocr: z.union([z.boolean(), z.null()]).optional(),
  html_make_all_elements_visible: z.union([z.boolean(), z.null()]).optional(),
  layout_aware: z.union([z.boolean(), z.null()]).optional(),
  specialized_chart_parsing_agentic: z
    .union([z.boolean(), z.null()])
    .optional(),
  specialized_chart_parsing_plus: z.union([z.boolean(), z.null()]).optional(),
  specialized_chart_parsing_efficient: z
    .union([z.boolean(), z.null()])
    .optional(),
  specialized_image_parsing: z.union([z.boolean(), z.null()]).optional(),
  precise_bounding_box: z.union([z.boolean(), z.null()]).optional(),
  line_level_bounding_box: z.union([z.boolean(), z.null()]).optional(),
  html_remove_navigation_elements: z.union([z.boolean(), z.null()]).optional(),
  html_remove_fixed_elements: z.union([z.boolean(), z.null()]).optional(),
  guess_xlsx_sheet_name: z.union([z.boolean(), z.null()]).optional(),
  page_separator: z.union([z.string(), z.null()]).optional(),
  bounding_box: z.union([z.string(), z.null()]).optional(),
  bbox_top: z.union([z.number(), z.null()]).optional(),
  bbox_right: z.union([z.number(), z.null()]).optional(),
  bbox_bottom: z.union([z.number(), z.null()]).optional(),
  bbox_left: z.union([z.number(), z.null()]).optional(),
  target_pages: z.union([z.string(), z.null()]).optional(),
  use_vendor_multimodal_model: z.union([z.boolean(), z.null()]).optional(),
  vendor_multimodal_model_name: z.union([z.string(), z.null()]).optional(),
  model: z.union([z.string(), z.null()]).optional(),
  vendor_multimodal_api_key: z.union([z.string(), z.null()]).optional(),
  page_prefix: z.union([z.string(), z.null()]).optional(),
  page_suffix: z.union([z.string(), z.null()]).optional(),
  webhook_url: z.union([z.string(), z.null()]).optional(),
  preset: z.union([z.string(), z.null()]).optional(),
  take_screenshot: z.union([z.boolean(), z.null()]).optional(),
  is_formatting_instruction: z.union([z.boolean(), z.null()]).optional(),
  premium_mode: z.union([z.boolean(), z.null()]).optional(),
  continuous_mode: z.union([z.boolean(), z.null()]).optional(),
  input_s3_path: z.union([z.string(), z.null()]).optional(),
  input_s3_region: z.union([z.string(), z.null()]).optional(),
  output_s3_path_prefix: z.union([z.string(), z.null()]).optional(),
  output_s3_region: z.union([z.string(), z.null()]).optional(),
  project_id: z.union([z.string(), z.null()]).optional(),
  azure_openai_deployment_name: z.union([z.string(), z.null()]).optional(),
  azure_openai_endpoint: z.union([z.string(), z.null()]).optional(),
  azure_openai_api_version: z.union([z.string(), z.null()]).optional(),
  azure_openai_key: z.union([z.string(), z.null()]).optional(),
  input_url: z.union([z.string(), z.null()]).optional(),
  http_proxy: z.union([z.string(), z.null()]).optional(),
  auto_mode: z.union([z.boolean(), z.null()]).optional(),
  auto_mode_trigger_on_regexp_in_page: z
    .union([z.string(), z.null()])
    .optional(),
  auto_mode_trigger_on_text_in_page: z.union([z.string(), z.null()]).optional(),
  auto_mode_trigger_on_table_in_page: z
    .union([z.boolean(), z.null()])
    .optional(),
  auto_mode_trigger_on_image_in_page: z
    .union([z.boolean(), z.null()])
    .optional(),
  auto_mode_configuration_json: z.union([z.string(), z.null()]).optional(),
  structured_output: z.union([z.boolean(), z.null()]).optional(),
  structured_output_json_schema: z.union([z.string(), z.null()]).optional(),
  structured_output_json_schema_name: z
    .union([z.string(), z.null()])
    .optional(),
  max_pages: z.union([z.number().int(), z.null()]).optional(),
  max_pages_enforced: z.union([z.number().int(), z.null()]).optional(),
  extract_charts: z.union([z.boolean(), z.null()]).optional(),
  formatting_instruction: z.union([z.string(), z.null()]).optional(),
  complemental_formatting_instruction: z
    .union([z.string(), z.null()])
    .optional(),
  content_guideline_instruction: z.union([z.string(), z.null()]).optional(),
  spreadsheet_extract_sub_tables: z.union([z.boolean(), z.null()]).optional(),
  spreadsheet_force_formula_computation: z
    .union([z.boolean(), z.null()])
    .optional(),
  inline_images_in_markdown: z.union([z.boolean(), z.null()]).optional(),
  job_timeout_in_seconds: z.union([z.number(), z.null()]).optional(),
  job_timeout_extra_time_per_page_in_seconds: z
    .union([z.number(), z.null()])
    .optional(),
  strict_mode_image_extraction: z.union([z.boolean(), z.null()]).optional(),
  strict_mode_image_ocr: z.union([z.boolean(), z.null()]).optional(),
  strict_mode_reconstruction: z.union([z.boolean(), z.null()]).optional(),
  strict_mode_buggy_font: z.union([z.boolean(), z.null()]).optional(),
  save_images: z.union([z.boolean(), z.null()]).optional(),
  hide_headers: z.union([z.boolean(), z.null()]).optional(),
  hide_footers: z.union([z.boolean(), z.null()]).optional(),
  page_header_prefix: z.union([z.string(), z.null()]).optional(),
  page_header_suffix: z.union([z.string(), z.null()]).optional(),
  page_footer_prefix: z.union([z.string(), z.null()]).optional(),
  page_footer_suffix: z.union([z.string(), z.null()]).optional(),
  keep_page_separator_when_merging_tables: z
    .union([z.boolean(), z.null()])
    .optional(),
  ignore_document_elements_for_layout_detection: z
    .union([z.boolean(), z.null()])
    .optional(),
  output_tables_as_HTML: z.union([z.boolean(), z.null()]).optional(),
  internal_is_screenshot_job: z.union([z.boolean(), z.null()]).optional(),
  parse_mode: z.union([zParsingMode, z.null()]).optional(),
  system_prompt: z.union([z.string(), z.null()]).optional(),
  system_prompt_append: z.union([z.string(), z.null()]).optional(),
  user_prompt: z.union([z.string(), z.null()]).optional(),
  page_error_tolerance: z.union([z.number(), z.null()]).optional(),
  replace_failed_page_mode: z.union([zFailPageMode, z.null()]).optional(),
  replace_failed_page_with_error_message_prefix: z
    .union([z.string(), z.null()])
    .optional(),
  replace_failed_page_with_error_message_suffix: z
    .union([z.string(), z.null()])
    .optional(),
  markdown_table_multiline_header_separator: z
    .union([z.string(), z.null()])
    .optional(),
  tier: z.union([z.string(), z.null()]).optional(),
  version: z.union([z.string(), z.null()]).optional(),
  extract_printed_page_number: z.union([z.boolean(), z.null()]).optional(),
  type: z.literal("parse").optional().default("parse"),
  lang: z.string().optional().default("en"),
  outputBucket: z.union([z.string(), z.null()]).optional(),
  pipeline_id: z.union([z.string(), z.null()]).optional(),
});

export const zBatchParseJobRecordCreate = z.object({
  job_name: z
    .literal("parse_raw_file_job")
    .optional()
    .default("parse_raw_file_job"),
  partitions: z.object({}).optional(),
  parameters: z.union([zBatchParseJobConfig, z.null()]).optional(),
  session_id: z.union([z.string().uuid(), z.null()]).optional(),
  correlation_id: z.union([z.string().uuid(), z.null()]).optional(),
  parent_job_execution_id: z.union([z.string().uuid(), z.null()]).optional(),
  user_id: z.union([z.string(), z.null()]).optional(),
  project_id: z.union([z.string().uuid(), z.null()]).optional(),
  webhook_url: z.union([z.string(), z.null()]).optional(),
});

export const zStatusEnum = z.enum([
  "PENDING",
  "SUCCESS",
  "ERROR",
  "PARTIAL_SUCCESS",
  "CANCELLED",
]);

export const zClassifierRule = z.object({
  type: z.string().min(1).max(50),
  description: z.string().min(10).max(500),
});

export const zClassifyParsingConfiguration = z.object({
  lang: zParserLanguages.optional(),
  max_pages: z.union([z.number().int(), z.null()]).optional(),
  target_pages: z
    .union([z.array(z.number().int()).min(1), z.null()])
    .optional(),
});

export const zClassifyJob = z.object({
  status: zStatusEnum,
  effective_at: z.string().datetime().optional(),
  job_record_id: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  rules: z.array(zClassifierRule).min(1),
  user_id: z.string(),
  project_id: z.string().uuid(),
  parsing_configuration: zClassifyParsingConfiguration.optional(),
});

export const zBatchJobCreateRequest = z.object({
  directory_id: z.union([z.string(), z.null()]).optional(),
  item_ids: z.union([z.array(z.string()), z.null()]).optional(),
  job_config: z.union([zBatchParseJobRecordCreate, zClassifyJob]),
  page_size: z.number().int().gte(1).lte(1000).optional().default(100),
  continue_as_new_threshold: z.union([z.number().int(), z.null()]).optional(),
});

export const zBatchJobType = z.enum(["parse", "extract", "classify"]);

export const zBatchJobResponse = z.object({
  status: zBatchJobStatus,
  effective_at: z.string().datetime().optional(),
  job_record_id: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
  id: z.string(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string(),
  directory_id: z.union([z.string(), z.null()]).optional(),
  job_type: zBatchJobType,
  total_items: z.number().int(),
  processed_items: z.number().int().optional().default(0),
  failed_items: z.number().int().optional().default(0),
  skipped_items: z.number().int().optional().default(0),
  workflow_id: z.union([z.string(), z.null()]).optional(),
  started_at: z.union([z.string().datetime(), z.null()]).optional(),
  completed_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zBatchJobQueryResponse = z.object({
  items: z.array(zBatchJobResponse),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zBatchJobStatusResponse = z.object({
  job: zBatchJobResponse,
  progress_percentage: z.number().gte(0).lte(100),
});

export const zBedrockEmbedding = z.object({
  model_name: z.string().optional().default("amazon.titan-embed-text-v1"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  profile_name: z.union([z.string(), z.null()]).optional(),
  aws_access_key_id: z.union([z.string(), z.null()]).optional(),
  aws_secret_access_key: z.union([z.string(), z.null()]).optional(),
  aws_session_token: z.union([z.string(), z.null()]).optional(),
  region_name: z.union([z.string(), z.null()]).optional(),
  max_retries: z.number().int().optional().default(10),
  timeout: z.number().optional().default(60),
  additional_kwargs: z.object({}).optional(),
  class_name: z.string().optional().default("BedrockEmbedding"),
});

export const zBedrockEmbeddingConfig = z.object({
  type: z.literal("BEDROCK_EMBEDDING").optional().default("BEDROCK_EMBEDDING"),
  component: zBedrockEmbedding.optional(),
});

export const zBodyImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPut =
  z.object({
    upload_file: z.string(),
  });

export const zBodyRunJobOnFileApiV1ExtractionJobsFilePost = z.object({
  extraction_agent_id: z.string().uuid(),
  file: z.string(),
  data_schema_override: z.union([z.string(), z.null()]).optional(),
  config_override: z.union([z.string(), z.null()]).optional(),
});

export const zBodyScreenshotApiV1ParsingScreenshotPost = z.object({
  file: z.union([z.string(), z.null()]).optional(),
  do_not_cache: z.boolean().optional().default(false),
  http_proxy: z.string().optional(),
  input_s3_path: z.string().optional().default(""),
  input_s3_region: z.string().optional().default(""),
  input_url: z.string().optional(),
  invalidate_cache: z.boolean().optional().default(false),
  max_pages: z.union([z.number().int(), z.null()]).optional(),
  output_s3_path_prefix: z.string().optional().default(""),
  output_s3_region: z.string().optional().default(""),
  target_pages: z.string().optional().default(""),
  webhook_url: z.string().optional().default(""),
  webhook_configurations: z.string().optional().default(""),
  job_timeout_in_seconds: z.number().optional(),
  job_timeout_extra_time_per_page_in_seconds: z.number().optional(),
});

export const zBodyUploadFileApiV1FilesPost = z.object({
  upload_file: z.string(),
});

export const zBodyUploadFileApiV1ParsingUploadPost = z.object({
  file: z.union([z.string(), z.null()]).optional(),
  adaptive_long_table: z.boolean().optional().default(false),
  annotate_links: z.boolean().optional().default(false),
  auto_mode: z.boolean().optional().default(false),
  auto_mode_trigger_on_image_in_page: z.boolean().optional().default(false),
  auto_mode_trigger_on_table_in_page: z.boolean().optional().default(false),
  auto_mode_trigger_on_text_in_page: z.string().optional(),
  auto_mode_trigger_on_regexp_in_page: z.string().optional(),
  auto_mode_configuration_json: z.string().optional(),
  azure_openai_api_version: z.string().optional(),
  azure_openai_deployment_name: z.string().optional(),
  azure_openai_endpoint: z.string().optional(),
  azure_openai_key: z.string().optional(),
  bbox_bottom: z.number().optional(),
  bbox_left: z.number().optional(),
  bbox_right: z.number().optional(),
  bbox_top: z.number().optional(),
  compact_markdown_table: z.boolean().optional().default(false),
  disable_ocr: z.boolean().optional().default(false),
  disable_reconstruction: z.boolean().optional().default(false),
  disable_image_extraction: z.boolean().optional().default(false),
  do_not_cache: z.boolean().optional().default(false),
  do_not_unroll_columns: z.boolean().optional().default(false),
  extract_charts: z.boolean().optional().default(false),
  guess_xlsx_sheet_name: z.boolean().optional().default(false),
  high_res_ocr: z.boolean().optional().default(false),
  html_make_all_elements_visible: z.boolean().optional().default(false),
  layout_aware: z.boolean().optional().default(false),
  specialized_chart_parsing_agentic: z.boolean().optional().default(false),
  specialized_chart_parsing_plus: z.boolean().optional().default(false),
  specialized_chart_parsing_efficient: z.boolean().optional().default(false),
  specialized_image_parsing: z.boolean().optional().default(false),
  precise_bounding_box: z.boolean().optional().default(false),
  line_level_bounding_box: z.boolean().optional().default(false),
  html_remove_fixed_elements: z.boolean().optional().default(false),
  html_remove_navigation_elements: z.boolean().optional().default(false),
  http_proxy: z.string().optional(),
  input_s3_path: z.string().optional().default(""),
  input_s3_region: z.string().optional().default(""),
  input_url: z.string().optional(),
  invalidate_cache: z.boolean().optional().default(false),
  language: z.array(zParserLanguages).optional().default(["en"]),
  extract_layout: z.boolean().optional().default(false),
  max_pages: z.union([z.number().int(), z.null()]).optional(),
  merge_tables_across_pages_in_markdown: z.boolean().optional().default(false),
  outlined_table_extraction: z.boolean().optional().default(false),
  aggressive_table_extraction: z.boolean().optional().default(false),
  output_pdf_of_document: z.boolean().optional().default(false),
  output_s3_path_prefix: z.string().optional().default(""),
  output_s3_region: z.string().optional().default(""),
  page_prefix: z.string().optional().default(""),
  page_separator: z.string().optional(),
  page_suffix: z.string().optional().default(""),
  preserve_layout_alignment_across_pages: z.boolean().optional().default(false),
  preserve_very_small_text: z.boolean().optional().default(false),
  skip_diagonal_text: z.boolean().optional().default(false),
  spreadsheet_extract_sub_tables: z.boolean().optional().default(true),
  spreadsheet_force_formula_computation: z.boolean().optional().default(false),
  inline_images_in_markdown: z.boolean().optional().default(false),
  structured_output: z.boolean().optional().default(false),
  structured_output_json_schema: z.string().optional(),
  structured_output_json_schema_name: z.string().optional(),
  take_screenshot: z.boolean().optional().default(false),
  target_pages: z.string().optional().default(""),
  vendor_multimodal_api_key: z.string().optional().default(""),
  vendor_multimodal_model_name: z.string().optional(),
  model: z.string().optional(),
  webhook_url: z.string().optional().default(""),
  webhook_configurations: z.string().optional().default(""),
  preset: z.string().optional().default(""),
  parse_mode: z.union([zParsingMode, z.null()]).optional(),
  page_error_tolerance: z.number().optional().default(0.05),
  replace_failed_page_mode: z.union([zFailPageMode, z.null()]).optional(),
  replace_failed_page_with_error_message_prefix: z
    .string()
    .optional()
    .default(""),
  replace_failed_page_with_error_message_suffix: z
    .string()
    .optional()
    .default(""),
  system_prompt: z.string().optional().default(""),
  system_prompt_append: z.string().optional().default(""),
  user_prompt: z.string().optional().default(""),
  job_timeout_in_seconds: z.number().optional(),
  job_timeout_extra_time_per_page_in_seconds: z.number().optional(),
  strict_mode_image_extraction: z.boolean().optional().default(false),
  strict_mode_image_ocr: z.boolean().optional().default(false),
  strict_mode_reconstruction: z.boolean().optional().default(false),
  strict_mode_buggy_font: z.boolean().optional().default(false),
  save_images: z.boolean().optional().default(true),
  ignore_document_elements_for_layout_detection: z
    .boolean()
    .optional()
    .default(false),
  keep_page_separator_when_merging_tables: z
    .boolean()
    .optional()
    .default(false),
  output_tables_as_HTML: z.boolean().optional().default(false),
  markdown_table_multiline_header_separator: z.string().optional(),
  use_vendor_multimodal_model: z.boolean().optional().default(false),
  bounding_box: z.string().optional().default(""),
  gpt4o_mode: z.boolean().optional().default(false),
  gpt4o_api_key: z.string().optional().default(""),
  complemental_formatting_instruction: z.string().optional(),
  content_guideline_instruction: z.string().optional(),
  premium_mode: z.boolean().optional().default(false),
  is_formatting_instruction: z.boolean().optional().default(true),
  continuous_mode: z.boolean().optional().default(false),
  parsing_instruction: z.string().optional().default(""),
  fast_mode: z.boolean().optional().default(false),
  formatting_instruction: z.string().optional(),
  hide_headers: z.boolean().optional().default(false),
  hide_footers: z.boolean().optional().default(false),
  page_header_prefix: z.string().optional(),
  page_header_suffix: z.string().optional(),
  page_footer_prefix: z.string().optional(),
  page_footer_suffix: z.string().optional(),
  remove_hidden_text: z.boolean().optional().default(false),
  presentation_out_of_bounds_content: z.boolean().optional().default(false),
  extract_printed_page_number: z.boolean().optional().default(false),
  tier: z.string().optional(),
  version: z.string().optional(),
});

export const zBodyUploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPost =
  z.object({
    upload_file: z.string(),
    unique_id: z.union([z.string(), z.null()]).optional(),
    display_name: z.union([z.string(), z.null()]).optional(),
    external_file_id: z.union([z.string(), z.null()]).optional(),
  });

export const zBoxAuthMechanism = z.enum(["developer_token", "ccg"]);

export const zFilterOperator = z.enum([
  "==",
  ">",
  "<",
  "!=",
  ">=",
  "<=",
  "in",
  "nin",
  "any",
  "all",
  "text_match",
  "text_match_insensitive",
  "contains",
  "is_empty",
]);

export const zMetadataFilter = z.object({
  key: z.string(),
  value: z.union([
    z.number().int(),
    z.number(),
    z.string(),
    z.array(z.string()),
    z.array(z.number()),
    z.array(z.number().int()),
    z.null(),
  ]),
  operator: zFilterOperator.optional(),
});

export const zFilterCondition: z.ZodTypeAny = z.enum(["and", "or", "not"]);

export const zMetadataFilters: z.AnyZodObject = z.object({
  filters: z.array(z.unknown()),
  condition: z.union([zFilterCondition, z.null()]).optional(),
});

export const zRetrievalMode: z.ZodTypeAny = z.enum([
  "chunks",
  "files_via_metadata",
  "files_via_content",
  "auto_routed",
]);

export const zPresetRetrievalParams: z.AnyZodObject = z.object({
  dense_similarity_top_k: z
    .union([z.number().int().gte(1).lte(100), z.null()])
    .optional(),
  dense_similarity_cutoff: z
    .union([z.number().gte(0).lte(1), z.null()])
    .optional(),
  sparse_similarity_top_k: z
    .union([z.number().int().gte(1).lte(100), z.null()])
    .optional(),
  enable_reranking: z.union([z.boolean(), z.null()]).optional(),
  rerank_top_n: z
    .union([z.number().int().gte(1).lte(100), z.null()])
    .optional(),
  alpha: z.union([z.number().gte(0).lte(1), z.null()]).optional(),
  search_filters: z.union([zMetadataFilters, z.null()]).optional(),
  search_filters_inference_schema: z.union([z.object({}), z.null()]).optional(),
  files_top_k: z.union([z.number().int().gte(1).lte(5), z.null()]).optional(),
  retrieval_mode: zRetrievalMode.optional(),
  retrieve_image_nodes: z.boolean().optional().default(false),
  retrieve_page_screenshot_nodes: z.boolean().optional().default(false),
  retrieve_page_figure_nodes: z.boolean().optional().default(false),
  class_name: z.string().optional().default("base_component"),
});

export const zSupportedLlmModelNames: z.ZodTypeAny = z.enum([
  "GPT_4O",
  "GPT_4O_MINI",
  "GPT_4_1",
  "GPT_4_1_NANO",
  "GPT_4_1_MINI",
  "AZURE_OPENAI_GPT_4O",
  "AZURE_OPENAI_GPT_4O_MINI",
  "AZURE_OPENAI_GPT_4_1",
  "AZURE_OPENAI_GPT_4_1_MINI",
  "AZURE_OPENAI_GPT_4_1_NANO",
  "CLAUDE_3_5_SONNET",
  "CLAUDE_4_5_SONNET",
  "BEDROCK_CLAUDE_3_5_SONNET_V1",
  "BEDROCK_CLAUDE_3_5_SONNET_V2",
  "VERTEX_AI_CLAUDE_3_5_SONNET_V2",
]);

export const zLlmParameters: z.AnyZodObject = z.object({
  model_name: zSupportedLlmModelNames.optional(),
  system_prompt: z.union([z.string().max(3000), z.null()]).optional(),
  temperature: z.union([z.number(), z.null()]).optional(),
  use_chain_of_thought_reasoning: z.union([z.boolean(), z.null()]).optional(),
  use_citation: z.union([z.boolean(), z.null()]).optional(),
  class_name: z.string().optional().default("base_component"),
});

export const zChatData: z.AnyZodObject = z.object({
  retrieval_parameters: zPresetRetrievalParams.optional(),
  llm_parameters: z.union([zLlmParameters, z.null()]).optional(),
  class_name: z.string().optional().default("base_component"),
});

export const zMessageRole = z.enum([
  "system",
  "developer",
  "user",
  "assistant",
  "function",
  "tool",
  "chatbot",
  "model",
]);

export const zInputMessage = z.object({
  id: z.string().uuid().optional(),
  role: zMessageRole,
  content: z.string(),
  data: z.union([z.object({}), z.null()]).optional(),
  class_name: z.string().optional().default("base_component"),
});

export const zChatInputParams = z.object({
  messages: z.array(zInputMessage).min(1).optional(),
  data: zChatData.optional(),
  class_name: z.string().optional().default("base_component"),
});

export const zMessageAnnotation = z.object({
  type: z.string(),
  data: z.string(),
  class_name: z.string().optional().default("base_component"),
});

export const zChatMessage = z.object({
  id: z.string().uuid(),
  index: z.number().int(),
  annotations: z.array(zMessageAnnotation).optional(),
  role: zMessageRole,
  content: z.union([z.string(), z.null()]).optional(),
  additional_kwargs: z.object({}).optional(),
  class_name: z.string().optional().default("base_component"),
});

export const zClassificationResult = z.object({
  reasoning: z.string(),
  confidence: z.number().gte(0).lte(1),
  type: z.union([z.string(), z.null()]),
});

export const zClassifyJobCreate = z.object({
  rules: z.array(zClassifierRule).min(1),
  file_ids: z.array(z.string().uuid()).min(1).max(500),
  parsing_configuration: zClassifyParsingConfiguration.optional(),
});

export const zFileClassification = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  classify_job_id: z.string().uuid(),
  file_id: z.string().uuid(),
  result: z.union([zClassificationResult, z.null()]).optional(),
});

export const zClassifyJobResults = z.object({
  items: z.array(zFileClassification),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zCloudAstraDbVectorStore = z.object({
  supports_nested_metadata_filters: z.literal(true).optional().default(true),
  token: z.string(),
  api_endpoint: z.string(),
  collection_name: z.string(),
  embedding_dimension: z.number().int(),
  keyspace: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudAstraDBVectorStore"),
});

export const zCloudAzStorageBlobDataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  container_name: z.string(),
  account_url: z.string(),
  blob: z.union([z.string(), z.null()]).optional(),
  prefix: z.union([z.string(), z.null()]).optional(),
  account_name: z.union([z.string(), z.null()]).optional(),
  account_key: z.union([z.string(), z.null()]).optional(),
  tenant_id: z.union([z.string(), z.null()]).optional(),
  client_id: z.union([z.string(), z.null()]).optional(),
  client_secret: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudAzStorageBlobDataSource"),
});

export const zCloudAzureAiSearchVectorStore = z.object({
  supports_nested_metadata_filters: z.literal(true).optional().default(true),
  search_service_api_key: z.string(),
  search_service_endpoint: z.string(),
  search_service_api_version: z.union([z.string(), z.null()]).optional(),
  index_name: z.union([z.string(), z.null()]).optional(),
  filterable_metadata_field_keys: z.union([z.object({}), z.null()]).optional(),
  embedding_dimension: z.union([z.number().int(), z.null()]).optional(),
  client_id: z.union([z.string(), z.null()]).optional(),
  client_secret: z.union([z.string(), z.null()]).optional(),
  tenant_id: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudAzureAISearchVectorStore"),
});

export const zCloudBoxDataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  folder_id: z.union([z.string(), z.null()]).optional(),
  authentication_mechanism: zBoxAuthMechanism,
  developer_token: z.union([z.string(), z.null()]).optional(),
  client_id: z.union([z.string(), z.null()]).optional(),
  client_secret: z.union([z.string(), z.null()]).optional(),
  user_id: z.union([z.string(), z.null()]).optional(),
  enterprise_id: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudBoxDataSource"),
});

export const zFailureHandlingConfig = z.object({
  skip_list_failures: z.boolean().optional().default(false),
});

export const zCloudConfluenceDataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  server_url: z.string(),
  authentication_mechanism: z.string(),
  user_name: z.union([z.string(), z.null()]).optional(),
  api_token: z.union([z.string(), z.null()]).optional(),
  space_key: z.union([z.string(), z.null()]).optional(),
  page_ids: z.union([z.string(), z.null()]).optional(),
  cql: z.union([z.string(), z.null()]).optional(),
  label: z.union([z.string(), z.null()]).optional(),
  index_restricted_pages: z.boolean().optional().default(false),
  keep_markdown_format: z.boolean().optional(),
  failure_handling: zFailureHandlingConfig.optional(),
  class_name: z.string().optional().default("CloudConfluenceDataSource"),
});

export const zCloudDocument = z.object({
  text: z.string(),
  metadata: z.object({}),
  excluded_embed_metadata_keys: z.array(z.string()).optional().default([]),
  excluded_llm_metadata_keys: z.array(z.string()).optional().default([]),
  page_positions: z.union([z.array(z.number().int()), z.null()]).optional(),
  id: z.string(),
  status_metadata: z.union([z.object({}), z.null()]).optional(),
});

export const zCloudDocumentCreate = z.object({
  text: z.string(),
  metadata: z.object({}),
  excluded_embed_metadata_keys: z.array(z.string()).optional().default([]),
  excluded_llm_metadata_keys: z.array(z.string()).optional().default([]),
  page_positions: z.union([z.array(z.number().int()), z.null()]).optional(),
  id: z.union([z.string(), z.null()]).optional(),
});

export const zCloudJiraDataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  email: z.union([z.string(), z.null()]).optional(),
  api_token: z.union([z.string(), z.null()]).optional(),
  server_url: z.union([z.string(), z.null()]).optional(),
  cloud_id: z.union([z.string(), z.null()]).optional(),
  authentication_mechanism: z.string(),
  query: z.string(),
  class_name: z.string().optional().default("CloudJiraDataSource"),
});

export const zCloudJiraDataSourceV2 = z.object({
  supports_access_control: z.boolean().optional().default(false),
  email: z.union([z.string(), z.null()]).optional(),
  api_token: z.union([z.string(), z.null()]).optional(),
  server_url: z.string(),
  cloud_id: z.union([z.string(), z.null()]).optional(),
  authentication_mechanism: z.string(),
  api_version: z.enum(["2", "3"]).optional(),
  query: z.string(),
  fields: z.union([z.array(z.string()), z.null()]).optional(),
  expand: z.union([z.string(), z.null()]).optional(),
  requests_per_minute: z.union([z.number().int(), z.null()]).optional(),
  get_permissions: z.boolean().optional().default(true),
  class_name: z.string().optional().default("CloudJiraDataSourceV2"),
});

export const zCloudMilvusVectorStore = z.object({
  supports_nested_metadata_filters: z.boolean().optional().default(false),
  uri: z.string(),
  collection_name: z.union([z.string(), z.null()]).optional(),
  token: z.union([z.string(), z.null()]).optional(),
  embedding_dimension: z.union([z.number().int(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudMilvusVectorStore"),
});

export const zCloudMongoDbAtlasVectorSearch = z.object({
  supports_nested_metadata_filters: z.boolean().optional().default(false),
  mongodb_uri: z.string(),
  db_name: z.string(),
  collection_name: z.string(),
  vector_index_name: z.union([z.string(), z.null()]).optional(),
  fulltext_index_name: z.union([z.string(), z.null()]).optional(),
  embedding_dimension: z.union([z.number().int(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudMongoDBAtlasVectorSearch"),
});

export const zCloudNotionPageDataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  integration_token: z.string(),
  database_ids: z.union([z.string(), z.null()]).optional(),
  page_ids: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudNotionPageDataSource"),
});

export const zCloudOneDriveDataSource = z.object({
  supports_access_control: z.literal(true).optional().default(true),
  user_principal_name: z.string(),
  folder_path: z.union([z.string(), z.null()]).optional(),
  folder_id: z.union([z.string(), z.null()]).optional(),
  client_id: z.string(),
  client_secret: z.string(),
  tenant_id: z.string(),
  required_exts: z.union([z.array(z.string()), z.null()]).optional(),
  class_name: z.string().optional().default("CloudOneDriveDataSource"),
});

export const zCloudPineconeVectorStore = z.object({
  supports_nested_metadata_filters: z.literal(true).optional().default(true),
  api_key: z.string(),
  index_name: z.string(),
  namespace: z.union([z.string(), z.null()]).optional(),
  insert_kwargs: z.union([z.object({}), z.null()]).optional(),
  class_name: z.string().optional().default("CloudPineconeVectorStore"),
});

export const zPgVectorVectorType = z.enum([
  "vector",
  "half_vec",
  "bit",
  "sparse_vec",
]);

export const zPgVectorDistanceMethod = z.enum([
  "l2",
  "ip",
  "cosine",
  "l1",
  "hamming",
  "jaccard",
]);

export const zPgVectorHnswSettings = z.object({
  ef_construction: z.number().int().gte(1).optional().default(64),
  ef_search: z.number().int().gte(1).optional().default(40),
  m: z.number().int().gte(1).optional().default(16),
  vector_type: zPgVectorVectorType.optional(),
  distance_method: zPgVectorDistanceMethod.optional(),
});

export const zCloudPostgresVectorStore = z.object({
  supports_nested_metadata_filters: z.boolean().optional().default(true),
  database: z.string(),
  host: z.string(),
  password: z.string(),
  port: z.number().int(),
  user: z.string(),
  table_name: z.string(),
  schema_name: z.string(),
  embed_dim: z.number().int(),
  hybrid_search: z.union([z.boolean(), z.null()]).optional(),
  perform_setup: z.boolean().optional().default(true),
  hnsw_settings: z.union([zPgVectorHnswSettings, z.null()]).optional(),
  class_name: z.string().optional().default("CloudPostgresVectorStore"),
});

export const zCloudQdrantVectorStore = z.object({
  supports_nested_metadata_filters: z.literal(true).optional().default(true),
  collection_name: z.string(),
  url: z.string(),
  api_key: z.string(),
  max_retries: z.number().int().optional().default(3),
  client_kwargs: z.object({}).optional(),
  class_name: z.string().optional().default("CloudQdrantVectorStore"),
});

export const zCloudS3DataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  bucket: z.string(),
  prefix: z.union([z.string(), z.null()]).optional(),
  regex_pattern: z.union([z.string(), z.null()]).optional(),
  aws_access_id: z.union([z.string(), z.null()]).optional(),
  aws_access_secret: z.union([z.string(), z.null()]).optional(),
  s3_endpoint_url: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudS3DataSource"),
});

export const zCloudSharepointDataSource = z.object({
  supports_access_control: z.literal(true).optional().default(true),
  site_name: z.union([z.string(), z.null()]).optional(),
  site_id: z.union([z.string(), z.null()]).optional(),
  folder_path: z.union([z.string(), z.null()]).optional(),
  folder_id: z.union([z.string(), z.null()]).optional(),
  drive_name: z.union([z.string(), z.null()]).optional(),
  client_id: z.string(),
  client_secret: z.string(),
  tenant_id: z.string(),
  required_exts: z.union([z.array(z.string()), z.null()]).optional(),
  get_permissions: z.union([z.boolean(), z.null()]).optional(),
  include_path_patterns: z.union([z.array(z.string()), z.null()]).optional(),
  exclude_path_patterns: z.union([z.array(z.string()), z.null()]).optional(),
  class_name: z.string().optional().default("CloudSharepointDataSource"),
});

export const zCloudSlackDataSource = z.object({
  supports_access_control: z.boolean().optional().default(false),
  slack_token: z.string(),
  channel_ids: z.union([z.string(), z.null()]).optional(),
  latest_date: z.union([z.string(), z.null()]).optional(),
  earliest_date: z.union([z.string(), z.null()]).optional(),
  earliest_date_timestamp: z.union([z.number(), z.null()]).optional(),
  latest_date_timestamp: z.union([z.number(), z.null()]).optional(),
  channel_patterns: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("CloudSlackDataSource"),
});

export const zCodeItem = z.object({
  type: z.literal("code").optional().default("code"),
  bBox: z.union([z.unknown(), z.null()]).optional(),
  value: z.string(),
  language: z.union([z.string(), z.null()]).optional(),
});

export const zCohereEmbedding = z.object({
  model_name: z.string().optional().default("embed-english-v3.0"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  api_key: z.union([z.string(), z.null()]),
  truncate: z.string().optional().default("END"),
  input_type: z.union([z.string(), z.null()]).optional(),
  embedding_type: z.string().optional().default("float"),
  class_name: z.string().optional().default("CohereEmbedding"),
});

export const zCohereEmbeddingConfig = z.object({
  type: z.literal("COHERE_EMBEDDING").optional().default("COHERE_EMBEDDING"),
  component: zCohereEmbedding.optional(),
});

export const zCompositeRetrievalMode = z.enum(["routing", "full"]);

export const zReRankerType = z.enum([
  "system_default",
  "llm",
  "cohere",
  "bedrock",
  "score",
  "disabled",
]);

export const zReRankConfig = z.object({
  top_n: z.number().int().optional().default(6),
  type: zReRankerType.optional(),
});

export const zCompositeRetrievalParams = z.object({
  mode: zCompositeRetrievalMode.optional(),
  rerank_top_n: z.union([z.number().int(), z.null()]).optional(),
  rerank_config: zReRankConfig.optional(),
  query: z.string().min(1),
});

export const zCompositeRetrievedTextNode = z.object({
  id: z.string().uuid(),
  retriever_id: z.string().uuid(),
  retriever_pipeline_name: z.string(),
  pipeline_id: z.string().uuid(),
  metadata: z.object({}).optional(),
  text: z.string(),
  start_char_idx: z.union([z.number().int(), z.null()]),
  end_char_idx: z.union([z.number().int(), z.null()]),
});

export const zCompositeRetrievedTextNodeWithScore = z.object({
  node: zCompositeRetrievedTextNode,
  score: z.union([z.number(), z.null()]).optional(),
  class_name: z
    .string()
    .optional()
    .default("CompositeRetrievedTextNodeWithScore"),
});

export const zPageScreenshotMetadata = z.object({
  page_index: z.number().int().gte(0),
  file_id: z.string().uuid(),
  image_size: z.number().int().gte(0),
  metadata: z.union([z.object({}), z.null()]).optional(),
});

export const zPageScreenshotNodeWithScore = z.object({
  node: zPageScreenshotMetadata,
  score: z.number(),
  class_name: z.string().optional().default("NodeWithScore"),
});

export const zPageFigureMetadata = z.object({
  figure_name: z.string(),
  file_id: z.string().uuid(),
  page_index: z.number().int().gte(0),
  figure_size: z.number().int().gte(0),
  is_likely_noise: z.boolean().optional().default(false),
  confidence: z.number().gte(0).lte(1),
  metadata: z.union([z.object({}), z.null()]).optional(),
});

export const zPageFigureNodeWithScore = z.object({
  node: zPageFigureMetadata,
  score: z.number(),
  class_name: z.string().optional().default("PageFigureNodeWithScore"),
});

export const zCompositeRetrievalResult = z.object({
  nodes: z.array(zCompositeRetrievedTextNodeWithScore).optional(),
  image_nodes: z.array(zPageScreenshotNodeWithScore).optional(),
  page_figure_nodes: z.array(zPageFigureNodeWithScore).optional(),
});

export const zConfigurableDataSinkNames = z.enum([
  "PINECONE",
  "POSTGRES",
  "QDRANT",
  "AZUREAI_SEARCH",
  "MONGODB_ATLAS",
  "MILVUS",
  "ASTRA_DB",
]);

export const zConfigurableDataSourceNames = z.enum([
  "S3",
  "AZURE_STORAGE_BLOB",
  "GOOGLE_DRIVE",
  "MICROSOFT_ONEDRIVE",
  "MICROSOFT_SHAREPOINT",
  "SLACK",
  "NOTION_PAGE",
  "CONFLUENCE",
  "JIRA",
  "JIRA_V2",
  "BOX",
]);

export const zDataSink = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string(),
  sink_type: zConfigurableDataSinkNames,
  component: z.union([
    z.object({}),
    zCloudPineconeVectorStore,
    zCloudPostgresVectorStore,
    zCloudQdrantVectorStore,
    zCloudAzureAiSearchVectorStore,
    zCloudMongoDbAtlasVectorSearch,
    zCloudMilvusVectorStore,
    zCloudAstraDbVectorStore,
  ]),
  project_id: z.string().uuid(),
});

export const zDataSinkCreate = z.object({
  name: z.string(),
  sink_type: zConfigurableDataSinkNames,
  component: z.union([
    z.object({}),
    zCloudPineconeVectorStore,
    zCloudPostgresVectorStore,
    zCloudQdrantVectorStore,
    zCloudAzureAiSearchVectorStore,
    zCloudMongoDbAtlasVectorSearch,
    zCloudMilvusVectorStore,
    zCloudAstraDbVectorStore,
  ]),
});

export const zDataSinkUpdate = z.object({
  name: z.union([z.string(), z.null()]).optional(),
  sink_type: zConfigurableDataSinkNames,
  component: z
    .union([
      z.object({}),
      zCloudPineconeVectorStore,
      zCloudPostgresVectorStore,
      zCloudQdrantVectorStore,
      zCloudAzureAiSearchVectorStore,
      zCloudMongoDbAtlasVectorSearch,
      zCloudMilvusVectorStore,
      zCloudAstraDbVectorStore,
      z.null(),
    ])
    .optional(),
});

export const zDataSourceReaderVersionMetadata = z.object({
  reader_version: z.union([z.enum(["1.0", "2.0", "2.1"]), z.null()]).optional(),
});

export const zDataSource = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string(),
  source_type: zConfigurableDataSourceNames,
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
  component: z.union([
    z.object({}),
    zCloudS3DataSource,
    zCloudAzStorageBlobDataSource,
    zCloudOneDriveDataSource,
    zCloudSharepointDataSource,
    zCloudSlackDataSource,
    zCloudNotionPageDataSource,
    zCloudConfluenceDataSource,
    zCloudJiraDataSource,
    zCloudJiraDataSourceV2,
    zCloudBoxDataSource,
  ]),
  version_metadata: z
    .union([zDataSourceReaderVersionMetadata, z.null()])
    .optional(),
  project_id: z.string().uuid(),
});

export const zDataSourceCreate = z.object({
  name: z.string(),
  source_type: zConfigurableDataSourceNames,
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
  component: z.union([
    z.object({}),
    zCloudS3DataSource,
    zCloudAzStorageBlobDataSource,
    zCloudOneDriveDataSource,
    zCloudSharepointDataSource,
    zCloudSlackDataSource,
    zCloudNotionPageDataSource,
    zCloudConfluenceDataSource,
    zCloudJiraDataSource,
    zCloudJiraDataSourceV2,
    zCloudBoxDataSource,
  ]),
});

export const zDataSourceSyncRequest = z.object({
  pipeline_file_ids: z.union([z.array(z.string().uuid()), z.null()]).optional(),
});

export const zDataSourceUpdate = z.object({
  name: z.union([z.string(), z.null()]).optional(),
  source_type: zConfigurableDataSourceNames,
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
  component: z
    .union([
      z.object({}),
      zCloudS3DataSource,
      zCloudAzStorageBlobDataSource,
      zCloudOneDriveDataSource,
      zCloudSharepointDataSource,
      zCloudSlackDataSource,
      zCloudNotionPageDataSource,
      zCloudConfluenceDataSource,
      zCloudJiraDataSource,
      zCloudJiraDataSourceV2,
      zCloudBoxDataSource,
      z.null(),
    ])
    .optional(),
});

export const zDeleteRequest = z.object({
  deployment_name: z.string(),
  collection: z.string().optional().default("default"),
  filter: z.union([z.object({}), z.null()]).optional(),
});

export const zDeleteResponse = z.object({
  deleted_count: z.number().int(),
});

export const zDiffingStatusDetails = z.object({
  status: z.enum(["pending", "processing", "completed", "failed"]).optional(),
  effective_at: z.string().datetime().optional(),
  job_record_id: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
});

export const zRetrieverPipeline = z.object({
  name: z.union([z.string().min(1).max(3000), z.null()]),
  description: z.union([z.string().max(15000), z.null()]),
  pipeline_id: z.string().uuid(),
  preset_retrieval_parameters: zPresetRetrievalParams.optional(),
});

export const zDirectRetrievalParams = z.object({
  mode: zCompositeRetrievalMode.optional(),
  rerank_top_n: z.union([z.number().int(), z.null()]).optional(),
  rerank_config: zReRankConfig.optional(),
  query: z.string().min(1),
  pipelines: z.array(zRetrieverPipeline).optional(),
});

export const zDirectoryCreateRequest = z.object({
  name: z.string().min(1),
  description: z.union([z.string(), z.null()]).optional(),
  data_source_id: z.union([z.string(), z.null()]).optional(),
});

export const zDirectoryFileCreateRequest = z.object({
  file_id: z.string(),
  unique_id: z.union([z.string(), z.null()]).optional(),
  display_name: z.union([z.string(), z.null()]).optional(),
});

export const zDirectoryFileResponse = z.object({
  id: z.string(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string(),
  directory_id: z.string(),
  unique_id: z.string().min(1),
  display_name: z.string().min(1),
  data_source_id: z.union([z.string(), z.null()]).optional(),
  file_id: z.union([z.string(), z.null()]).optional(),
  deleted_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zDirectoryFileQueryResponse = z.object({
  items: z.array(zDirectoryFileResponse),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zDirectoryFileUpdateRequest = z.object({
  unique_id: z.union([z.string().min(1), z.null()]).optional(),
  display_name: z.union([z.string(), z.null()]).optional(),
});

export const zDirectoryResponse = z.object({
  id: z.string(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string(),
  name: z.string().min(1),
  description: z.union([z.string(), z.null()]).optional(),
  data_source_id: z.union([z.string(), z.null()]).optional(),
  deleted_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zDirectoryQueryResponse = z.object({
  items: z.array(zDirectoryResponse),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zDirectorySyncJobCreateRequest = z.object({
  directory_id: z.string(),
});

export const zListingStatusDetails = z.object({
  status: z.enum(["pending", "processing", "completed", "failed"]).optional(),
  effective_at: z.string().datetime().optional(),
  job_record_id: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
});

export const zDirectorySyncJobResponse = z.object({
  id: z.string(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string(),
  directory_id: z.string(),
  listing_status_details: zListingStatusDetails,
  diffing_status_details: zDiffingStatusDetails,
  apply_status_details: zApplyStatusDetails,
  started_at: z.union([z.string().datetime(), z.null()]).optional(),
  completed_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zDirectoryUpdateRequest = z.object({
  name: z.union([z.string().min(1), z.null()]).optional(),
  description: z.union([z.string(), z.null()]).optional(),
});

export const zDocumentChunkMode = z.enum(["PAGE", "SECTION"]);

export const zGeminiEmbedding = z.object({
  model_name: z.string().optional().default("models/embedding-001"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  title: z.union([z.string(), z.null()]).optional(),
  task_type: z.union([z.string(), z.null()]).optional(),
  api_key: z.union([z.string(), z.null()]).optional(),
  api_base: z.union([z.string(), z.null()]).optional(),
  transport: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("GeminiEmbedding"),
});

export const zGeminiEmbeddingConfig = z.object({
  type: z.literal("GEMINI_EMBEDDING").optional().default("GEMINI_EMBEDDING"),
  component: zGeminiEmbedding.optional(),
});

export const zPooling = z.enum(["cls", "mean", "last"]);

export const zHuggingFaceInferenceApiEmbedding = z.object({
  model_name: z.union([z.string(), z.null()]).optional(),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  pooling: z.union([zPooling, z.null()]).optional(),
  query_instruction: z.union([z.string(), z.null()]).optional(),
  text_instruction: z.union([z.string(), z.null()]).optional(),
  token: z.union([z.string(), z.boolean(), z.null()]).optional(),
  timeout: z.union([z.number(), z.null()]).optional(),
  headers: z.union([z.object({}), z.null()]).optional(),
  cookies: z.union([z.object({}), z.null()]).optional(),
  task: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("HuggingFaceInferenceAPIEmbedding"),
});

export const zHuggingFaceInferenceApiEmbeddingConfig = z.object({
  type: z
    .literal("HUGGINGFACE_API_EMBEDDING")
    .optional()
    .default("HUGGINGFACE_API_EMBEDDING"),
  component: zHuggingFaceInferenceApiEmbedding.optional(),
});

export const zOpenAiEmbedding = z.object({
  model_name: z.string().optional().default("text-embedding-ada-002"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  additional_kwargs: z.object({}).optional(),
  api_key: z.union([z.string(), z.null()]).optional(),
  api_base: z.union([z.string(), z.null()]).optional(),
  api_version: z.union([z.string(), z.null()]).optional(),
  max_retries: z.number().int().optional().default(10),
  timeout: z.number().optional().default(60),
  default_headers: z.union([z.object({}), z.null()]).optional(),
  reuse_client: z.boolean().optional().default(true),
  dimensions: z.union([z.number().int(), z.null()]).optional(),
  class_name: z.string().optional().default("OpenAIEmbedding"),
});

export const zOpenAiEmbeddingConfig = z.object({
  type: z.literal("OPENAI_EMBEDDING").optional().default("OPENAI_EMBEDDING"),
  component: zOpenAiEmbedding.optional(),
});

export const zVertexEmbeddingMode = z.enum([
  "default",
  "classification",
  "clustering",
  "similarity",
  "retrieval",
]);

export const zVertexTextEmbedding = z.object({
  model_name: z.string().optional().default("textembedding-gecko@003"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  location: z.string(),
  project: z.string(),
  embed_mode: zVertexEmbeddingMode.optional(),
  additional_kwargs: z.object({}).optional(),
  client_email: z.union([z.string(), z.null()]),
  token_uri: z.union([z.string(), z.null()]),
  private_key_id: z.union([z.string(), z.null()]),
  private_key: z.union([z.string(), z.null()]),
  class_name: z.string().optional().default("VertexTextEmbedding"),
});

export const zVertexAiEmbeddingConfig = z.object({
  type: z
    .literal("VERTEXAI_EMBEDDING")
    .optional()
    .default("VERTEXAI_EMBEDDING"),
  component: zVertexTextEmbedding.optional(),
});

export const zEmbeddingModelConfig = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string(),
  embedding_config: z.union([
    z
      .object({
        type: z.literal("AZURE_EMBEDDING"),
      })
      .and(zAzureOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("COHERE_EMBEDDING"),
      })
      .and(zCohereEmbeddingConfig),
    z
      .object({
        type: z.literal("GEMINI_EMBEDDING"),
      })
      .and(zGeminiEmbeddingConfig),
    z
      .object({
        type: z.literal("HUGGINGFACE_API_EMBEDDING"),
      })
      .and(zHuggingFaceInferenceApiEmbeddingConfig),
    z
      .object({
        type: z.literal("OPENAI_EMBEDDING"),
      })
      .and(zOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("VERTEXAI_EMBEDDING"),
      })
      .and(zVertexAiEmbeddingConfig),
    z
      .object({
        type: z.literal("BEDROCK_EMBEDDING"),
      })
      .and(zBedrockEmbeddingConfig),
  ]),
  project_id: z.string().uuid(),
});

export const zEmbeddingModelConfigCreate = z.object({
  name: z.string(),
  embedding_config: z.union([
    z
      .object({
        type: z.literal("AZURE_EMBEDDING"),
      })
      .and(zAzureOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("COHERE_EMBEDDING"),
      })
      .and(zCohereEmbeddingConfig),
    z
      .object({
        type: z.literal("GEMINI_EMBEDDING"),
      })
      .and(zGeminiEmbeddingConfig),
    z
      .object({
        type: z.literal("HUGGINGFACE_API_EMBEDDING"),
      })
      .and(zHuggingFaceInferenceApiEmbeddingConfig),
    z
      .object({
        type: z.literal("OPENAI_EMBEDDING"),
      })
      .and(zOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("VERTEXAI_EMBEDDING"),
      })
      .and(zVertexAiEmbeddingConfig),
    z
      .object({
        type: z.literal("BEDROCK_EMBEDDING"),
      })
      .and(zBedrockEmbeddingConfig),
  ]),
});

export const zEmbeddingModelConfigUpdate = z.object({
  name: z.union([z.string(), z.null()]).optional(),
  embedding_config: z
    .union([
      z.union([
        z
          .object({
            type: z.literal("AZURE_EMBEDDING"),
          })
          .and(zAzureOpenAiEmbeddingConfig),
        z
          .object({
            type: z.literal("COHERE_EMBEDDING"),
          })
          .and(zCohereEmbeddingConfig),
        z
          .object({
            type: z.literal("GEMINI_EMBEDDING"),
          })
          .and(zGeminiEmbeddingConfig),
        z
          .object({
            type: z.literal("HUGGINGFACE_API_EMBEDDING"),
          })
          .and(zHuggingFaceInferenceApiEmbeddingConfig),
        z
          .object({
            type: z.literal("OPENAI_EMBEDDING"),
          })
          .and(zOpenAiEmbeddingConfig),
        z
          .object({
            type: z.literal("VERTEXAI_EMBEDDING"),
          })
          .and(zVertexAiEmbeddingConfig),
        z
          .object({
            type: z.literal("BEDROCK_EMBEDDING"),
          })
          .and(zBedrockEmbeddingConfig),
      ]),
      z.null(),
    ])
    .optional(),
});

export const zExtractTarget = z.enum(["PER_DOC", "PER_PAGE", "PER_TABLE_ROW"]);

export const zExtractMode = z.enum([
  "FAST",
  "BALANCED",
  "PREMIUM",
  "MULTIMODAL",
]);

export const zPublicModelName = z.enum([
  "openai-gpt-4o",
  "openai-gpt-4o-mini",
  "openai-gpt-4-1",
  "openai-gpt-4-1-mini",
  "openai-gpt-4-1-nano",
  "openai-gpt-5",
  "openai-gpt-5-mini",
  "openai-gpt-5-nano",
  "openai-text-embedding-3-large",
  "openai-text-embedding-3-small",
  "openai-whisper-1",
  "anthropic-sonnet-3.5",
  "anthropic-sonnet-3.5-v2",
  "anthropic-sonnet-3.7",
  "anthropic-sonnet-4.0",
  "anthropic-sonnet-4.5",
  "anthropic-haiku-3.5",
  "anthropic-haiku-4.5",
  "gemini-2.5-flash",
  "gemini-3.0-pro",
  "gemini-2.5-pro",
  "gemini-2.0-flash",
  "gemini-2.0-flash-lite",
  "gemini-2.5-flash-lite",
  "gemini-1.5-flash",
  "gemini-1.5-pro",
]);

export const zExtractModels = z.enum([
  "openai-gpt-4-1",
  "openai-gpt-4-1-mini",
  "openai-gpt-4-1-nano",
  "openai-gpt-5",
  "openai-gpt-5-mini",
  "gemini-2.0-flash",
  "gemini-2.5-flash",
  "gemini-2.5-flash-lite",
  "gemini-2.5-pro",
  "openai-gpt-4o",
  "openai-gpt-4o-mini",
]);

export const zExtractConfig = z.object({
  priority: z
    .union([z.enum(["low", "medium", "high", "critical"]), z.null()])
    .optional(),
  extraction_target: zExtractTarget.optional(),
  extraction_mode: zExtractMode.optional(),
  parse_model: z.union([zPublicModelName, z.null()]).optional(),
  extract_model: z.union([zExtractModels, z.null()]).optional(),
  multimodal_fast_mode: z.boolean().optional().default(false),
  system_prompt: z.union([z.string(), z.null()]).optional(),
  use_reasoning: z.boolean().optional().default(false),
  cite_sources: z.boolean().optional().default(false),
  citation_bbox: z.boolean().optional().default(false),
  confidence_scores: z.boolean().optional().default(false),
  chunk_mode: zDocumentChunkMode.optional(),
  high_resolution_mode: z.boolean().optional().default(false),
  invalidate_cache: z.boolean().optional().default(false),
  num_pages_context: z.union([z.number().int().gte(1), z.null()]).optional(),
  page_range: z.union([z.string(), z.null()]).optional(),
});

export const zExtractAgent = z.object({
  id: z.string().uuid(),
  name: z.string(),
  project_id: z.string().uuid(),
  data_schema: z.object({}),
  config: zExtractConfig,
  custom_configuration: z.union([z.literal("default"), z.null()]).optional(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zExtractAgentCreate = z.object({
  name: z.string().min(1).max(3000),
  data_schema: z.union([z.object({}), z.string()]),
  config: zExtractConfig,
});

export const zExtractAgentUpdate = z.object({
  data_schema: z.union([z.object({}), z.string()]),
  config: zExtractConfig,
});

export const zFile = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string().min(1).max(3000),
  external_file_id: z.union([z.string(), z.null()]).optional(),
  file_size: z.union([z.number().int().gte(0), z.null()]).optional(),
  file_type: z.union([z.string().min(1).max(3000), z.null()]).optional(),
  project_id: z.string().uuid(),
  last_modified_at: z.union([z.string().datetime(), z.null()]).optional(),
  resource_info: z.union([z.object({}), z.null()]).optional(),
  permission_info: z.union([z.object({}), z.null()]).optional(),
  data_source_id: z.union([z.string().uuid(), z.null()]).optional(),
});

export const zExtractJob = z.object({
  id: z.string().uuid(),
  extraction_agent: zExtractAgent,
  status: zStatusEnum,
  error: z.union([z.string(), z.null()]).optional(),
  file_id: z.union([z.string().uuid(), z.null()]).optional(),
  file: z.union([zFile, z.null()]).optional(),
});

export const zWebhookConfiguration = z.object({
  webhook_url: z.union([z.string(), z.null()]).optional(),
  webhook_headers: z.union([z.object({}), z.null()]).optional(),
  webhook_events: z
    .union([
      z.array(
        z.enum([
          "extract.pending",
          "extract.success",
          "extract.error",
          "extract.partial_success",
          "extract.cancelled",
          "parse.pending",
          "parse.success",
          "parse.error",
          "parse.partial_success",
          "parse.cancelled",
          "unmapped_event",
        ]),
      ),
      z.null(),
    ])
    .optional(),
  webhook_output_format: z.union([z.string(), z.null()]).optional(),
});

export const zExtractJobCreate = z.object({
  priority: z
    .union([z.enum(["low", "medium", "high", "critical"]), z.null()])
    .optional(),
  webhook_configurations: z
    .union([z.array(zWebhookConfiguration), z.null()])
    .optional(),
  extraction_agent_id: z.string().uuid(),
  file_id: z.string().uuid(),
  data_schema_override: z
    .union([z.object({}), z.string(), z.null()])
    .optional(),
  config_override: z.union([zExtractConfig, z.null()]).optional(),
});

export const zExtractJobCreateBatch = z.object({
  webhook_configurations: z
    .union([z.array(zWebhookConfiguration), z.null()])
    .optional(),
  extraction_agent_id: z.string().uuid(),
  file_ids: z.array(z.string().uuid()).min(1),
  data_schema_override: z
    .union([z.object({}), z.string(), z.null()])
    .optional(),
  config_override: z.union([zExtractConfig, z.null()]).optional(),
});

export const zExtractResultset = z.object({
  run_id: z.string().uuid(),
  extraction_agent_id: z.string().uuid(),
  data: z.union([z.object({}), z.array(z.object({})), z.null()]),
  extraction_metadata: z.object({}),
});

export const zExtractState = z.enum(["CREATED", "PENDING", "SUCCESS", "ERROR"]);

export const zExtractRun = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string().uuid(),
  extraction_agent_id: z.string().uuid(),
  data_schema: z.object({}),
  config: zExtractConfig,
  file_id: z.union([z.string().uuid(), z.null()]).optional(),
  file: z.union([zFile, z.null()]).optional(),
  status: zExtractState,
  error: z.union([z.string(), z.null()]).optional(),
  job_id: z.union([z.string().uuid(), z.null()]).optional(),
  data: z.union([z.object({}), z.array(z.object({})), z.null()]).optional(),
  extraction_metadata: z.union([z.object({}), z.null()]).optional(),
  from_ui: z.boolean(),
});

export const zExtractSchemaGenerateRequest = z.object({
  prompt: z.union([z.string(), z.null()]).optional(),
  file_id: z.union([z.string().uuid(), z.null()]).optional(),
  data_schema: z.union([z.object({}), z.string(), z.null()]).optional(),
});

export const zExtractSchemaGenerateResponse = z.object({
  data_schema: z.object({}),
});

export const zExtractSchemaValidateRequest = z.object({
  data_schema: z.union([z.object({}), z.string()]),
});

export const zExtractSchemaValidateResponse = z.object({
  data_schema: z.object({}),
});

export const zFileData = z.object({
  data: z.string(),
  mime_type: z.string(),
});

export const zExtractStatelessRequest = z.object({
  webhook_configurations: z
    .union([z.array(zWebhookConfiguration), z.null()])
    .optional(),
  data_schema: z.union([z.object({}), z.string()]),
  config: zExtractConfig,
  file_id: z.union([z.string().uuid(), z.null()]).optional(),
  text: z.union([z.string(), z.null()]).optional(),
  file: z.union([zFileData, z.null()]).optional(),
});

export const zExtractedRegionSummary = z.object({
  region_id: z.string().optional(),
  sheet_name: z.string(),
  location: z.string(),
  region_type: z.string(),
  title: z.union([z.string(), z.null()]).optional(),
  description: z.union([z.string(), z.null()]).optional(),
});

export const zFailedMarkdownPage = z.object({
  page_number: z.number().int(),
  error: z.string(),
  success: z.literal(false).optional().default(false),
});

export const zFailedStructuredPage = z.object({
  page_number: z.number().int(),
  error: z.string(),
  success: z.literal(false).optional().default(false),
});

export const zFileCountByStatusResponse = z.object({
  counts: z.object({}),
  total_count: z.number().int(),
  pipeline_id: z.union([z.string().uuid(), z.null()]).optional(),
  data_source_id: z.union([z.string().uuid(), z.null()]).optional(),
  only_manually_uploaded: z.boolean().optional().default(false),
});

export const zFileCreate = z.object({
  name: z.string().min(1).max(3000),
  external_file_id: z.union([z.string(), z.null()]).optional(),
  file_size: z.union([z.number().int().gte(0), z.null()]).optional(),
  last_modified_at: z.union([z.string().datetime(), z.null()]).optional(),
  resource_info: z.union([z.object({}), z.null()]).optional(),
  permission_info: z.union([z.object({}), z.null()]).optional(),
  data_source_id: z.union([z.string().uuid(), z.null()]).optional(),
});

export const zFileCreateFromUrl = z.object({
  name: z.union([z.string().min(1).max(3000), z.null()]).optional(),
  url: z.string().url().min(1),
  proxy_url: z.union([z.string().url().min(1), z.null()]).optional(),
  request_headers: z.union([z.object({}), z.null()]).optional(),
  verify_ssl: z.boolean().optional().default(true),
  follow_redirects: z.boolean().optional().default(true),
  resource_info: z.union([z.object({}), z.null()]).optional(),
});

export const zFileFilter = z.object({
  project_id: z.union([z.string().uuid(), z.null()]).optional(),
  file_ids: z.union([z.array(z.string().uuid()), z.null()]).optional(),
  file_name: z.union([z.string(), z.null()]).optional(),
  data_source_id: z.union([z.string().uuid(), z.null()]).optional(),
  external_file_id: z.union([z.string(), z.null()]).optional(),
  only_manually_uploaded: z.union([z.boolean(), z.null()]).optional(),
});

export const zFileIdPresignedUrl = z.object({
  url: z.string().url().min(1),
  expires_at: z.string().datetime(),
  form_fields: z.union([z.object({}), z.null()]).optional(),
  file_id: z.string().uuid(),
});

export const zFileQueryRequest = z.object({
  page_size: z.union([z.number().int(), z.null()]).optional(),
  page_token: z.union([z.string(), z.null()]).optional(),
  filter: z.union([zFileFilter, z.null()]).optional(),
  order_by: z.union([z.string(), z.null()]).optional(),
});

export const zFileQueryResponse = z.object({
  items: z.array(zFile),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zFilterOperation = z.object({
  eq: z.union([z.number(), z.number().int(), z.string(), z.null()]).optional(),
  gt: z.union([z.number(), z.number().int(), z.string(), z.null()]).optional(),
  gte: z.union([z.number(), z.number().int(), z.string(), z.null()]).optional(),
  lt: z.union([z.number(), z.number().int(), z.string(), z.null()]).optional(),
  lte: z.union([z.number(), z.number().int(), z.string(), z.null()]).optional(),
  includes: z.array(z.unknown()).optional(),
});

export const zValidationError = z.object({
  loc: z.array(z.unknown()),
  msg: z.string(),
  type: z.string(),
});

export const zHttpValidationError = z.object({
  detail: z.array(zValidationError).optional(),
});

export const zHeadingItem = z.object({
  type: z.literal("heading").optional().default("heading"),
  bBox: z.union([z.unknown(), z.null()]).optional(),
  level: z.number().int(),
  value: z.string(),
});

export const zImageItem = z.object({
  type: z.literal("image").optional().default("image"),
  bBox: z.union([z.unknown(), z.null()]).optional(),
  name: z.string(),
});

export const zJobNameMapping = z.enum([
  "MANAGED_INGESTION",
  "DATA_SOURCE",
  "FILE_UPDATER",
  "PARSE",
  "TRANSFORM",
  "INGESTION",
  "METADATA_UPDATE",
]);

export const zIngestionErrorResponse = z.object({
  job_id: z.string().uuid(),
  message: z.string(),
  step: zJobNameMapping,
});

export const zProcessingResultMetadata = z.object({});

export const zProcessingResult = z.object({
  result_id: z.string(),
  item_id: z.string(),
  job_type: zBatchJobType,
  job_config: z.union([zBatchParseJobRecordCreate, zClassifyJob]),
  parameters_hash: z.string(),
  output_s3_path: z.string(),
  output_metadata: z.union([zProcessingResultMetadata, z.null()]).optional(),
  processed_at: z.string().datetime(),
});

export const zItemProcessingResultsResponse = z.object({
  item_id: z.string(),
  item_name: z.string(),
  processing_results: z.array(zProcessingResult).optional(),
});

export const zTextItem = z.object({
  type: z.literal("text").optional().default("text"),
  bBox: z.union([z.unknown(), z.null()]).optional(),
  value: z.string(),
});

export const zListItem: z.AnyZodObject = z.object({
  type: z.literal("list").optional().default("list"),
  bBox: z.union([z.unknown(), z.null()]).optional(),
  items: z.array(z.unknown()),
  ordered: z.boolean(),
});

export const zLlamaParseIgnoreOptions = z.object({
  ignore_diagonal_text: z.union([z.boolean(), z.null()]).optional(),
  ignore_strikethrough_text: z.union([z.boolean(), z.null()]).optional(),
  ignore_text_in_image: z.union([z.boolean(), z.null()]).optional(),
  ignore_hidden_text: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseOcrParameters = z.object({
  languages: z.union([z.array(zParserLanguages), z.null()]).optional(),
});

export const zLlamaParseAgenticOptions = z.object({
  ignore: zLlamaParseIgnoreOptions.optional(),
  ocr_parameters: zLlamaParseOcrParameters.optional(),
  aggressive_table_extraction: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseCropBox = z.object({
  bottom: z.union([z.number().gte(0).lte(1), z.null()]).optional(),
  left: z.union([z.number().gte(0).lte(1), z.null()]).optional(),
  right: z.union([z.number().gte(0).lte(1), z.null()]).optional(),
  top: z.union([z.number().gte(0).lte(1), z.null()]).optional(),
});

export const zLlamaParseEmbeddedImagesOptions = z.object({
  enable: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseExportPdfOptions = z.object({
  enable: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseFastOptions = z.object({
  ignore: zLlamaParseIgnoreOptions.optional(),
  ocr_parameters: zLlamaParseOcrParameters.optional(),
  aggressive_table_extraction: z.union([z.boolean(), z.null()]).optional(),
});

export const zTierName = z.enum([
  "fast",
  "cost_effective",
  "agentic",
  "agentic_plus",
]);

export const zLlamaParseTierOptions = z.object({
  tier: zTierName,
  version: z.enum(["2025-11-18", "latest"]).optional(),
  fast_options: z.union([zLlamaParseFastOptions, z.null()]).optional(),
  agentic_options: z.union([zLlamaParseAgenticOptions, z.null()]).optional(),
});

export const zLlamaParseWebhookConfiguration = z.object({
  webhook_url: z.union([z.string().regex(/^https?:/), z.null()]).optional(),
  webhook_headers: z.union([z.object({}), z.null()]).optional(),
  webhook_events: z.union([z.array(z.string()), z.null()]).optional(),
});

export const zLlamaParseHtmlOptions = z.object({
  make_all_elements_visible: z.union([z.boolean(), z.null()]).optional(),
  remove_fixed_elements: z.union([z.boolean(), z.null()]).optional(),
  remove_navigation_elements: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParsePdfOptions = z.object({});

export const zLlamaParseSpreadsheetOptions = z.object({
  detect_sub_tables_in_sheets: z.union([z.boolean(), z.null()]).optional(),
  force_formula_computation_in_sheets: z
    .union([z.boolean(), z.null()])
    .optional(),
});

export const zLlamaParsePresentationOptions = z.object({
  out_of_bounds_content: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseInputOptions = z.object({
  html: zLlamaParseHtmlOptions.optional(),
  pdf: zLlamaParsePdfOptions.optional(),
  spreadsheet: zLlamaParseSpreadsheetOptions.optional(),
  presentation: zLlamaParsePresentationOptions.optional(),
});

export const zLlamaParsePageRanges = z.object({
  max_pages: z.union([z.number().int().gte(1), z.null()]).optional(),
  target_pages: z.union([z.string(), z.null()]).optional(),
});

export const zLlamaParsePages = z.object({
  merge_tables_across_pages_in_markdown: z
    .union([z.boolean(), z.null()])
    .optional(),
});

export const zLlamaParseTables = z.object({
  compact_markdown_tables: z.union([z.boolean(), z.null()]).optional(),
  output_tables_as_markdown: z.union([z.boolean(), z.null()]).optional(),
  markdown_table_multiline_separator: z
    .union([z.string(), z.null()])
    .optional(),
});

export const zLlamaParseMarkdownOptions = z.object({
  annotate_links: z.union([z.boolean(), z.null()]).optional(),
  pages: zLlamaParsePages.optional(),
  tables: zLlamaParseTables.optional(),
});

export const zLlamaParseSpatialTextOptions = z.object({
  preserve_layout_alignment_across_pages: z
    .union([z.boolean(), z.null()])
    .optional(),
  preserve_very_small_text: z.union([z.boolean(), z.null()]).optional(),
  do_not_unroll_columns: z.union([z.boolean(), z.null()]).optional(),
  pages: z.union([zLlamaParsePages, z.null()]).optional(),
});

export const zLlamaParseTablesAsSpreadsheetOptions = z.object({
  enable: z.union([z.boolean(), z.null()]).optional(),
  guess_sheet_name: z.boolean().optional().default(true),
});

export const zLlamaParseScreenshotsOptions = z.object({
  enable: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseOutputOptions = z.object({
  markdown: zLlamaParseMarkdownOptions.optional(),
  spatial_text: zLlamaParseSpatialTextOptions.optional(),
  tables_as_spreadsheet: zLlamaParseTablesAsSpreadsheetOptions.optional(),
  embedded_images: zLlamaParseEmbeddedImagesOptions.optional(),
  screenshots: zLlamaParseScreenshotsOptions.optional(),
  export_pdf: zLlamaParseExportPdfOptions.optional(),
  extract_printed_page_number: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseTimeouts = z.object({
  base_in_seconds: z.union([z.number().int().lte(1800), z.null()]).optional(),
  extra_time_per_page_in_seconds: z
    .union([z.number().int().lte(300), z.null()])
    .optional(),
});

export const zLlamaParseJobFailureConditions = z.object({
  allowed_page_failure_ratio: z.union([z.number().lte(1), z.null()]).optional(),
  fail_on_image_extraction_error: z.union([z.boolean(), z.null()]).optional(),
  fail_on_image_ocr_error: z.union([z.boolean(), z.null()]).optional(),
  fail_on_markdown_reconstruction_error: z
    .union([z.boolean(), z.null()])
    .optional(),
  fail_on_buggy_font: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseProcessingControl = z.object({
  timeouts: zLlamaParseTimeouts.optional(),
  job_failure_conditions: zLlamaParseJobFailureConditions.optional(),
});

export const zLlamaParseFileIdConfiguration = z.object({
  client_name: z.union([z.string(), z.null()]).optional(),
  parse_options: zLlamaParseTierOptions,
  webhook_configurations: z.array(zLlamaParseWebhookConfiguration).optional(),
  input_options: zLlamaParseInputOptions.optional(),
  crop_box: zLlamaParseCropBox.optional(),
  page_ranges: zLlamaParsePageRanges.optional(),
  disable_cache: z.union([z.boolean(), z.null()]).optional(),
  output_options: zLlamaParseOutputOptions.optional(),
  processing_control: zLlamaParseProcessingControl.optional(),
  file_id: z.string(),
});

export const zLlamaParseParameters = z.object({
  webhook_configurations: z
    .union([z.array(zWebhookConfiguration), z.null()])
    .optional(),
  priority: z
    .union([z.enum(["low", "medium", "high", "critical"]), z.null()])
    .optional(),
  languages: z.array(zParserLanguages).min(1).optional(),
  parsing_instruction: z.union([z.string(), z.null()]).optional(),
  disable_ocr: z.union([z.boolean(), z.null()]).optional(),
  annotate_links: z.union([z.boolean(), z.null()]).optional(),
  adaptive_long_table: z.union([z.boolean(), z.null()]).optional(),
  compact_markdown_table: z.union([z.boolean(), z.null()]).optional(),
  disable_reconstruction: z.union([z.boolean(), z.null()]).optional(),
  disable_image_extraction: z.union([z.boolean(), z.null()]).optional(),
  invalidate_cache: z.union([z.boolean(), z.null()]).optional(),
  outlined_table_extraction: z.union([z.boolean(), z.null()]).optional(),
  aggressive_table_extraction: z.union([z.boolean(), z.null()]).optional(),
  merge_tables_across_pages_in_markdown: z
    .union([z.boolean(), z.null()])
    .optional(),
  output_pdf_of_document: z.union([z.boolean(), z.null()]).optional(),
  do_not_cache: z.union([z.boolean(), z.null()]).optional(),
  fast_mode: z.union([z.boolean(), z.null()]).optional(),
  skip_diagonal_text: z.union([z.boolean(), z.null()]).optional(),
  preserve_layout_alignment_across_pages: z
    .union([z.boolean(), z.null()])
    .optional(),
  preserve_very_small_text: z.union([z.boolean(), z.null()]).optional(),
  gpt4o_mode: z.union([z.boolean(), z.null()]).optional(),
  gpt4o_api_key: z.union([z.string(), z.null()]).optional(),
  do_not_unroll_columns: z.union([z.boolean(), z.null()]).optional(),
  extract_layout: z.union([z.boolean(), z.null()]).optional(),
  high_res_ocr: z.union([z.boolean(), z.null()]).optional(),
  html_make_all_elements_visible: z.union([z.boolean(), z.null()]).optional(),
  layout_aware: z.union([z.boolean(), z.null()]).optional(),
  specialized_chart_parsing_agentic: z
    .union([z.boolean(), z.null()])
    .optional(),
  specialized_chart_parsing_plus: z.union([z.boolean(), z.null()]).optional(),
  specialized_chart_parsing_efficient: z
    .union([z.boolean(), z.null()])
    .optional(),
  specialized_image_parsing: z.union([z.boolean(), z.null()]).optional(),
  precise_bounding_box: z.union([z.boolean(), z.null()]).optional(),
  line_level_bounding_box: z.union([z.boolean(), z.null()]).optional(),
  html_remove_navigation_elements: z.union([z.boolean(), z.null()]).optional(),
  html_remove_fixed_elements: z.union([z.boolean(), z.null()]).optional(),
  guess_xlsx_sheet_name: z.union([z.boolean(), z.null()]).optional(),
  page_separator: z.union([z.string(), z.null()]).optional(),
  bounding_box: z.union([z.string(), z.null()]).optional(),
  bbox_top: z.union([z.number(), z.null()]).optional(),
  bbox_right: z.union([z.number(), z.null()]).optional(),
  bbox_bottom: z.union([z.number(), z.null()]).optional(),
  bbox_left: z.union([z.number(), z.null()]).optional(),
  target_pages: z.union([z.string(), z.null()]).optional(),
  use_vendor_multimodal_model: z.union([z.boolean(), z.null()]).optional(),
  vendor_multimodal_model_name: z.union([z.string(), z.null()]).optional(),
  model: z.union([z.string(), z.null()]).optional(),
  vendor_multimodal_api_key: z.union([z.string(), z.null()]).optional(),
  page_prefix: z.union([z.string(), z.null()]).optional(),
  page_suffix: z.union([z.string(), z.null()]).optional(),
  webhook_url: z.union([z.string(), z.null()]).optional(),
  preset: z.union([z.string(), z.null()]).optional(),
  take_screenshot: z.union([z.boolean(), z.null()]).optional(),
  is_formatting_instruction: z.union([z.boolean(), z.null()]).optional(),
  premium_mode: z.union([z.boolean(), z.null()]).optional(),
  continuous_mode: z.union([z.boolean(), z.null()]).optional(),
  input_s3_path: z.union([z.string(), z.null()]).optional(),
  input_s3_region: z.union([z.string(), z.null()]).optional(),
  output_s3_path_prefix: z.union([z.string(), z.null()]).optional(),
  output_s3_region: z.union([z.string(), z.null()]).optional(),
  project_id: z.union([z.string(), z.null()]).optional(),
  azure_openai_deployment_name: z.union([z.string(), z.null()]).optional(),
  azure_openai_endpoint: z.union([z.string(), z.null()]).optional(),
  azure_openai_api_version: z.union([z.string(), z.null()]).optional(),
  azure_openai_key: z.union([z.string(), z.null()]).optional(),
  input_url: z.union([z.string(), z.null()]).optional(),
  http_proxy: z.union([z.string(), z.null()]).optional(),
  auto_mode: z.union([z.boolean(), z.null()]).optional(),
  auto_mode_trigger_on_regexp_in_page: z
    .union([z.string(), z.null()])
    .optional(),
  auto_mode_trigger_on_text_in_page: z.union([z.string(), z.null()]).optional(),
  auto_mode_trigger_on_table_in_page: z
    .union([z.boolean(), z.null()])
    .optional(),
  auto_mode_trigger_on_image_in_page: z
    .union([z.boolean(), z.null()])
    .optional(),
  auto_mode_configuration_json: z.union([z.string(), z.null()]).optional(),
  structured_output: z.union([z.boolean(), z.null()]).optional(),
  structured_output_json_schema: z.union([z.string(), z.null()]).optional(),
  structured_output_json_schema_name: z
    .union([z.string(), z.null()])
    .optional(),
  max_pages: z.union([z.number().int(), z.null()]).optional(),
  max_pages_enforced: z.union([z.number().int(), z.null()]).optional(),
  extract_charts: z.union([z.boolean(), z.null()]).optional(),
  formatting_instruction: z.union([z.string(), z.null()]).optional(),
  complemental_formatting_instruction: z
    .union([z.string(), z.null()])
    .optional(),
  content_guideline_instruction: z.union([z.string(), z.null()]).optional(),
  spreadsheet_extract_sub_tables: z.union([z.boolean(), z.null()]).optional(),
  spreadsheet_force_formula_computation: z
    .union([z.boolean(), z.null()])
    .optional(),
  inline_images_in_markdown: z.union([z.boolean(), z.null()]).optional(),
  job_timeout_in_seconds: z.union([z.number(), z.null()]).optional(),
  job_timeout_extra_time_per_page_in_seconds: z
    .union([z.number(), z.null()])
    .optional(),
  strict_mode_image_extraction: z.union([z.boolean(), z.null()]).optional(),
  strict_mode_image_ocr: z.union([z.boolean(), z.null()]).optional(),
  strict_mode_reconstruction: z.union([z.boolean(), z.null()]).optional(),
  strict_mode_buggy_font: z.union([z.boolean(), z.null()]).optional(),
  save_images: z.union([z.boolean(), z.null()]).optional(),
  hide_headers: z.union([z.boolean(), z.null()]).optional(),
  hide_footers: z.union([z.boolean(), z.null()]).optional(),
  page_header_prefix: z.union([z.string(), z.null()]).optional(),
  page_header_suffix: z.union([z.string(), z.null()]).optional(),
  page_footer_prefix: z.union([z.string(), z.null()]).optional(),
  page_footer_suffix: z.union([z.string(), z.null()]).optional(),
  remove_hidden_text: z.union([z.boolean(), z.null()]).optional(),
  keep_page_separator_when_merging_tables: z
    .union([z.boolean(), z.null()])
    .optional(),
  ignore_document_elements_for_layout_detection: z
    .union([z.boolean(), z.null()])
    .optional(),
  output_tables_as_HTML: z.union([z.boolean(), z.null()]).optional(),
  internal_is_screenshot_job: z.union([z.boolean(), z.null()]).optional(),
  parse_mode: z.union([zParsingMode, z.null()]).optional(),
  system_prompt: z.union([z.string(), z.null()]).optional(),
  system_prompt_append: z.union([z.string(), z.null()]).optional(),
  user_prompt: z.union([z.string(), z.null()]).optional(),
  page_error_tolerance: z.union([z.number(), z.null()]).optional(),
  replace_failed_page_mode: z.union([zFailPageMode, z.null()]).optional(),
  replace_failed_page_with_error_message_prefix: z
    .union([z.string(), z.null()])
    .optional(),
  replace_failed_page_with_error_message_suffix: z
    .union([z.string(), z.null()])
    .optional(),
  markdown_table_multiline_header_separator: z
    .union([z.string(), z.null()])
    .optional(),
  presentation_out_of_bounds_content: z
    .union([z.boolean(), z.null()])
    .optional(),
  tier: z.union([z.string(), z.null()]).optional(),
  version: z.union([z.string(), z.null()]).optional(),
  extract_printed_page_number: z.union([z.boolean(), z.null()]).optional(),
});

export const zLlamaParseSupportedFileExtensions = z.enum([
  ".pdf",
  ".doc",
  ".docx",
  ".docm",
  ".dot",
  ".dotx",
  ".dotm",
  ".rtf",
  ".wps",
  ".wpd",
  ".sxw",
  ".stw",
  ".sxg",
  ".pages",
  ".mw",
  ".mcw",
  ".uot",
  ".uof",
  ".uos",
  ".uop",
  ".ppt",
  ".pptx",
  ".pot",
  ".pptm",
  ".potx",
  ".potm",
  ".key",
  ".odp",
  ".odg",
  ".otp",
  ".fopd",
  ".sxi",
  ".sti",
  ".epub",
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".svg",
  ".tiff",
  ".webp",
  ".html",
  ".htm",
  ".xls",
  ".xlsx",
  ".xlsm",
  ".xlsb",
  ".xlw",
  ".csv",
  ".dif",
  ".sylk",
  ".slk",
  ".prn",
  ".numbers",
  ".et",
  ".ods",
  ".fods",
  ".uos1",
  ".uos2",
  ".dbf",
  ".wk1",
  ".wk2",
  ".wk3",
  ".wk4",
  ".wks",
  ".wq1",
  ".wq2",
  ".wb1",
  ".wb2",
  ".wb3",
  ".qpw",
  ".xlr",
  ".eth",
  ".tsv",
]);

export const zLlamaParseUrlConfiguration = z.object({
  client_name: z.union([z.string(), z.null()]).optional(),
  parse_options: zLlamaParseTierOptions,
  webhook_configurations: z.array(zLlamaParseWebhookConfiguration).optional(),
  input_options: zLlamaParseInputOptions.optional(),
  crop_box: zLlamaParseCropBox.optional(),
  page_ranges: zLlamaParsePageRanges.optional(),
  disable_cache: z.union([z.boolean(), z.null()]).optional(),
  output_options: zLlamaParseOutputOptions.optional(),
  processing_control: zLlamaParseProcessingControl.optional(),
  source_url: z.string().regex(/^https?:/),
  http_proxy: z.union([z.string().regex(/^https?:/), z.null()]).optional(),
});

export const zManagedIngestionStatus = z.enum([
  "NOT_STARTED",
  "IN_PROGRESS",
  "SUCCESS",
  "ERROR",
  "PARTIAL_SUCCESS",
  "CANCELLED",
]);

export const zManagedIngestionStatusResponse = z.object({
  job_id: z.union([z.string().uuid(), z.null()]).optional(),
  deployment_date: z.union([z.string().datetime(), z.null()]).optional(),
  status: zManagedIngestionStatus,
  error: z.union([z.array(zIngestionErrorResponse), z.null()]).optional(),
  effective_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zManagedOpenAiEmbedding = z.object({
  model_name: z
    .literal("openai-text-embedding-3-small")
    .optional()
    .default("openai-text-embedding-3-small"),
  embed_batch_size: z.number().int().lte(2048).optional().default(10),
  num_workers: z.union([z.number().int(), z.null()]).optional(),
  class_name: z.string().optional().default("ManagedOpenAIEmbedding"),
});

export const zManagedOpenAiEmbeddingConfig = z.object({
  type: z
    .literal("MANAGED_OPENAI_EMBEDDING")
    .optional()
    .default("MANAGED_OPENAI_EMBEDDING"),
  component: zManagedOpenAiEmbedding.optional(),
});

export const zMarkdownResultPage = z.object({
  page_number: z.number().int(),
  markdown: z.string(),
  success: z.literal(true).optional().default(true),
});

export const zMarkdownResult = z.object({
  pages: z.array(z.unknown()),
});

export const zNodeRelationship = z.enum(["1", "2", "3", "4", "5"]);

export const zObjectType = z.enum(["1", "2", "3", "4", "5"]);

export const zParsePlanLevel = z.enum(["DEFAULT", "PREMIUM"]);

export const zOrganization = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string().min(1).max(3000),
  parse_plan_level: zParsePlanLevel.optional(),
  stripe_customer_id: z.union([z.string(), z.null()]).optional(),
  feature_flags: z.union([z.object({}), z.null()]).optional(),
});

export const zPaginatedExtractRunsResponse = z.object({
  items: z.array(zExtractRun),
  total: z.number().int(),
  skip: z.number().int(),
  limit: z.number().int(),
});

export const zPaginatedListCloudDocumentsResponse = z.object({
  documents: z.array(zCloudDocument),
  limit: z.number().int(),
  offset: z.number().int(),
  total_count: z.number().int(),
});

export const zPipelineFile = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.union([z.string().min(1).max(3000), z.null()]).optional(),
  external_file_id: z.union([z.string(), z.null()]).optional(),
  file_size: z.union([z.number().int().gte(0), z.null()]).optional(),
  file_type: z.union([z.string().min(1).max(3000), z.null()]).optional(),
  project_id: z.union([z.string().uuid(), z.null()]).optional(),
  last_modified_at: z.union([z.string().datetime(), z.null()]).optional(),
  file_id: z.union([z.string().uuid(), z.null()]).optional(),
  pipeline_id: z.string().uuid(),
  resource_info: z.union([z.object({}), z.null()]).optional(),
  permission_info: z.union([z.object({}), z.null()]).optional(),
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
  data_source_id: z.union([z.string().uuid(), z.null()]).optional(),
  config_hash: z.union([z.object({}), z.null()]).optional(),
  indexed_page_count: z.union([z.number().int(), z.null()]).optional(),
  status: z
    .union([
      z.enum(["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "CANCELLED"]),
      z.null(),
    ])
    .optional(),
  status_updated_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zPaginatedListPipelineFilesResponse = z.object({
  files: z.array(zPipelineFile),
  limit: z.number().int(),
  offset: z.number().int(),
  total_count: z.number().int(),
});

export const zPaginatedResponseAgentData = z.object({
  items: z.array(zAgentData),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zPaginatedResponseAggregateGroup = z.object({
  items: z.array(zAggregateGroup),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zPaginatedResponseClassifyJob = z.object({
  items: z.array(zClassifyJob),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zSpreadsheetParsingConfig = z.object({
  sheet_names: z.union([z.array(z.string()), z.null()]).optional(),
  include_hidden_cells: z.boolean().optional().default(true),
  extraction_range: z.union([z.string(), z.null()]).optional(),
  generate_additional_metadata: z.boolean().optional().default(true),
  use_experimental_processing: z.boolean().optional().default(false),
});

export const zWorksheetMetadata = z.object({
  sheet_name: z.string(),
  title: z.union([z.string(), z.null()]).optional(),
  description: z.union([z.string(), z.null()]).optional(),
});

export const zSpreadsheetJob = z.object({
  id: z.string(),
  user_id: z.string(),
  project_id: z.string().uuid(),
  config: zSpreadsheetParsingConfig,
  status: zStatusEnum,
  created_at: z.string(),
  updated_at: z.string(),
  success: z.union([z.boolean(), z.null()]).optional(),
  regions: z.array(zExtractedRegionSummary).optional(),
  worksheet_metadata: z.array(zWorksheetMetadata).optional(),
  errors: z.array(z.string()).optional(),
  file_id: z.union([z.string().uuid(), z.null()]),
  file: z.union([zFile, z.null()]).optional(),
});

export const zPaginatedResponseSpreadsheetJob = z.object({
  items: z.array(zSpreadsheetJob),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zParseConfiguration = z.object({
  id: z.string(),
  name: z.string(),
  source_type: z.string(),
  source_id: z.string(),
  creator: z.union([z.string(), z.null()]).optional(),
  version: z.string(),
  parameters: zLlamaParseParameters,
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});

export const zParseConfigurationCreate = z.object({
  name: z.string(),
  source_type: z.union([z.string(), z.null()]).optional(),
  source_id: z.union([z.string(), z.null()]).optional(),
  creator: z.union([z.string(), z.null()]).optional(),
  version: z.string(),
  parameters: zLlamaParseParameters,
});

export const zParseConfigurationQueryResponse = z.object({
  items: z.array(zParseConfiguration),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zParseConfigurationUpdate = z.object({
  parameters: z.union([zLlamaParseParameters, z.null()]).optional(),
});

export const zParsingJob = z.object({
  id: z.string().uuid(),
  status: zStatusEnum,
  error_code: z.union([z.string(), z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
});

export const zParsingJobJsonResult = z.object({
  pages: z.unknown(),
  job_metadata: z.unknown(),
});

export const zParsingJobMarkdownResult = z.object({
  markdown: z.string(),
  job_metadata: z.unknown(),
});

export const zParsingJobStructuredResult = z.object({
  structured: z.unknown(),
  job_metadata: z.unknown(),
});

export const zParsingJobTextResult = z.object({
  text: z.string(),
  job_metadata: z.unknown(),
});

export const zPartitionNames = z.enum([
  "data_source_id_partition",
  "pipeline_id_partition",
  "eval_dataset_id_partition",
  "file_id_partition",
  "pipeline_file_id_partition",
  "file_parsing_id_partition",
  "extraction_schema_id_partition",
]);

export const zPipelineType = z.enum(["PLAYGROUND", "MANAGED"]);

export const zSparseModelType = z.enum(["splade", "bm25", "auto"]);

export const zSparseModelConfig = z.object({
  model_type: zSparseModelType.optional(),
  class_name: z.string().optional().default("SparseModelConfig"),
});

export const zPipelineConfigurationHashes = z.object({
  embedding_config_hash: z.union([z.string(), z.null()]).optional(),
  parsing_config_hash: z.union([z.string(), z.null()]).optional(),
  transform_config_hash: z.union([z.string(), z.null()]).optional(),
});

export const zPipelineMetadataConfig = z.object({
  excluded_embed_metadata_keys: z.array(z.string()).optional(),
  excluded_llm_metadata_keys: z.array(z.string()).optional(),
});

export const zPipeline = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string(),
  project_id: z.string().uuid(),
  embedding_model_config_id: z.union([z.string().uuid(), z.null()]).optional(),
  embedding_model_config: z.union([zEmbeddingModelConfig, z.null()]).optional(),
  pipeline_type: zPipelineType.optional(),
  managed_pipeline_id: z.union([z.string().uuid(), z.null()]).optional(),
  embedding_config: z.union([
    z
      .object({
        type: z.literal("MANAGED_OPENAI_EMBEDDING"),
      })
      .and(zManagedOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("AZURE_EMBEDDING"),
      })
      .and(zAzureOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("COHERE_EMBEDDING"),
      })
      .and(zCohereEmbeddingConfig),
    z
      .object({
        type: z.literal("GEMINI_EMBEDDING"),
      })
      .and(zGeminiEmbeddingConfig),
    z
      .object({
        type: z.literal("HUGGINGFACE_API_EMBEDDING"),
      })
      .and(zHuggingFaceInferenceApiEmbeddingConfig),
    z
      .object({
        type: z.literal("OPENAI_EMBEDDING"),
      })
      .and(zOpenAiEmbeddingConfig),
    z
      .object({
        type: z.literal("VERTEXAI_EMBEDDING"),
      })
      .and(zVertexAiEmbeddingConfig),
    z
      .object({
        type: z.literal("BEDROCK_EMBEDDING"),
      })
      .and(zBedrockEmbeddingConfig),
  ]),
  sparse_model_config: z.union([zSparseModelConfig, z.null()]).optional(),
  config_hash: z.union([zPipelineConfigurationHashes, z.null()]).optional(),
  transform_config: z
    .union([zAutoTransformConfig, zAdvancedModeTransformConfig])
    .optional(),
  preset_retrieval_parameters: zPresetRetrievalParams.optional(),
  llama_parse_parameters: z.union([zLlamaParseParameters, z.null()]).optional(),
  data_sink: z.union([zDataSink, z.null()]).optional(),
  status: z.union([z.enum(["CREATED", "DELETING"]), z.null()]).optional(),
  metadata_config: z.union([zPipelineMetadataConfig, z.null()]).optional(),
});

export const zPipelineCreate = z.object({
  embedding_config: z
    .union([
      z.union([
        z
          .object({
            type: z.literal("AZURE_EMBEDDING"),
          })
          .and(zAzureOpenAiEmbeddingConfig),
        z
          .object({
            type: z.literal("COHERE_EMBEDDING"),
          })
          .and(zCohereEmbeddingConfig),
        z
          .object({
            type: z.literal("GEMINI_EMBEDDING"),
          })
          .and(zGeminiEmbeddingConfig),
        z
          .object({
            type: z.literal("HUGGINGFACE_API_EMBEDDING"),
          })
          .and(zHuggingFaceInferenceApiEmbeddingConfig),
        z
          .object({
            type: z.literal("OPENAI_EMBEDDING"),
          })
          .and(zOpenAiEmbeddingConfig),
        z
          .object({
            type: z.literal("VERTEXAI_EMBEDDING"),
          })
          .and(zVertexAiEmbeddingConfig),
        z
          .object({
            type: z.literal("BEDROCK_EMBEDDING"),
          })
          .and(zBedrockEmbeddingConfig),
      ]),
      z.null(),
    ])
    .optional(),
  transform_config: z
    .union([zAutoTransformConfig, zAdvancedModeTransformConfig, z.null()])
    .optional(),
  sparse_model_config: z.union([zSparseModelConfig, z.null()]).optional(),
  data_sink_id: z.union([z.string().uuid(), z.null()]).optional(),
  embedding_model_config_id: z.union([z.string().uuid(), z.null()]).optional(),
  data_sink: z.union([zDataSinkCreate, z.null()]).optional(),
  preset_retrieval_parameters: zPresetRetrievalParams.optional(),
  llama_parse_parameters: zLlamaParseParameters.optional(),
  status: z.union([z.string(), z.null()]).optional(),
  metadata_config: z.union([zPipelineMetadataConfig, z.null()]).optional(),
  name: z.string().min(1).max(3000),
  pipeline_type: zPipelineType.optional(),
  managed_pipeline_id: z.union([z.string().uuid(), z.null()]).optional(),
});

export const zPipelineDataSource = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  name: z.string(),
  source_type: zConfigurableDataSourceNames,
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
  component: z.union([
    z.object({}),
    zCloudS3DataSource,
    zCloudAzStorageBlobDataSource,
    zCloudOneDriveDataSource,
    zCloudSharepointDataSource,
    zCloudSlackDataSource,
    zCloudNotionPageDataSource,
    zCloudConfluenceDataSource,
    zCloudJiraDataSource,
    zCloudJiraDataSourceV2,
    zCloudBoxDataSource,
  ]),
  version_metadata: z
    .union([zDataSourceReaderVersionMetadata, z.null()])
    .optional(),
  project_id: z.string().uuid(),
  data_source_id: z.string().uuid(),
  pipeline_id: z.string().uuid(),
  last_synced_at: z.string().datetime(),
  sync_interval: z.union([z.number(), z.null()]).optional(),
  sync_schedule_set_by: z.union([z.string(), z.null()]).optional(),
  status: z
    .union([
      z.enum(["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "CANCELLED"]),
      z.null(),
    ])
    .optional(),
  status_updated_at: z.union([z.string().datetime(), z.null()]).optional(),
});

export const zPipelineDataSourceCreate = z.object({
  data_source_id: z.string().uuid(),
  sync_interval: z.union([z.number(), z.null()]).optional(),
});

export const zPipelineDataSourceUpdate = z.object({
  sync_interval: z.union([z.number(), z.null()]).optional(),
});

export const zPipelineFileCreate = z.object({
  file_id: z.string().uuid(),
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
});

export const zPipelineFileUpdate = z.object({
  custom_metadata: z.union([z.object({}), z.null()]).optional(),
});

export const zPipelineUpdate = z.object({
  embedding_config: z
    .union([
      z.union([
        z
          .object({
            type: z.literal("AZURE_EMBEDDING"),
          })
          .and(zAzureOpenAiEmbeddingConfig),
        z
          .object({
            type: z.literal("COHERE_EMBEDDING"),
          })
          .and(zCohereEmbeddingConfig),
        z
          .object({
            type: z.literal("GEMINI_EMBEDDING"),
          })
          .and(zGeminiEmbeddingConfig),
        z
          .object({
            type: z.literal("HUGGINGFACE_API_EMBEDDING"),
          })
          .and(zHuggingFaceInferenceApiEmbeddingConfig),
        z
          .object({
            type: z.literal("OPENAI_EMBEDDING"),
          })
          .and(zOpenAiEmbeddingConfig),
        z
          .object({
            type: z.literal("VERTEXAI_EMBEDDING"),
          })
          .and(zVertexAiEmbeddingConfig),
        z
          .object({
            type: z.literal("BEDROCK_EMBEDDING"),
          })
          .and(zBedrockEmbeddingConfig),
      ]),
      z.null(),
    ])
    .optional(),
  transform_config: z
    .union([zAutoTransformConfig, zAdvancedModeTransformConfig, z.null()])
    .optional(),
  sparse_model_config: z.union([zSparseModelConfig, z.null()]).optional(),
  data_sink_id: z.union([z.string().uuid(), z.null()]).optional(),
  embedding_model_config_id: z.union([z.string().uuid(), z.null()]).optional(),
  data_sink: z.union([zDataSinkCreate, z.null()]).optional(),
  preset_retrieval_parameters: z
    .union([zPresetRetrievalParams, z.null()])
    .optional(),
  llama_parse_parameters: z.union([zLlamaParseParameters, z.null()]).optional(),
  status: z.union([z.string(), z.null()]).optional(),
  metadata_config: z.union([zPipelineMetadataConfig, z.null()]).optional(),
  name: z.union([z.string(), z.null()]).optional(),
  managed_pipeline_id: z.union([z.string().uuid(), z.null()]).optional(),
});

export const zPlaygroundSession = z.object({
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  pipeline_id: z.string().uuid(),
  user_id: z.string(),
  llm_params_id: z.string().uuid(),
  llm_params: zLlmParameters.optional(),
  retrieval_params_id: z.string().uuid(),
  retrieval_params: zPresetRetrievalParams.optional(),
  chat_messages: z.array(zChatMessage).optional(),
});

export const zPresignedUrl = z.object({
  url: z.string().url().min(1),
  expires_at: z.string().datetime(),
  form_fields: z.union([z.object({}), z.null()]).optional(),
});

export const zProject = z.object({
  name: z.string().min(1).max(3000),
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  ad_hoc_eval_dataset_id: z.union([z.string().uuid(), z.null()]).optional(),
  organization_id: z.string().uuid(),
  is_default: z.boolean().optional().default(false),
});

export const zRelatedNodeInfo = z.object({
  node_id: z.string(),
  node_type: z.union([zObjectType, z.string(), z.null()]).optional(),
  metadata: z.object({}).optional(),
  hash: z.union([z.string(), z.null()]).optional(),
  class_name: z.string().optional().default("RelatedNodeInfo"),
});

export const zRetrievalParams = z.object({
  dense_similarity_top_k: z
    .union([z.number().int().gte(1).lte(100), z.null()])
    .optional(),
  dense_similarity_cutoff: z
    .union([z.number().gte(0).lte(1), z.null()])
    .optional(),
  sparse_similarity_top_k: z
    .union([z.number().int().gte(1).lte(100), z.null()])
    .optional(),
  enable_reranking: z.union([z.boolean(), z.null()]).optional(),
  rerank_top_n: z
    .union([z.number().int().gte(1).lte(100), z.null()])
    .optional(),
  alpha: z.union([z.number().gte(0).lte(1), z.null()]).optional(),
  search_filters: z.union([zMetadataFilters, z.null()]).optional(),
  search_filters_inference_schema: z.union([z.object({}), z.null()]).optional(),
  files_top_k: z.union([z.number().int().gte(1).lte(5), z.null()]).optional(),
  retrieval_mode: zRetrievalMode.optional(),
  retrieve_image_nodes: z.boolean().optional().default(false),
  retrieve_page_screenshot_nodes: z.boolean().optional().default(false),
  retrieve_page_figure_nodes: z.boolean().optional().default(false),
  query: z.string().min(1),
  class_name: z.string().optional().default("base_component"),
});

export const zTextNode = z.object({
  id_: z.string().optional(),
  embedding: z.union([z.array(z.number()), z.null()]).optional(),
  extra_info: z.object({}).optional(),
  excluded_embed_metadata_keys: z.array(z.string()).optional(),
  excluded_llm_metadata_keys: z.array(z.string()).optional(),
  relationships: z.object({}).optional(),
  metadata_template: z.string().optional().default("{key}: {value}"),
  metadata_seperator: z.string().optional().default(`
`),
  text: z.string().optional().default(""),
  mimetype: z.string().optional().default("text/plain"),
  start_char_idx: z.union([z.number().int(), z.null()]).optional(),
  end_char_idx: z.union([z.number().int(), z.null()]).optional(),
  text_template: z.string().optional().default(`{metadata_str}

{content}`),
  class_name: z.string().optional().default("TextNode"),
});

export const zTextNodeWithScore = z.object({
  node: zTextNode,
  score: z.union([z.number(), z.null()]).optional(),
  class_name: z.string().optional().default("TextNodeWithScore"),
});

export const zRetrieveResults = z.object({
  pipeline_id: z.string().uuid(),
  retrieval_nodes: z.array(zTextNodeWithScore),
  image_nodes: z.array(zPageScreenshotNodeWithScore).optional(),
  page_figure_nodes: z.array(zPageFigureNodeWithScore).optional(),
  retrieval_latency: z.object({}).optional(),
  metadata: z.object({}).optional(),
  inferred_search_filters: z.union([zMetadataFilters, z.null()]).optional(),
  class_name: z.string().optional().default("RetrieveResults"),
});

export const zRetriever = z.object({
  name: z.string().min(1).max(3000),
  pipelines: z.array(zRetrieverPipeline).optional(),
  id: z.string().uuid(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string().uuid(),
});

export const zRetrieverCreate = z.object({
  name: z.string().min(1).max(3000),
  pipelines: z.array(zRetrieverPipeline).optional(),
});

export const zRetrieverUpdate = z.object({
  name: z.union([z.string(), z.null()]).optional(),
  pipelines: z.union([z.array(zRetrieverPipeline), z.null()]),
});

export const zSearchRequest = z.object({
  page_size: z.union([z.number().int(), z.null()]).optional(),
  page_token: z.union([z.string(), z.null()]).optional(),
  filter: z.union([z.object({}), z.null()]).optional(),
  order_by: z.union([z.string(), z.null()]).optional(),
  deployment_name: z.string(),
  collection: z.string().optional().default("default"),
  include_total: z.boolean().optional().default(false),
  offset: z.union([z.number().int().gte(0).lte(1000), z.null()]).optional(),
});

export const zSplitCategory = z.object({
  name: z.string().min(1).max(200),
  description: z.union([z.string().min(1).max(2000), z.null()]).optional(),
});

export const zSplitDocumentInput = z.object({
  type: z.string(),
  value: z.string(),
});

export const zSplitStrategy = z.object({
  allow_uncategorized: z.boolean().optional().default(false),
});

export const zSplitCreateRequest = z.object({
  document_input: zSplitDocumentInput,
  categories: z.array(zSplitCategory).min(1).max(50),
  splitting_strategy: zSplitStrategy.optional(),
});

export const zSplitSegmentResponse = z.object({
  category: z.string(),
  pages: z.array(z.number().int()),
  confidence_category: z.string(),
});

export const zSplitResultResponse = z.object({
  segments: z.array(zSplitSegmentResponse),
});

export const zSplitJobResponse = z.object({
  id: z.string(),
  created_at: z.union([z.string().datetime(), z.null()]).optional(),
  updated_at: z.union([z.string().datetime(), z.null()]).optional(),
  project_id: z.string(),
  user_id: z.string(),
  document_input: zSplitDocumentInput,
  categories: z.array(zSplitCategory),
  status: z.string(),
  result: z.union([zSplitResultResponse, z.null()]).optional(),
  error_message: z.union([z.string(), z.null()]).optional(),
});

export const zSplitJobQueryResponse = z.object({
  items: z.array(zSplitJobResponse),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zSpreadsheetJobCreate = z.object({
  file_id: z.string().uuid(),
  config: zSpreadsheetParsingConfig.optional(),
});

export const zSpreadsheetResultType = z.enum([
  "table",
  "extra",
  "cell_metadata",
]);

export const zTableItem = z.object({
  type: z.literal("table").optional().default("table"),
  bBox: z.union([z.unknown(), z.null()]).optional(),
  rows: z.array(z.array(z.string())),
  html: z.string(),
  md: z.string(),
  csv: z.string(),
});

export const zStructuredResultPage = z.object({
  page_number: z.number().int(),
  items: z.array(z.unknown()),
  success: z.literal(true).optional().default(true),
});

export const zStructuredResult = z.object({
  pages: z.array(z.unknown()),
});

export const zTextResultPage = z.object({
  page_number: z.number().int(),
  text: z.string(),
});

export const zTextResult = z.object({
  pages: z.array(zTextResultPage),
});

export const zUsageMetric = z.object({
  id: z.string().uuid(),
  user_id: z.string(),
  event_type: z.enum([
    "pages_indexed",
    "pages_embedded",
    "pages_parsed",
    "set_total_pages_indexed",
    "set_total_indexes",
    "layout_extracted",
    "layout_aware_parsing",
    "layout_aware_chart_extraction",
    "chart_parsing_agentic",
    "chart_parsing_plus",
    "chart_parsing_efficient",
    "image_classified",
    "precise_bbox_extraction",
    "audio_seconds_parsed",
    "extraction_num_pages",
    "extraction_num_pages_parsed",
  ]),
  project_id: z.string(),
  organization_id: z.string(),
  value: z.number().int(),
  properties: z.object({}).optional(),
  day: z.string(),
  event_aggregation_key: z.string(),
  event_aggregation_type: z.string(),
});

export const zUsageMetricQueryResponse = z.object({
  items: z.array(zUsageMetric),
  next_page_token: z.union([z.string(), z.null()]).optional(),
  total_size: z.union([z.number().int(), z.null()]).optional(),
});

export const zListDataSinksApiV1DataSinksGetResponse = z.array(zDataSink);

export const zCreateDataSinkApiV1DataSinksPostResponse = zDataSink;

export const zDeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse = z.void();

export const zGetDataSinkApiV1DataSinksDataSinkIdGetResponse = zDataSink;

export const zUpdateDataSinkApiV1DataSinksDataSinkIdPutResponse = zDataSink;

export const zListDataSourcesApiV1DataSourcesGetResponse = z.array(zDataSource);

export const zCreateDataSourceApiV1DataSourcesPostResponse = zDataSource;

export const zDeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse =
  z.void();

export const zGetDataSourceApiV1DataSourcesDataSourceIdGetResponse =
  zDataSource;

export const zUpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse =
  zDataSource;

export const zListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponse =
  z.array(zEmbeddingModelConfig);

export const zCreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponse =
  zEmbeddingModelConfig;

export const zDeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponse =
  z.void();

export const zUpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponse =
  zEmbeddingModelConfig;

export const zListOrganizationsApiV1OrganizationsGetResponse =
  z.array(zOrganization);

export const zGetOrganizationApiV1OrganizationsOrganizationIdGetResponse =
  zOrganization;

export const zListProjectsApiV1ProjectsGetResponse = z.array(zProject);

export const zGetProjectApiV1ProjectsProjectIdGetResponse = zProject;

export const zListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponse =
  z.array(zPageScreenshotMetadata);

export const zGenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponse =
  zPresignedUrl;

export const zListFilePagesFiguresApiV1FilesIdPageFiguresGetResponse =
  z.array(zPageFigureMetadata);

export const zListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponse =
  z.array(zPageFigureMetadata);

export const zGenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponse =
  zPresignedUrl;

export const zDeleteFileApiV1FilesIdDeleteResponse = z.void();

export const zGetFileApiV1FilesIdGetResponse = zFile;

export const zUploadFileApiV1FilesPostResponse = zFile;

export const zGeneratePresignedUrlApiV1FilesPutResponse = zFileIdPresignedUrl;

export const zUploadFileFromUrlApiV1FilesUploadFromUrlPutResponse = zFile;

export const zReadFileContentApiV1FilesIdContentGetResponse = zPresignedUrl;

export const zSearchPipelinesApiV1PipelinesGetResponse = z.array(zPipeline);

export const zCreatePipelineApiV1PipelinesPostResponse = zPipeline;

export const zUpsertPipelineApiV1PipelinesPutResponse = zPipeline;

export const zDeletePipelineApiV1PipelinesPipelineIdDeleteResponse = z.void();

export const zGetPipelineApiV1PipelinesPipelineIdGetResponse = zPipeline;

export const zUpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse =
  zPipeline;

export const zGetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse =
  zManagedIngestionStatusResponse;

export const zSyncPipelineApiV1PipelinesPipelineIdSyncPostResponse = zPipeline;

export const zCancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponse =
  zPipeline;

export const zForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponse =
  z.void();

export const zCopyPipelineApiV1PipelinesPipelineIdCopyPostResponse = zPipeline;

export const zRunSearchApiV1PipelinesPipelineIdRetrievePostResponse =
  zRetrieveResults;

export const zGetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponse =
  zPlaygroundSession;

export const zListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse =
  z.array(zPipelineDataSource);

export const zAddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse =
  z.array(zPipelineDataSource);

export const zUpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponse =
  zPipelineDataSource;

export const zSyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse =
  zPipeline;

export const zGetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponse =
  zManagedIngestionStatusResponse;

export const zListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponse =
  zPaginatedListPipelineFilesResponse;

export const zGetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponse =
  zFileCountByStatusResponse;

export const zGetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse =
  zManagedIngestionStatusResponse;

export const zAddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponse =
  z.array(zPipelineFile);

export const zDeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse =
  z.void();

export const zUpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse =
  zPipelineFile;

export const zDeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse =
  z.void();

export const zImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse =
  z.object({});

export const zListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse =
  z.array(zCloudDocument);

export const zCreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse =
  z.array(zCloudDocument);

export const zUpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse =
  z.array(zCloudDocument);

export const zPaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponse =
  zPaginatedListCloudDocumentsResponse;

export const zDeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse =
  z.void();

export const zGetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse =
  zCloudDocument;

export const zGetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse =
  zManagedIngestionStatusResponse;

export const zListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse =
  z.array(zTextNode);

export const zListRetrieversApiV1RetrieversGetResponse = z.array(zRetriever);

export const zCreateRetrieverApiV1RetrieversPostResponse = zRetriever;

export const zUpsertRetrieverApiV1RetrieversPutResponse = zRetriever;

export const zDeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponse =
  z.void();

export const zGetRetrieverApiV1RetrieversRetrieverIdGetResponse = zRetriever;

export const zUpdateRetrieverApiV1RetrieversRetrieverIdPutResponse = zRetriever;

export const zRetrieveApiV1RetrieversRetrieverIdRetrievePostResponse =
  zCompositeRetrievalResult;

export const zDirectRetrieveApiV1RetrieversRetrievePostResponse =
  zCompositeRetrievalResult;

export const zGetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse =
  z.array(zLlamaParseSupportedFileExtensions);

export const zScreenshotApiV1ParsingScreenshotPostResponse = zParsingJob;

export const zUploadFileApiV1ParsingUploadPostResponse = zParsingJob;

export const zGetJobApiV1ParsingJobJobIdGetResponse = zParsingJob;

export const zGetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse =
  zParsingJobTextResult;

export const zGetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponse =
  zParsingJobStructuredResult;

export const zGetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse =
  zParsingJobMarkdownResult;

export const zGetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse =
  zParsingJobJsonResult;

export const zGeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse =
  zPresignedUrl;

export const zListClassifyJobsApiV1ClassifierJobsGetResponse =
  zPaginatedResponseClassifyJob;

export const zCreateClassifyJobApiV1ClassifierJobsPostResponse = zClassifyJob;

export const zGetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponse =
  zClassifyJob;

export const zGetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponse =
  zClassifyJobResults;

export const zListJobsApiV1ExtractionJobsGetResponse = z.array(zExtractJob);

export const zRunJobApiV1ExtractionJobsPostResponse = zExtractJob;

export const zGetJobApiV1ExtractionJobsJobIdGetResponse = zExtractJob;

export const zRunJobOnFileApiV1ExtractionJobsFilePostResponse = zExtractJob;

export const zRunBatchJobsApiV1ExtractionJobsBatchPostResponse =
  z.array(zExtractJob);

export const zGetJobResultApiV1ExtractionJobsJobIdResultGetResponse =
  zExtractResultset;

export const zListExtractRunsApiV1ExtractionRunsGetResponse =
  zPaginatedExtractRunsResponse;

export const zGetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponse =
  z.union([zExtractRun, z.null()]);

export const zGetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponse =
  zExtractRun;

export const zGetRunApiV1ExtractionRunsRunIdGetResponse = zExtractRun;

export const zExtractStatelessApiV1ExtractionRunPostResponse = zExtractJob;

export const zListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponse =
  z.array(zExtractAgent);

export const zCreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponse =
  zExtractAgent;

export const zValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponse =
  zExtractSchemaValidateResponse;

export const zGenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponse =
  zExtractSchemaGenerateResponse;

export const zGetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponse =
  zExtractAgent;

export const zGetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponse =
  zExtractAgent;

export const zGetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponse =
  zExtractAgent;

export const zUpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponse =
  zExtractAgent;

export const zListUsageMetricsApiV1BetaUsageMetricsGetResponse =
  zUsageMetricQueryResponse;

export const zDeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponse = z.object(
  {},
);

export const zGetAgentDataApiV1BetaAgentDataItemIdGetResponse = zAgentData;

export const zUpdateAgentDataApiV1BetaAgentDataItemIdPutResponse = zAgentData;

export const zCreateAgentDataApiV1BetaAgentDataPostResponse = zAgentData;

export const zSearchAgentDataApiV1BetaAgentDataSearchPostResponse =
  zPaginatedResponseAgentData;

export const zAggregateAgentDataApiV1BetaAgentDataAggregatePostResponse =
  zPaginatedResponseAggregateGroup;

export const zDeleteAgentDataByQueryApiV1BetaAgentDataDeletePostResponse =
  zDeleteResponse;

export const zCreateFileApiV1BetaFilesPostResponse = zFile;

export const zUpsertFileApiV1BetaFilesPutResponse = zFile;

export const zQueryFilesApiV1BetaFilesQueryPostResponse = zFileQueryResponse;

export const zDeleteFileApiV1BetaFilesFileIdDeleteResponse = z.void();

export const zListParseConfigurationsApiV1BetaParseConfigurationsGetResponse =
  zParseConfigurationQueryResponse;

export const zCreateParseConfigurationApiV1BetaParseConfigurationsPostResponse =
  zParseConfiguration;

export const zDeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponse =
  z.void();

export const zGetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponse =
  zParseConfiguration;

export const zUpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponse =
  zParseConfiguration;

export const zListSpreadsheetJobsApiV1BetaSheetsJobsGetResponse =
  zPaginatedResponseSpreadsheetJob;

export const zCreateSpreadsheetJobApiV1BetaSheetsJobsPostResponse =
  zSpreadsheetJob;

export const zGetSpreadsheetJobApiV1BetaSheetsJobsSpreadsheetJobIdGetResponse =
  zSpreadsheetJob;

export const zGetResultRegionApiV1BetaSheetsJobsSpreadsheetJobIdRegionsRegionIdResultRegionTypeGetResponse =
  zPresignedUrl;

export const zListDirectoriesApiV1BetaDirectoriesGetResponse =
  zDirectoryQueryResponse;

export const zCreateDirectoryApiV1BetaDirectoriesPostResponse =
  zDirectoryResponse;

export const zDeleteDirectoryApiV1BetaDirectoriesDirectoryIdDeleteResponse =
  z.void();

export const zGetDirectoryApiV1BetaDirectoriesDirectoryIdGetResponse =
  zDirectoryResponse;

export const zUpdateDirectoryApiV1BetaDirectoriesDirectoryIdPatchResponse =
  zDirectoryResponse;

export const zCreateDirectorySyncJobApiV1BetaDirectorySyncJobsPostResponse =
  zDirectorySyncJobResponse;

export const zGetDirectorySyncJobApiV1BetaDirectorySyncJobsJobIdGetResponse =
  zDirectorySyncJobResponse;

export const zListDirectoryFilesApiV1BetaDirectoriesDirectoryIdFilesGetResponse =
  zDirectoryFileQueryResponse;

export const zAddDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesPostResponse =
  zDirectoryFileResponse;

export const zUploadFileToDirectoryApiV1BetaDirectoriesDirectoryIdFilesUploadPostResponse =
  zDirectoryFileResponse;

export const zDeleteDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdDeleteResponse =
  z.void();

export const zGetDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdGetResponse =
  zDirectoryFileResponse;

export const zUpdateDirectoryFileApiV1BetaDirectoriesDirectoryIdFilesDirectoryFileIdPatchResponse =
  zDirectoryFileResponse;

export const zListSplitJobsApiV1BetaSplitJobsGetResponse =
  zSplitJobQueryResponse;

export const zCreateSplitJobApiV1BetaSplitJobsPostResponse = zSplitJobResponse;

export const zGetSplitJobApiV1BetaSplitJobsSplitJobIdGetResponse =
  zSplitJobResponse;

export const zListBatchJobsApiV1BetaBatchProcessingGetResponse =
  zBatchJobQueryResponse;

export const zCreateBatchJobApiV1BetaBatchProcessingPostResponse =
  zBatchJobResponse;

export const zGetBatchJobStatusApiV1BetaBatchProcessingJobIdGetResponse =
  zBatchJobStatusResponse;

export const zListBatchJobItemsApiV1BetaBatchProcessingJobIdItemsGetResponse =
  zBatchItemListResponse;

export const zCancelBatchJobApiV1BetaBatchProcessingJobIdCancelPostResponse =
  zBatchJobCancelResponse;

export const zGetItemProcessingResultsApiV1BetaBatchProcessingItemsItemIdProcessingResultsGetResponse =
  zItemProcessingResultsResponse;

export const zUploadFileMultipartApiV2Alpha1ParseUploadPostResponse =
  zParsingJob;

export const zUploadFileByIdApiV2Alpha1ParsePostResponse = zParsingJob;

export const zUploadFileByUrlApiV2Alpha1ParseUrlPostResponse = zParsingJob;

export const zGetMarkdownTemplateApiV2Alpha1ParseJobJobIdResultMarkdownGetResponse =
  zMarkdownResult;

export const zGetTextTemplateApiV2Alpha1ParseJobJobIdResultTextGetResponse =
  zTextResult;

export const zGetStructuredTemplateApiV2Alpha1ParseJobJobIdResultStructuredGetResponse =
  zStructuredResult;
