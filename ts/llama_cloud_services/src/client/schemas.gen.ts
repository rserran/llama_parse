// This file is auto-generated by @hey-api/openapi-ts

export const AdvancedModeTransformConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "advanced",
      title: "Mode",
      default: "advanced",
    },
    segmentation_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/NoneSegmentationConfig",
        },
        {
          $ref: "#/components/schemas/PageSegmentationConfig",
        },
        {
          $ref: "#/components/schemas/ElementSegmentationConfig",
        },
      ],
      title: "Segmentation Config",
      description: "Configuration for the segmentation.",
    },
    chunking_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/NoneChunkingConfig",
        },
        {
          $ref: "#/components/schemas/CharacterChunkingConfig",
        },
        {
          $ref: "#/components/schemas/TokenChunkingConfig",
        },
        {
          $ref: "#/components/schemas/SentenceChunkingConfig",
        },
        {
          $ref: "#/components/schemas/SemanticChunkingConfig",
        },
      ],
      title: "Chunking Config",
      description: "Configuration for the chunking.",
    },
  },
  type: "object",
  title: "AdvancedModeTransformConfig",
} as const;

export const AgentDataSchema = {
  properties: {
    id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Id",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
    },
    collection: {
      type: "string",
      title: "Collection",
      default: "default",
    },
    data: {
      additionalProperties: true,
      type: "object",
      title: "Data",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
    },
  },
  type: "object",
  required: ["deployment_name", "data"],
  title: "AgentData",
  description: "API Result for a single agent data item",
} as const;

export const AgentDataCreateSchema = {
  properties: {
    deployment_name: {
      type: "string",
      title: "Deployment Name",
    },
    collection: {
      type: "string",
      title: "Collection",
      default: "default",
    },
    data: {
      additionalProperties: true,
      type: "object",
      title: "Data",
    },
  },
  type: "object",
  required: ["deployment_name", "data"],
  title: "AgentDataCreate",
  description: "API request model for creating agent data",
} as const;

export const AgentDataUpdateSchema = {
  properties: {
    data: {
      additionalProperties: true,
      type: "object",
      title: "Data",
    },
  },
  type: "object",
  required: ["data"],
  title: "AgentDataUpdate",
  description: "API request model for updating agent data",
} as const;

export const AggregateGroupSchema = {
  properties: {
    group_key: {
      additionalProperties: true,
      type: "object",
      title: "Group Key",
    },
    count: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Count",
    },
    first_item: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "First Item",
    },
  },
  type: "object",
  required: ["group_key"],
  title: "AggregateGroup",
  description: "API Result for a single group in the aggregate response",
} as const;

export const AggregateRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          additionalProperties: {
            $ref: "#/components/schemas/FilterOperation",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filter",
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "The agent deployment's name to aggregate data for",
    },
    collection: {
      type: "string",
      title: "Collection",
      description: "The logical agent data collection to aggregate data for",
      default: "default",
    },
    group_by: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Group By",
      description:
        "The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations",
    },
    count: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Count",
      description: "Whether to count the number of items in each group",
      default: false,
    },
    first: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "First",
      description:
        "Whether to return the first item in each group (Sorted by created_at)",
      default: false,
    },
    offset: {
      anyOf: [
        {
          type: "integer",
          maximum: 1000,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Offset",
      description:
        "The offset to start from. If not provided, the first page is returned",
      default: 0,
    },
  },
  type: "object",
  required: ["deployment_name"],
  title: "AggregateRequest",
  description: "API request body for aggregating agent data",
} as const;

export const ApplyStatusDetailsSchema = {
  properties: {
    status: {
      type: "string",
      enum: ["pending", "processing", "completed", "failed"],
      title: "Status",
      description: "Status of the apply process (file updates and deletions)",
      default: "pending",
    },
    effective_at: {
      type: "string",
      format: "date-time",
      title: "Effective At",
    },
    job_record_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Record Id",
      description: "The job record ID associated with this status, if any.",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message for the latest job attempt, if any.",
    },
  },
  type: "object",
  title: "ApplyStatusDetails",
} as const;

export const AutoTransformConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "auto",
      title: "Mode",
      default: "auto",
    },
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      description: "Chunk size for the transformation.",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      description: "Chunk overlap for the transformation.",
      default: 200,
      gte: 0,
    },
  },
  type: "object",
  title: "AutoTransformConfig",
} as const;

export const AzureOpenAIEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The name of the OpenAI embedding model.",
      default: "text-embedding-ada-002",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the OpenAI API.",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "The OpenAI API key.",
    },
    api_base: {
      type: "string",
      title: "Api Base",
      description: "The base URL for Azure deployment.",
      default: "",
    },
    api_version: {
      type: "string",
      title: "Api Version",
      description: "The version for Azure OpenAI API.",
      default: "",
    },
    max_retries: {
      type: "integer",
      title: "Max Retries",
      description: "Maximum number of retries.",
      default: 10,
      gte: 0,
    },
    timeout: {
      type: "number",
      title: "Timeout",
      description: "Timeout for each request.",
      default: 60,
      gte: 0,
    },
    default_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Default Headers",
      description: "The default headers for API requests.",
    },
    reuse_client: {
      type: "boolean",
      title: "Reuse Client",
      description:
        "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
      default: true,
    },
    dimensions: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Dimensions",
      description:
        "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.",
    },
    azure_endpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Endpoint",
      description: "The Azure endpoint to use.",
    },
    azure_deployment: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Deployment",
      description: "The Azure deployment to use.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "AzureOpenAIEmbedding",
    },
  },
  type: "object",
  title: "AzureOpenAIEmbedding",
} as const;

export const AzureOpenAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "AZURE_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "AZURE_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/AzureOpenAIEmbedding",
      description: "Configuration for the Azure OpenAI embedding model.",
    },
  },
  type: "object",
  title: "AzureOpenAIEmbeddingConfig",
} as const;

export const BatchFileStatusSchema = {
  type: "string",
  enum: [
    "pending",
    "processing",
    "completed",
    "failed",
    "skipped",
    "cancelled",
  ],
  title: "BatchFileStatus",
  description: "Status of an individual file in a batch job.",
} as const;

export const BatchItemDetailSchema = {
  properties: {
    status: {
      $ref: "#/components/schemas/BatchFileStatus",
      description: "Processing status of this item",
    },
    effective_at: {
      type: "string",
      format: "date-time",
      title: "Effective At",
    },
    job_record_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Record Id",
      description: "The job record ID associated with this status, if any.",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message for the latest job attempt, if any.",
    },
    item_id: {
      type: "string",
      title: "Item Id",
      description: "ID of the item",
    },
    item_name: {
      type: "string",
      title: "Item Name",
      description: "Name of the item",
    },
    job_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Id",
      description:
        "Job ID for the underlying processing job (links to parse/extract job results)",
    },
    skip_reason: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Skip Reason",
      description:
        "Reason item was skipped (e.g., 'already_processed', 'size_limit_exceeded')",
    },
    started_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Started At",
      description: "When processing started for this item",
    },
    completed_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Completed At",
      description: "When processing completed for this item",
    },
  },
  type: "object",
  required: ["status", "item_id", "item_name"],
  title: "BatchItemDetail",
  description: "Detailed information about an item in a batch job.",
} as const;

export const BatchItemListResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/BatchItemDetail",
      },
      type: "array",
      title: "Items",
      description: "List of item details",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  title: "BatchItemListResponse",
  description: "Paginated response containing batch job item details.",
} as const;

export const BatchJobCancelRequestSchema = {
  properties: {
    reason: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Reason",
      description: "Optional reason for cancelling the job",
    },
  },
  type: "object",
  title: "BatchJobCancelRequest",
  description: "Request to cancel a running batch job.",
} as const;

export const BatchJobCancelResponseSchema = {
  properties: {
    job_id: {
      type: "string",
      title: "Job Id",
      description: "ID of the cancelled job",
    },
    status: {
      $ref: "#/components/schemas/BatchJobStatus",
      description: "New status (should be 'cancelled')",
    },
    processed_items: {
      type: "integer",
      title: "Processed Items",
      description: "Number of items processed before cancellation",
    },
    message: {
      type: "string",
      title: "Message",
      description: "Confirmation message",
    },
  },
  type: "object",
  required: ["job_id", "status", "processed_items", "message"],
  title: "BatchJobCancelResponse",
  description: "Response after cancelling a batch job.",
} as const;

export const BatchJobCreateRequestSchema = {
  properties: {
    directory_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Directory Id",
      description: "ID of the directory containing files to process",
    },
    item_ids: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Item Ids",
      description:
        "List of specific item IDs to process. Either this or directory_id must be provided.",
    },
    job_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/BatchParseJobRecordCreate",
        },
        {
          $ref: "#/components/schemas/ClassifyJob",
        },
      ],
      title: "Job Config",
      description:
        "Job configuration for batch processing. Can be BatchParseJobRecordCreate or ClassifyJob.",
    },
    page_size: {
      type: "integer",
      maximum: 1000,
      minimum: 1,
      title: "Page Size",
      description:
        "Number of files to fetch per batch from the directory (only used in directory mode)",
      default: 100,
    },
    continue_as_new_threshold: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Continue As New Threshold",
      description:
        "Maximum number of files to process before calling continue-as-new. If None, continue-as-new is called after every batch. (only used in directory mode)",
    },
  },
  type: "object",
  required: ["job_config"],
  title: "BatchJobCreateRequest",
  description: `Request to create a batch processing job.

Supports two modes:
1. Directory mode: Process all files in a directory (use directory_id)
2. Item list mode: Process specific items (use item_ids). Project must be provided via validate_project dependency.`,
} as const;

export const BatchJobQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/BatchJobResponse",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "BatchJobQueryResponse",
  description: "Response schema for paginated batch job queries.",
} as const;

export const BatchJobResponseSchema = {
  properties: {
    status: {
      $ref: "#/components/schemas/BatchJobStatus",
      description: "Current status of the job",
    },
    effective_at: {
      type: "string",
      format: "date-time",
      title: "Effective At",
    },
    job_record_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Record Id",
      description: "The job record ID associated with this status, if any.",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message for the latest job attempt, if any.",
    },
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the batch job",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "Project this job belongs to",
    },
    directory_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Directory Id",
      description: "Directory being processed",
    },
    job_type: {
      $ref: "#/components/schemas/BatchJobType",
      description: "Type of processing operation",
    },
    total_items: {
      type: "integer",
      title: "Total Items",
      description: "Total number of items in the job",
    },
    processed_items: {
      type: "integer",
      title: "Processed Items",
      description: "Number of items processed so far",
      default: 0,
    },
    failed_items: {
      type: "integer",
      title: "Failed Items",
      description: "Number of items that failed processing",
      default: 0,
    },
    skipped_items: {
      type: "integer",
      title: "Skipped Items",
      description: "Number of items skipped (already processed or size limit)",
      default: 0,
    },
    workflow_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Workflow Id",
      description: "Temporal workflow ID for this batch job",
    },
    started_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Started At",
      description: "Timestamp when job processing started",
    },
    completed_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Completed At",
      description: "Timestamp when job completed",
    },
  },
  type: "object",
  required: ["status", "id", "project_id", "job_type", "total_items"],
  title: "BatchJobResponse",
  description: "Response schema for a batch processing job.",
} as const;

export const BatchJobStatusSchema = {
  type: "string",
  enum: [
    "pending",
    "running",
    "dispatched",
    "completed",
    "failed",
    "cancelled",
  ],
  title: "BatchJobStatus",
  description: "Status of a batch processing job.",
} as const;

export const BatchJobStatusResponseSchema = {
  properties: {
    job: {
      $ref: "#/components/schemas/BatchJobResponse",
    },
    progress_percentage: {
      type: "number",
      maximum: 100,
      minimum: 0,
      title: "Progress Percentage",
      description: "Percentage of items processed (0-100)",
    },
  },
  type: "object",
  required: ["job", "progress_percentage"],
  title: "BatchJobStatusResponse",
  description: "Detailed status response for a batch processing job.",
} as const;

export const BatchJobTypeSchema = {
  type: "string",
  enum: ["parse", "extract", "classify"],
  title: "BatchJobType",
  description: "Type of batch processing operation.",
} as const;

export const BatchParseJobConfigSchema = {
  properties: {
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the documents.",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "The resource info about the file",
    },
    languages: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      minItems: 1,
      title: "Languages",
    },
    parsing_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsing Instruction",
      default: "",
    },
    disable_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Ocr",
      default: false,
    },
    annotate_links: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Annotate Links",
      default: false,
    },
    adaptive_long_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Adaptive Long Table",
      default: false,
    },
    compact_markdown_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Compact Markdown Table",
      default: false,
    },
    disable_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Image Extraction",
      default: false,
    },
    invalidate_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Invalidate Cache",
      default: false,
    },
    outlined_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Outlined Table Extraction",
      default: false,
    },
    aggressive_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Aggressive Table Extraction",
      default: false,
    },
    merge_tables_across_pages_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    output_pdf_of_document: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Pdf Of Document",
      default: false,
    },
    do_not_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Cache",
      default: false,
    },
    fast_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fast Mode",
      default: false,
    },
    skip_diagonal_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Skip Diagonal Text",
      default: false,
    },
    preserve_layout_alignment_across_pages: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Very Small Text",
      default: false,
    },
    gpt4o_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Api Key",
    },
    do_not_unroll_columns: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_layout: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Layout",
      default: false,
    },
    high_res_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Precise Bounding Box",
      default: false,
    },
    line_level_bounding_box: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Line Level Bounding Box",
      default: false,
    },
    html_remove_navigation_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Navigation Elements",
      default: false,
    },
    html_remove_fixed_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Fixed Elements",
      default: false,
    },
    guess_xlsx_sheet_name: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    page_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Separator",
    },
    bounding_box: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Bounding Box",
    },
    bbox_top: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Top",
    },
    bbox_right: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Right",
    },
    bbox_bottom: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Bottom",
    },
    bbox_left: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Left",
    },
    target_pages: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
    },
    use_vendor_multimodal_model: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    vendor_multimodal_model_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Model Name",
    },
    model: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model",
    },
    vendor_multimodal_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Api Key",
    },
    page_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Prefix",
    },
    page_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Suffix",
    },
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
    },
    preset: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Preset",
    },
    take_screenshot: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Take Screenshot",
      default: false,
    },
    is_formatting_instruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Is Formatting Instruction",
      default: true,
    },
    premium_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Premium Mode",
      default: false,
    },
    continuous_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Continuous Mode",
      default: false,
    },
    input_s3_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Path",
    },
    input_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Region",
      description: "The region for the input S3 bucket.",
    },
    output_s3_path_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Path Prefix",
      description:
        "If specified, llamaParse will save the output to the specified path. All output file will use this 'prefix' should be a valid s3:// url",
    },
    output_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Region",
      description: "The region for the output S3 bucket.",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
    },
    azure_openai_deployment_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Endpoint",
    },
    azure_openai_api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Api Version",
    },
    azure_openai_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Key",
    },
    input_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input Url",
    },
    http_proxy: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Http Proxy",
    },
    auto_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_regexp_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_trigger_on_text_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_table_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_configuration_json: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Configuration Json",
    },
    structured_output: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema Name",
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    max_pages_enforced: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages Enforced",
    },
    extract_charts: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Charts",
      default: false,
    },
    formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Formatting Instruction",
    },
    complemental_formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Content Guideline Instruction",
    },
    spreadsheet_extract_sub_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Extract Sub Tables",
      default: false,
    },
    spreadsheet_force_formula_computation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Inline Images In Markdown",
      default: false,
    },
    job_timeout_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Save Images",
      default: true,
    },
    hide_headers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Suffix",
    },
    keep_page_separator_when_merging_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Keep Page Separator When Merging Tables",
      default: false,
    },
    ignore_document_elements_for_layout_detection: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    output_tables_as_HTML: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Tables As Html",
      default: false,
    },
    internal_is_screenshot_job: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Internal Is Screenshot Job",
      default: false,
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
    },
    system_prompt_append: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt Append",
    },
    user_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Prompt",
    },
    page_error_tolerance: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
      default: "raw_text",
    },
    replace_failed_page_with_error_message_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Prefix",
    },
    replace_failed_page_with_error_message_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Suffix",
    },
    markdown_table_multiline_header_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Markdown Table Multiline Header Separator",
    },
    tier: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Tier",
    },
    version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Version",
    },
    extract_printed_page_number: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Printed Page Number",
      default: false,
    },
    type: {
      type: "string",
      const: "parse",
      title: "Type",
      default: "parse",
    },
    lang: {
      type: "string",
      title: "Lang",
      description: "The language.",
      default: "en",
    },
    outputBucket: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Outputbucket",
      description: "The output bucket.",
    },
    pipeline_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline Id",
      description: "The pipeline ID.",
    },
  },
  type: "object",
  title: "BatchParseJobConfig",
  description: `Generic parse job configuration for batch processing.

This model contains the parsing configuration that applies to all files
in a batch, but excludes file-specific fields like file_name, file_id, etc.
Those file-specific fields are populated from DirectoryFile data when
creating individual ParseJobRecordCreate instances for each file.

The fields in this model should be generic settings that apply uniformly
to all files being processed in the batch.`,
} as const;

export const BatchParseJobRecordCreateSchema = {
  properties: {
    job_name: {
      type: "string",
      const: "parse_raw_file_job",
      title: "Job Name",
      default: "parse_raw_file_job",
    },
    partitions: {
      additionalProperties: {
        anyOf: [
          {
            type: "string",
            format: "uuid",
          },
          {
            type: "string",
          },
        ],
      },
      propertyNames: {
        $ref: "#/components/schemas/PartitionNames",
      },
      type: "object",
      title: "Partitions",
      description:
        "The partitions for this execution. Used for determining where to save job output.",
    },
    parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/BatchParseJobConfig",
        },
        {
          type: "null",
        },
      ],
      description:
        "The generic parse configuration for all files in the batch.",
    },
    session_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Session Id",
      description:
        "The upstream request ID that created this job. Used for tracking the job across services.",
    },
    correlation_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Correlation Id",
      description:
        "The correlation ID for this job. Used for tracking the job across services.",
    },
    parent_job_execution_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Parent Job Execution Id",
      description: "The ID of the parent job execution.",
    },
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "The ID of the user that created this job",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "The ID of the project this job belongs to.",
    },
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
      description:
        "The URL that needs to be called at the end of the parsing job.",
    },
  },
  type: "object",
  title: "BatchParseJobRecordCreate",
  description: `Batch-specific parse job record for batch processing.

This model contains the metadata and configuration for a batch parse job,
but excludes file-specific information. It's used as input to the batch
parent workflow and combined with DirectoryFile data to create full
ParseJobRecordCreate instances for each file.

Attributes:
    job_name: Must be PARSE_RAW_FILE
    partitions: Partitions for job output location
    parameters: Generic parse configuration (BatchParseJobConfig)
    session_id: Upstream request ID for tracking
    correlation_id: Correlation ID for cross-service tracking
    parent_job_execution_id: Parent job execution ID if nested
    user_id: User who created the job
    project_id: Project this job belongs to
    webhook_url: Optional webhook URL for job completion notifications`,
} as const;

export const BedrockEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the Bedrock model to use.",
      default: "amazon.titan-embed-text-v1",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    profile_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Profile Name",
      description:
        "The name of aws profile to use. If not given, then the default profile is used.",
    },
    aws_access_key_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Access Key Id",
      description: "AWS Access Key ID to use",
    },
    aws_secret_access_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Secret Access Key",
      description: "AWS Secret Access Key to use",
    },
    aws_session_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Session Token",
      description: "AWS Session Token to use",
    },
    region_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Region Name",
      description:
        "AWS region name to use. Uses region configured in AWS CLI if not passed",
    },
    max_retries: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Max Retries",
      description: "The maximum number of API retries.",
      default: 10,
    },
    timeout: {
      type: "number",
      title: "Timeout",
      description:
        "The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.",
      default: 60,
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the bedrock client.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "BedrockEmbedding",
    },
  },
  type: "object",
  title: "BedrockEmbedding",
} as const;

export const BedrockEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "BEDROCK_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "BEDROCK_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/BedrockEmbedding",
      description: "Configuration for the Bedrock embedding model.",
    },
  },
  type: "object",
  title: "BedrockEmbeddingConfig",
} as const;

export const Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema =
  {
    properties: {
      upload_file: {
        type: "string",
        format: "binary",
        title: "Upload File",
      },
    },
    type: "object",
    required: ["upload_file"],
    title:
      "Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put",
  } as const;

export const Body_run_job_on_file_api_v1_extraction_jobs_file_postSchema = {
  properties: {
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    file: {
      type: "string",
      format: "binary",
      title: "File",
      description: "The file to run the job on",
    },
    data_schema_override: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema Override",
      description:
        "The data schema to override the extraction agent's data schema with as a JSON string",
    },
    config_override: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Config Override",
      description:
        "The config to override the extraction agent's config with as a JSON string",
    },
  },
  type: "object",
  required: ["extraction_agent_id", "file"],
  title: "Body_run_job_on_file_api_v1_extraction_jobs_file_post",
} as const;

export const Body_screenshot_api_v1_parsing_screenshot_postSchema = {
  properties: {
    file: {
      anyOf: [
        {
          type: "string",
          format: "binary",
        },
        {
          type: "null",
        },
      ],
      title: "File",
    },
    do_not_cache: {
      type: "boolean",
      title: "Do Not Cache",
      default: false,
    },
    http_proxy: {
      type: "string",
      title: "Http Proxy",
    },
    input_s3_path: {
      type: "string",
      title: "Input S3 Path",
      default: "",
    },
    input_s3_region: {
      type: "string",
      title: "Input S3 Region",
      default: "",
    },
    input_url: {
      type: "string",
      title: "Input Url",
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      default: false,
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    output_s3_path_prefix: {
      type: "string",
      title: "Output S3 Path Prefix",
      default: "",
    },
    output_s3_region: {
      type: "string",
      title: "Output S3 Region",
      default: "",
    },
    target_pages: {
      type: "string",
      title: "Target Pages",
      default: "",
    },
    webhook_url: {
      type: "string",
      title: "Webhook Url",
      default: "",
    },
    webhook_configurations: {
      type: "string",
      title: "Webhook Configurations",
      default: "",
    },
    job_timeout_in_seconds: {
      type: "number",
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      type: "number",
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
  },
  type: "object",
  title: "Body_screenshot_api_v1_parsing_screenshot_post",
} as const;

export const Body_upload_file_api_v1_files_postSchema = {
  properties: {
    upload_file: {
      type: "string",
      format: "binary",
      title: "Upload File",
    },
  },
  type: "object",
  required: ["upload_file"],
  title: "Body_upload_file_api_v1_files_post",
} as const;

export const Body_upload_file_api_v1_parsing_upload_postSchema = {
  properties: {
    file: {
      anyOf: [
        {
          type: "string",
          format: "binary",
        },
        {
          type: "null",
        },
      ],
      title: "File",
    },
    adaptive_long_table: {
      type: "boolean",
      title: "Adaptive Long Table",
      default: false,
    },
    annotate_links: {
      type: "boolean",
      title: "Annotate Links",
      default: false,
    },
    auto_mode: {
      type: "boolean",
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      type: "boolean",
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_trigger_on_table_in_page: {
      type: "boolean",
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_text_in_page: {
      type: "string",
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_regexp_in_page: {
      type: "string",
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_configuration_json: {
      type: "string",
      title: "Auto Mode Configuration Json",
    },
    azure_openai_api_version: {
      type: "string",
      title: "Azure Openai Api Version",
    },
    azure_openai_deployment_name: {
      type: "string",
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      type: "string",
      title: "Azure Openai Endpoint",
    },
    azure_openai_key: {
      type: "string",
      title: "Azure Openai Key",
    },
    bbox_bottom: {
      type: "number",
      title: "Bbox Bottom",
    },
    bbox_left: {
      type: "number",
      title: "Bbox Left",
    },
    bbox_right: {
      type: "number",
      title: "Bbox Right",
    },
    bbox_top: {
      type: "number",
      title: "Bbox Top",
    },
    compact_markdown_table: {
      type: "boolean",
      title: "Compact Markdown Table",
      default: false,
    },
    disable_ocr: {
      type: "boolean",
      title: "Disable Ocr",
      default: false,
    },
    disable_reconstruction: {
      type: "boolean",
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      type: "boolean",
      title: "Disable Image Extraction",
      default: false,
    },
    do_not_cache: {
      type: "boolean",
      title: "Do Not Cache",
      default: false,
    },
    do_not_unroll_columns: {
      type: "boolean",
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_charts: {
      type: "boolean",
      title: "Extract Charts",
      default: false,
    },
    guess_xlsx_sheet_name: {
      type: "boolean",
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    high_res_ocr: {
      type: "boolean",
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      type: "boolean",
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      type: "boolean",
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      type: "boolean",
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      type: "boolean",
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      type: "boolean",
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      type: "boolean",
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      type: "boolean",
      title: "Precise Bounding Box",
      default: false,
    },
    line_level_bounding_box: {
      type: "boolean",
      title: "Line Level Bounding Box",
      default: false,
    },
    html_remove_fixed_elements: {
      type: "boolean",
      title: "Html Remove Fixed Elements",
      default: false,
    },
    html_remove_navigation_elements: {
      type: "boolean",
      title: "Html Remove Navigation Elements",
      default: false,
    },
    http_proxy: {
      type: "string",
      title: "Http Proxy",
    },
    input_s3_path: {
      type: "string",
      title: "Input S3 Path",
      default: "",
    },
    input_s3_region: {
      type: "string",
      title: "Input S3 Region",
      default: "",
    },
    input_url: {
      type: "string",
      title: "Input Url",
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      default: false,
    },
    language: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      title: "Language",
      default: ["en"],
    },
    extract_layout: {
      type: "boolean",
      title: "Extract Layout",
      default: false,
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    merge_tables_across_pages_in_markdown: {
      type: "boolean",
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    outlined_table_extraction: {
      type: "boolean",
      title: "Outlined Table Extraction",
      default: false,
    },
    aggressive_table_extraction: {
      type: "boolean",
      title: "Aggressive Table Extraction",
      default: false,
    },
    output_pdf_of_document: {
      type: "boolean",
      title: "Output Pdf Of Document",
      default: false,
    },
    output_s3_path_prefix: {
      type: "string",
      title: "Output S3 Path Prefix",
      default: "",
    },
    output_s3_region: {
      type: "string",
      title: "Output S3 Region",
      default: "",
    },
    page_prefix: {
      type: "string",
      title: "Page Prefix",
      default: "",
    },
    page_separator: {
      type: "string",
      title: "Page Separator",
    },
    page_suffix: {
      type: "string",
      title: "Page Suffix",
      default: "",
    },
    preserve_layout_alignment_across_pages: {
      type: "boolean",
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      type: "boolean",
      title: "Preserve Very Small Text",
      default: false,
    },
    skip_diagonal_text: {
      type: "boolean",
      title: "Skip Diagonal Text",
      default: false,
    },
    spreadsheet_extract_sub_tables: {
      type: "boolean",
      title: "Spreadsheet Extract Sub Tables",
      default: true,
    },
    spreadsheet_force_formula_computation: {
      type: "boolean",
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      type: "boolean",
      title: "Inline Images In Markdown",
      default: false,
    },
    structured_output: {
      type: "boolean",
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      type: "string",
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      type: "string",
      title: "Structured Output Json Schema Name",
    },
    take_screenshot: {
      type: "boolean",
      title: "Take Screenshot",
      default: false,
    },
    target_pages: {
      type: "string",
      title: "Target Pages",
      default: "",
    },
    vendor_multimodal_api_key: {
      type: "string",
      title: "Vendor Multimodal Api Key",
      default: "",
    },
    vendor_multimodal_model_name: {
      type: "string",
      title: "Vendor Multimodal Model Name",
    },
    model: {
      type: "string",
      title: "Model",
    },
    webhook_url: {
      type: "string",
      title: "Webhook Url",
      default: "",
    },
    webhook_configurations: {
      type: "string",
      title: "Webhook Configurations",
      default: "",
    },
    preset: {
      type: "string",
      title: "Preset",
      default: "",
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    page_error_tolerance: {
      type: "number",
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
    },
    replace_failed_page_with_error_message_prefix: {
      type: "string",
      title: "Replace Failed Page With Error Message Prefix",
      default: "",
    },
    replace_failed_page_with_error_message_suffix: {
      type: "string",
      title: "Replace Failed Page With Error Message Suffix",
      default: "",
    },
    system_prompt: {
      type: "string",
      title: "System Prompt",
      default: "",
    },
    system_prompt_append: {
      type: "string",
      title: "System Prompt Append",
      default: "",
    },
    user_prompt: {
      type: "string",
      title: "User Prompt",
      default: "",
    },
    job_timeout_in_seconds: {
      type: "number",
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      type: "number",
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      type: "boolean",
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      type: "boolean",
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      type: "boolean",
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      type: "boolean",
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      type: "boolean",
      title: "Save Images",
      default: true,
    },
    ignore_document_elements_for_layout_detection: {
      type: "boolean",
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    keep_page_separator_when_merging_tables: {
      type: "boolean",
      title: "Keep Page Separator When Merging Tables",
      default: false,
    },
    output_tables_as_HTML: {
      type: "boolean",
      title: "Output Tables As Html",
      default: false,
    },
    markdown_table_multiline_header_separator: {
      type: "string",
      title: "Markdown Table Multiline Header Separator",
    },
    use_vendor_multimodal_model: {
      type: "boolean",
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    bounding_box: {
      type: "string",
      title: "Bounding Box",
      default: "",
    },
    gpt4o_mode: {
      type: "boolean",
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      type: "string",
      title: "Gpt4O Api Key",
      default: "",
    },
    complemental_formatting_instruction: {
      type: "string",
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      type: "string",
      title: "Content Guideline Instruction",
    },
    premium_mode: {
      type: "boolean",
      title: "Premium Mode",
      default: false,
    },
    is_formatting_instruction: {
      type: "boolean",
      title: "Is Formatting Instruction",
      default: true,
    },
    continuous_mode: {
      type: "boolean",
      title: "Continuous Mode",
      default: false,
    },
    parsing_instruction: {
      type: "string",
      title: "Parsing Instruction",
      default: "",
    },
    fast_mode: {
      type: "boolean",
      title: "Fast Mode",
      default: false,
    },
    formatting_instruction: {
      type: "string",
      title: "Formatting Instruction",
    },
    hide_headers: {
      type: "boolean",
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      type: "boolean",
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      type: "string",
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      type: "string",
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      type: "string",
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      type: "string",
      title: "Page Footer Suffix",
    },
    remove_hidden_text: {
      type: "boolean",
      title: "Remove Hidden Text",
      default: false,
    },
    presentation_out_of_bounds_content: {
      type: "boolean",
      title: "Presentation Out Of Bounds Content",
      default: false,
    },
    extract_printed_page_number: {
      type: "boolean",
      title: "Extract Printed Page Number",
      default: false,
    },
    tier: {
      type: "string",
      title: "Tier",
    },
    version: {
      type: "string",
      title: "Version",
    },
  },
  type: "object",
  title: "Body_upload_file_api_v1_parsing_upload_post",
} as const;

export const Body_upload_file_to_directory_api_v1_beta_directories__directory_id__files_upload_postSchema =
  {
    properties: {
      upload_file: {
        type: "string",
        format: "binary",
        title: "Upload File",
      },
      unique_id: {
        anyOf: [
          {
            type: "string",
          },
          {
            type: "null",
          },
        ],
        title: "Unique Id",
      },
      display_name: {
        anyOf: [
          {
            type: "string",
          },
          {
            type: "null",
          },
        ],
        title: "Display Name",
      },
      external_file_id: {
        anyOf: [
          {
            type: "string",
          },
          {
            type: "null",
          },
        ],
        title: "External File Id",
      },
    },
    type: "object",
    required: ["upload_file"],
    title:
      "Body_upload_file_to_directory_api_v1_beta_directories__directory_id__files_upload_post",
  } as const;

export const BoxAuthMechanismSchema = {
  type: "string",
  enum: ["developer_token", "ccg"],
  title: "BoxAuthMechanism",
} as const;

export const CharacterChunkingConfigSchema = {
  properties: {
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      default: 200,
      gte: 0,
    },
    mode: {
      type: "string",
      const: "character",
      title: "Mode",
      default: "character",
    },
  },
  type: "object",
  title: "CharacterChunkingConfig",
} as const;

export const ChatDataSchema = {
  properties: {
    retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
    },
    llm_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LLMParameters",
        },
        {
          type: "null",
        },
      ],
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "ChatData",
} as const;

export const ChatInputParamsSchema = {
  properties: {
    messages: {
      items: {
        $ref: "#/components/schemas/InputMessage",
      },
      type: "array",
      minItems: 1,
      title: "Messages",
    },
    data: {
      $ref: "#/components/schemas/ChatData",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "ChatInputParams",
} as const;

export const ChatMessageSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
    },
    index: {
      type: "integer",
      title: "Index",
      description: "The index of the message in the chat.",
    },
    annotations: {
      items: {
        $ref: "#/components/schemas/MessageAnnotation",
      },
      type: "array",
      title: "Annotations",
      description: "Retrieval annotations for the message.",
    },
    role: {
      $ref: "#/components/schemas/MessageRole",
      description: "The role of the message.",
    },
    content: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Content",
      description: "Text content of the generation",
    },
    additional_kwargs: {
      additionalProperties: {
        type: "string",
      },
      type: "object",
      title: "Additional Kwargs",
      description: "Additional arguments passed to the model",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["id", "index", "role"],
  title: "ChatMessage",
} as const;

export const ClassificationResultSchema = {
  properties: {
    reasoning: {
      type: "string",
      title: "Reasoning",
      description:
        "Step-by-step explanation of why this classification was chosen and the confidence score assigned",
    },
    confidence: {
      type: "number",
      maximum: 1,
      minimum: 0,
      title: "Confidence",
      description: "Confidence score of the classification (0.0-1.0)",
    },
    type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Type",
      description: "The document type that best matches, or null if no match.",
    },
  },
  type: "object",
  required: ["reasoning", "confidence", "type"],
  title: "ClassificationResult",
  description: "Result of classifying a single file.",
} as const;

export const ClassifierRuleSchema = {
  properties: {
    type: {
      type: "string",
      maxLength: 50,
      minLength: 1,
      title: "Type",
      description:
        "The document type to assign when this rule matches (e.g., 'invoice', 'receipt', 'contract')",
      examples: ["invoice", "receipt", "contract", "report", "proposal"],
    },
    description: {
      type: "string",
      maxLength: 500,
      minLength: 10,
      title: "Description",
      description:
        "Natural language description of what to classify. Be specific about the content characteristics that identify this document type.",
      examples: [
        "contains invoice number, line items, and total amount",
        "purchase receipt with transaction info and merchant details",
        "legal contract with terms, conditions, and signatures",
      ],
    },
  },
  type: "object",
  required: ["type", "description"],
  title: "ClassifierRule",
  description: `A rule for classifying documents - v0 simplified version.

This represents a single classification rule that will be applied to documents.
All rules are content-based and use natural language descriptions.`,
} as const;

export const ClassifyJobSchema = {
  properties: {
    status: {
      $ref: "#/components/schemas/StatusEnum",
      description: "The status of the classify job",
    },
    effective_at: {
      type: "string",
      format: "date-time",
      title: "Effective At",
    },
    job_record_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Record Id",
      description: "The job record ID associated with this status, if any.",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message for the latest job attempt, if any.",
    },
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    rules: {
      items: {
        $ref: "#/components/schemas/ClassifierRule",
      },
      type: "array",
      minItems: 1,
      title: "Rules",
      description: "The rules to classify the files",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The ID of the user",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project",
    },
    parsing_configuration: {
      $ref: "#/components/schemas/ClassifyParsingConfiguration",
      description: "The configuration for the parsing job",
      default: {
        lang: "en",
        max_pages: 5,
      },
    },
  },
  type: "object",
  required: ["status", "id", "rules", "user_id", "project_id"],
  title: "ClassifyJob",
  description: "A classify job.",
} as const;

export const ClassifyJobCreateSchema = {
  properties: {
    rules: {
      items: {
        $ref: "#/components/schemas/ClassifierRule",
      },
      type: "array",
      minItems: 1,
      title: "Rules",
      description: "The rules to classify the files",
    },
    file_ids: {
      items: {
        type: "string",
        format: "uuid",
      },
      type: "array",
      maxItems: 500,
      minItems: 1,
      title: "File Ids",
      description: "The IDs of the files to classify",
    },
    parsing_configuration: {
      $ref: "#/components/schemas/ClassifyParsingConfiguration",
      description: "The configuration for the parsing job",
      default: {
        lang: "en",
        max_pages: 5,
      },
    },
  },
  type: "object",
  required: ["rules", "file_ids"],
  title: "ClassifyJobCreate",
  description: "A classify job.",
} as const;

export const ClassifyJobResultsSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/FileClassification",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "ClassifyJobResults",
  description:
    "Response model for the classify endpoint following AIP-132 pagination standard.",
} as const;

export const ClassifyParsingConfigurationSchema = {
  properties: {
    lang: {
      $ref: "#/components/schemas/ParserLanguages",
      description: "The language to parse the files in",
      default: "en",
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
      description: "The maximum number of pages to parse",
      default: 5,
    },
    target_pages: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
          minItems: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
      description:
        "The pages to target for parsing (0-indexed, so first page is at 0)",
    },
  },
  type: "object",
  title: "ClassifyParsingConfiguration",
  description: "Parsing configuration for a classify job.",
} as const;

export const CloudAstraDBVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    token: {
      type: "string",
      format: "password",
      title: "Token",
      description: "The Astra DB Application Token to use",
      writeOnly: true,
    },
    api_endpoint: {
      type: "string",
      title: "Api Endpoint",
      description: "The Astra DB JSON API endpoint for your database",
    },
    collection_name: {
      type: "string",
      title: "Collection Name",
      description:
        "Collection name to use. If not existing, it will be created",
    },
    embedding_dimension: {
      type: "integer",
      title: "Embedding Dimension",
      description: "Length of the embedding vectors in use",
    },
    keyspace: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Keyspace",
      description: "The keyspace to use. If not provided, 'default_keyspace'",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudAstraDBVectorStore",
    },
  },
  type: "object",
  required: ["token", "api_endpoint", "collection_name", "embedding_dimension"],
  title: "CloudAstraDBVectorStore",
  description: `Cloud AstraDB Vector Store.

This class is used to store the configuration for an AstraDB vector store, so that it can be
created and used in LlamaCloud.

Args:
    token (str): The Astra DB Application Token to use.
    api_endpoint (str): The Astra DB JSON API endpoint for your database.
    collection_name (str): Collection name to use. If not existing, it will be created.
    embedding_dimension (int): Length of the embedding vectors in use.
    keyspace (optional[str]): The keyspace to use. If not provided, 'default_keyspace'`,
} as const;

export const CloudAzStorageBlobDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    container_name: {
      type: "string",
      title: "Container Name",
      description: "The name of the Azure Storage Blob container to read from.",
    },
    account_url: {
      type: "string",
      title: "Account Url",
      description:
        "The Azure Storage Blob account URL to use for authentication.",
    },
    blob: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Blob",
      description: "The blob name to read from.",
    },
    prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Prefix",
      description: "The prefix of the Azure Storage Blob objects to read from.",
    },
    account_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Account Name",
      description:
        "The Azure Storage Blob account name to use for authentication.",
    },
    account_key: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Account Key",
      description:
        "The Azure Storage Blob account key to use for authentication.",
    },
    tenant_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Tenant Id",
      description: "The Azure AD tenant ID to use for authentication.",
    },
    client_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Id",
      description: "The Azure AD client ID to use for authentication.",
    },
    client_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Client Secret",
      description: "The Azure AD client secret to use for authentication.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudAzStorageBlobDataSource",
    },
  },
  type: "object",
  required: ["container_name", "account_url"],
  title: "CloudAzStorageBlobDataSource",
} as const;

export const CloudAzureAISearchVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    search_service_api_key: {
      type: "string",
      format: "password",
      title: "Search Service Api Key",
      writeOnly: true,
    },
    search_service_endpoint: {
      type: "string",
      title: "Search Service Endpoint",
    },
    search_service_api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Search Service Api Version",
    },
    index_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Index Name",
    },
    filterable_metadata_field_keys: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filterable Metadata Field Keys",
    },
    embedding_dimension: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Dimension",
    },
    client_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Id",
    },
    client_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Client Secret",
    },
    tenant_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Tenant Id",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudAzureAISearchVectorStore",
    },
  },
  type: "object",
  required: ["search_service_api_key", "search_service_endpoint"],
  title: "CloudAzureAISearchVectorStore",
  description: "Cloud Azure AI Search Vector Store.",
} as const;

export const CloudBoxDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    folder_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Id",
      description: "The ID of the Box folder to read from.",
    },
    authentication_mechanism: {
      $ref: "#/components/schemas/BoxAuthMechanism",
      description: "The type of authentication to use (Developer Token or CCG)",
    },
    developer_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Developer Token",
      description:
        "Developer token for authentication if authentication_mechanism is 'developer_token'.",
    },
    client_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Id",
      description:
        "Box API key used for identifying the application the user is authenticating with",
    },
    client_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Client Secret",
      description: "Box API secret used for making auth requests.",
    },
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "Box User ID, if provided authenticates as user.",
    },
    enterprise_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Enterprise Id",
      description: "Box Enterprise ID, if provided authenticates as service.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudBoxDataSource",
    },
  },
  type: "object",
  required: ["authentication_mechanism"],
  title: "CloudBoxDataSource",
} as const;

export const CloudConfluenceDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    server_url: {
      type: "string",
      title: "Server Url",
      description: "The server URL of the Confluence instance.",
    },
    authentication_mechanism: {
      type: "string",
      title: "Authentication Mechanism",
      description: "Type of Authentication for connecting to Confluence APIs.",
    },
    user_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Name",
      description: "The username to use for authentication.",
    },
    api_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Api Token",
      description: "The API token to use for authentication.",
    },
    space_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Space Key",
      description: "The space key to read from.",
    },
    page_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Ids",
      description: "The page IDs of the Confluence to read from.",
    },
    cql: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Cql",
      description: "The CQL query to use for fetching pages.",
    },
    label: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Label",
      description: "The label to use for fetching pages.",
    },
    index_restricted_pages: {
      type: "boolean",
      title: "Index Restricted Pages",
      description: "Whether to index restricted pages.",
      default: false,
    },
    keep_markdown_format: {
      type: "boolean",
      title: "Keep Markdown Format",
      description: "Whether to keep the markdown format.",
    },
    failure_handling: {
      $ref: "#/components/schemas/FailureHandlingConfig",
      description: `Configuration for handling failures during processing. Key-value object controlling failure handling behaviors.

Example:
{
  "skip_list_failures": true
}

Currently supports:
- skip_list_failures: Skip failed batches/lists and continue processing`,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudConfluenceDataSource",
    },
  },
  type: "object",
  required: ["server_url", "authentication_mechanism"],
  title: "CloudConfluenceDataSource",
} as const;

export const CloudDocumentSchema = {
  properties: {
    text: {
      type: "string",
      title: "Text",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
    },
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      default: [],
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      default: [],
    },
    page_positions: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Page Positions",
      description:
        "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].",
    },
    id: {
      type: "string",
      title: "Id",
    },
    status_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Status Metadata",
    },
  },
  type: "object",
  required: ["text", "metadata", "id"],
  title: "CloudDocument",
  description: "Cloud document stored in S3.",
} as const;

export const CloudDocumentCreateSchema = {
  properties: {
    text: {
      type: "string",
      title: "Text",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
    },
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      default: [],
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      default: [],
    },
    page_positions: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Page Positions",
      description:
        "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].",
    },
    id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Id",
    },
  },
  type: "object",
  required: ["text", "metadata"],
  title: "CloudDocumentCreate",
  description: "Create a new cloud document.",
} as const;

export const CloudJiraDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    email: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The email address to use for authentication.",
    },
    api_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Api Token",
      description:
        "The API/ Access Token used for Basic, PAT and OAuth2 authentication.",
    },
    server_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Server Url",
      description: "The server url for Jira Cloud.",
    },
    cloud_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Cloud Id",
      description: "The cloud ID, used in case of OAuth2.",
    },
    authentication_mechanism: {
      type: "string",
      title: "Authentication Mechanism",
      description: "Type of Authentication for connecting to Jira APIs.",
    },
    query: {
      type: "string",
      title: "Query",
      description: "JQL (Jira Query Language) query to search.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudJiraDataSource",
    },
  },
  type: "object",
  required: ["authentication_mechanism", "query"],
  title: "CloudJiraDataSource",
  description: "Cloud Jira Data Source integrating JiraReader.",
} as const;

export const CloudJiraDataSourceV2Schema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    email: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The email address to use for authentication.",
    },
    api_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Api Token",
      description:
        "The API Access Token used for Basic, PAT and OAuth2 authentication.",
    },
    server_url: {
      type: "string",
      title: "Server Url",
      description: "The server url for Jira Cloud.",
    },
    cloud_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Cloud Id",
      description: "The cloud ID, used in case of OAuth2.",
    },
    authentication_mechanism: {
      type: "string",
      title: "Authentication Mechanism",
      description: "Type of Authentication for connecting to Jira APIs.",
    },
    api_version: {
      type: "string",
      enum: ["2", "3"],
      title: "Api Version",
      description:
        "Jira REST API version to use (2 or 3). 3 supports Atlassian Document Format (ADF).",
      default: "2",
    },
    query: {
      type: "string",
      title: "Query",
      description: "JQL (Jira Query Language) query to search.",
    },
    fields: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Fields",
      description:
        "List of fields to retrieve from Jira. If None, retrieves all fields.",
    },
    expand: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Expand",
      description: "Fields to expand in the response.",
    },
    requests_per_minute: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Requests Per Minute",
      description: "Rate limit for Jira API requests per minute.",
    },
    get_permissions: {
      type: "boolean",
      title: "Get Permissions",
      description:
        "Whether to fetch project role permissions and issue-level security",
      default: true,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudJiraDataSourceV2",
    },
  },
  type: "object",
  required: ["server_url", "authentication_mechanism", "query"],
  title: "CloudJiraDataSourceV2",
  description: "Cloud Jira Data Source integrating JiraReaderV2.",
} as const;

export const CloudMilvusVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      title: "Supports Nested Metadata Filters",
      default: false,
    },
    uri: {
      type: "string",
      title: "Uri",
    },
    collection_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Collection Name",
    },
    token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Token",
    },
    embedding_dimension: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Dimension",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudMilvusVectorStore",
    },
  },
  type: "object",
  required: ["uri"],
  title: "CloudMilvusVectorStore",
  description: "Cloud Milvus Vector Store.",
} as const;

export const CloudMongoDBAtlasVectorSearchSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      title: "Supports Nested Metadata Filters",
      default: false,
    },
    mongodb_uri: {
      type: "string",
      format: "password",
      title: "Mongodb Uri",
      writeOnly: true,
    },
    db_name: {
      type: "string",
      title: "Db Name",
    },
    collection_name: {
      type: "string",
      title: "Collection Name",
    },
    vector_index_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vector Index Name",
    },
    fulltext_index_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Fulltext Index Name",
    },
    embedding_dimension: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Dimension",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudMongoDBAtlasVectorSearch",
    },
  },
  type: "object",
  required: ["mongodb_uri", "db_name", "collection_name"],
  title: "CloudMongoDBAtlasVectorSearch",
  description: `Cloud MongoDB Atlas Vector Store.

This class is used to store the configuration for a MongoDB Atlas vector store,
so that it can be created and used in LlamaCloud.

Args:
    mongodb_uri (str): URI for connecting to MongoDB Atlas
    db_name (str): name of the MongoDB database
    collection_name (str): name of the MongoDB collection
    vector_index_name (str): name of the MongoDB Atlas vector index
    fulltext_index_name (str): name of the MongoDB Atlas full-text index`,
} as const;

export const CloudNotionPageDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    integration_token: {
      type: "string",
      format: "password",
      title: "Integration Token",
      description: "The integration token to use for authentication.",
      writeOnly: true,
    },
    database_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Database Ids",
      description: "The Notion Database Id to read content from.",
    },
    page_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Ids",
      description: "The Page ID's of the Notion to read from.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudNotionPageDataSource",
    },
  },
  type: "object",
  required: ["integration_token"],
  title: "CloudNotionPageDataSource",
} as const;

export const CloudOneDriveDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      const: true,
      title: "Supports Access Control",
      default: true,
    },
    user_principal_name: {
      type: "string",
      title: "User Principal Name",
      description: "The user principal name to use for authentication.",
    },
    folder_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Path",
      description: "The path of the OneDrive folder to read from.",
    },
    folder_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Id",
      description: "The ID of the OneDrive folder to read from.",
    },
    client_id: {
      type: "string",
      title: "Client Id",
      description: "The client ID to use for authentication.",
    },
    client_secret: {
      type: "string",
      format: "password",
      title: "Client Secret",
      description: "The client secret to use for authentication.",
      writeOnly: true,
    },
    tenant_id: {
      type: "string",
      title: "Tenant Id",
      description: "The tenant ID to use for authentication.",
    },
    required_exts: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Required Exts",
      description: "The list of required file extensions.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudOneDriveDataSource",
    },
  },
  type: "object",
  required: ["user_principal_name", "client_id", "client_secret", "tenant_id"],
  title: "CloudOneDriveDataSource",
} as const;

export const CloudPineconeVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    api_key: {
      type: "string",
      format: "password",
      title: "Api Key",
      description: "The API key for authenticating with Pinecone",
      writeOnly: true,
    },
    index_name: {
      type: "string",
      title: "Index Name",
    },
    namespace: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Namespace",
    },
    insert_kwargs: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Insert Kwargs",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudPineconeVectorStore",
    },
  },
  type: "object",
  required: ["api_key", "index_name"],
  title: "CloudPineconeVectorStore",
  description: `Cloud Pinecone Vector Store.

This class is used to store the configuration for a Pinecone vector store, so that it can be
created and used in LlamaCloud.

Args:
    api_key (str): API key for authenticating with Pinecone
    index_name (str): name of the Pinecone index
    namespace (optional[str]): namespace to use in the Pinecone index
    insert_kwargs (optional[dict]): additional kwargs to pass during insertion`,
} as const;

export const CloudPostgresVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    database: {
      type: "string",
      title: "Database",
    },
    host: {
      type: "string",
      title: "Host",
    },
    password: {
      type: "string",
      format: "password",
      title: "Password",
      writeOnly: true,
    },
    port: {
      type: "integer",
      title: "Port",
    },
    user: {
      type: "string",
      title: "User",
    },
    table_name: {
      type: "string",
      title: "Table Name",
    },
    schema_name: {
      type: "string",
      title: "Schema Name",
    },
    embed_dim: {
      type: "integer",
      title: "Embed Dim",
    },
    hybrid_search: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hybrid Search",
      default: true,
    },
    perform_setup: {
      type: "boolean",
      title: "Perform Setup",
      default: true,
    },
    hnsw_settings: {
      anyOf: [
        {
          $ref: "#/components/schemas/PGVectorHNSWSettings",
        },
        {
          type: "null",
        },
      ],
      description:
        "HNSW settings for PGVector index. Set to null to disable HNSW indexing in favor of a brute force indexing/exact search strategy instead.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudPostgresVectorStore",
    },
  },
  type: "object",
  required: [
    "database",
    "host",
    "password",
    "port",
    "user",
    "table_name",
    "schema_name",
    "embed_dim",
  ],
  title: "CloudPostgresVectorStore",
} as const;

export const CloudQdrantVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    collection_name: {
      type: "string",
      title: "Collection Name",
    },
    url: {
      type: "string",
      title: "Url",
    },
    api_key: {
      type: "string",
      format: "password",
      title: "Api Key",
      writeOnly: true,
    },
    max_retries: {
      type: "integer",
      title: "Max Retries",
      default: 3,
    },
    client_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Client Kwargs",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudQdrantVectorStore",
    },
  },
  type: "object",
  required: ["collection_name", "url", "api_key"],
  title: "CloudQdrantVectorStore",
  description: `Cloud Qdrant Vector Store.

This class is used to store the configuration for a Qdrant vector store, so that it can be
created and used in LlamaCloud.

Args:
    collection_name (str): name of the Qdrant collection
    url (str): url of the Qdrant instance
    api_key (str): API key for authenticating with Qdrant
    max_retries (int): maximum number of retries in case of a failure. Defaults to 3
    client_kwargs (dict): additional kwargs to pass to the Qdrant client`,
} as const;

export const CloudS3DataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    bucket: {
      type: "string",
      title: "Bucket",
      description: "The name of the S3 bucket to read from.",
    },
    prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Prefix",
      description: "The prefix of the S3 objects to read from.",
    },
    regex_pattern: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Regex Pattern",
      description:
        "The regex pattern to filter S3 objects. Must be a valid regex pattern.",
    },
    aws_access_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Access Id",
      description: "The AWS access ID to use for authentication.",
    },
    aws_access_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Aws Access Secret",
      description: "The AWS access secret to use for authentication.",
    },
    s3_endpoint_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "S3 Endpoint Url",
      description: "The S3 endpoint URL to use for authentication.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudS3DataSource",
    },
  },
  type: "object",
  required: ["bucket"],
  title: "CloudS3DataSource",
} as const;

export const CloudSharepointDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      const: true,
      title: "Supports Access Control",
      default: true,
    },
    site_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Site Name",
      description: "The name of the SharePoint site to download from.",
    },
    site_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Site Id",
      description: "The ID of the SharePoint site to download from.",
    },
    folder_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Path",
      description: "The path of the Sharepoint folder to read from.",
    },
    folder_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Id",
      description: "The ID of the Sharepoint folder to read from.",
    },
    drive_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Drive Name",
      description: "The name of the Sharepoint drive to read from.",
    },
    client_id: {
      type: "string",
      title: "Client Id",
      description: "The client ID to use for authentication.",
    },
    client_secret: {
      type: "string",
      format: "password",
      title: "Client Secret",
      description: "The client secret to use for authentication.",
      writeOnly: true,
    },
    tenant_id: {
      type: "string",
      title: "Tenant Id",
      description: "The tenant ID to use for authentication.",
    },
    required_exts: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Required Exts",
      description: "The list of required file extensions.",
    },
    get_permissions: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Get Permissions",
      description: "Whether to get permissions for the sharepoint site.",
      default: true,
    },
    include_path_patterns: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Include Path Patterns",
      description:
        "List of regex patterns for file paths to include. Full paths (including filename) must match at least one pattern to be included. Example: ['/reports/', '/docs/.*\\.pdf$', '^Report.*\\.pdf$']",
    },
    exclude_path_patterns: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Exclude Path Patterns",
      description:
        "List of regex patterns for file paths to exclude. Files whose paths (including filename) match any pattern will be excluded. Example: ['/temp/', '/backup/', '\\.git/', '\\.tmp$', '^~']",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudSharepointDataSource",
    },
  },
  type: "object",
  required: ["client_id", "client_secret", "tenant_id"],
  title: "CloudSharepointDataSource",
} as const;

export const CloudSlackDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    slack_token: {
      type: "string",
      format: "password",
      title: "Slack Token",
      description: "Slack Bot Token.",
      writeOnly: true,
    },
    channel_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Channel Ids",
      description: "Slack Channel.",
    },
    latest_date: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Latest Date",
      description: "Latest date.",
    },
    earliest_date: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Earliest Date",
      description: "Earliest date.",
    },
    earliest_date_timestamp: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Earliest Date Timestamp",
      description: "Earliest date timestamp.",
    },
    latest_date_timestamp: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Latest Date Timestamp",
      description: "Latest date timestamp.",
    },
    channel_patterns: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Channel Patterns",
      description: "Slack Channel name pattern.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudSlackDataSource",
    },
  },
  type: "object",
  required: ["slack_token"],
  title: "CloudSlackDataSource",
} as const;

export const CodeItemSchema = {
  properties: {
    type: {
      type: "string",
      const: "code",
      title: "Type",
      description: "Code block item type",
      default: "code",
    },
    bBox: {
      anyOf: [
        {
          prefixItems: [
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
          ],
          type: "array",
          maxItems: 4,
          minItems: 4,
        },
        {
          type: "null",
        },
      ],
      title: "Bbox",
      description: "Bounding box coordinates [x1, y1, x2, y2]",
    },
    value: {
      type: "string",
      title: "Value",
      description: "Code content",
    },
    language: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Language",
      description: "Programming language identifier",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["value"],
  title: "CodeItem",
} as const;

export const CohereEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the Cohere model to use.",
      default: "embed-english-v3.0",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "The Cohere API key.",
    },
    truncate: {
      type: "string",
      title: "Truncate",
      description: "Truncation type - START/ END/ NONE",
      default: "END",
    },
    input_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input Type",
      description:
        "Model Input type. If not provided, search_document and search_query are used when needed.",
    },
    embedding_type: {
      type: "string",
      title: "Embedding Type",
      description:
        "Embedding type. If not provided float embedding_type is used when needed.",
      default: "float",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CohereEmbedding",
    },
  },
  type: "object",
  required: ["api_key"],
  title: "CohereEmbedding",
} as const;

export const CohereEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "COHERE_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "COHERE_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/CohereEmbedding",
      description: "Configuration for the Cohere embedding model.",
    },
  },
  type: "object",
  title: "CohereEmbeddingConfig",
} as const;

export const CompositeRetrievalModeSchema = {
  type: "string",
  enum: ["routing", "full"],
  title: "CompositeRetrievalMode",
  description: "Enum for the mode of composite retrieval.",
} as const;

export const CompositeRetrievalParamsSchema = {
  properties: {
    mode: {
      $ref: "#/components/schemas/CompositeRetrievalMode",
      description: "The mode of composite retrieval.",
      default: "full",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description:
        "(use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      deprecated: true,
    },
    rerank_config: {
      $ref: "#/components/schemas/ReRankConfig",
      description: "The rerank configuration for composite retrieval.",
    },
    query: {
      type: "string",
      minLength: 1,
      title: "Query",
      description: "The query to retrieve against.",
    },
  },
  type: "object",
  required: ["query"],
  title: "CompositeRetrievalParams",
} as const;

export const CompositeRetrievalResultSchema = {
  properties: {
    nodes: {
      items: {
        $ref: "#/components/schemas/CompositeRetrievedTextNodeWithScore",
      },
      type: "array",
      title: "Nodes",
      description: "The retrieved nodes from the composite retrieval.",
    },
    image_nodes: {
      items: {
        $ref: "#/components/schemas/PageScreenshotNodeWithScore",
      },
      type: "array",
      title: "Image Nodes",
      description:
        "The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.",
      deprecated: true,
    },
    page_figure_nodes: {
      items: {
        $ref: "#/components/schemas/PageFigureNodeWithScore",
      },
      type: "array",
      title: "Page Figure Nodes",
      description:
        "The page figure nodes retrieved by the pipeline for the given query.",
    },
  },
  type: "object",
  title: "CompositeRetrievalResult",
} as const;

export const CompositeRetrievedTextNodeSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The ID of the retrieved node.",
    },
    retriever_id: {
      type: "string",
      format: "uuid",
      title: "Retriever Id",
      description: "The ID of the retriever this node was retrieved from.",
    },
    retriever_pipeline_name: {
      type: "string",
      title: "Retriever Pipeline Name",
      description:
        "The name of the retrieval pipeline this node was retrieved from.",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline this node was retrieved from.",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
      description: "Metadata associated with the retrieved node.",
    },
    text: {
      type: "string",
      title: "Text",
      description: "The text of the retrieved node.",
    },
    start_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Start Char Idx",
      description:
        "The start character index of the retrieved node in the document",
    },
    end_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "End Char Idx",
      description:
        "The end character index of the retrieved node in the document",
    },
  },
  type: "object",
  required: [
    "id",
    "retriever_id",
    "retriever_pipeline_name",
    "pipeline_id",
    "text",
    "start_char_idx",
    "end_char_idx",
  ],
  title: "CompositeRetrievedTextNode",
} as const;

export const CompositeRetrievedTextNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/CompositeRetrievedTextNode",
    },
    score: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Score",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CompositeRetrievedTextNodeWithScore",
    },
  },
  type: "object",
  required: ["node"],
  title: "CompositeRetrievedTextNodeWithScore",
} as const;

export const ConfigurableDataSinkNamesSchema = {
  type: "string",
  enum: [
    "PINECONE",
    "POSTGRES",
    "QDRANT",
    "AZUREAI_SEARCH",
    "MONGODB_ATLAS",
    "MILVUS",
    "ASTRA_DB",
  ],
  title: "ConfigurableDataSinkNames",
} as const;

export const ConfigurableDataSourceNamesSchema = {
  type: "string",
  enum: [
    "S3",
    "AZURE_STORAGE_BLOB",
    "GOOGLE_DRIVE",
    "MICROSOFT_ONEDRIVE",
    "MICROSOFT_SHAREPOINT",
    "SLACK",
    "NOTION_PAGE",
    "CONFLUENCE",
    "JIRA",
    "JIRA_V2",
    "BOX",
  ],
  title: "ConfigurableDataSourceNames",
} as const;

export const DataSinkSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data sink.",
    },
    sink_type: {
      $ref: "#/components/schemas/ConfigurableDataSinkNames",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudPineconeVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudPostgresVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudQdrantVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAzureAISearchVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch",
        },
        {
          $ref: "#/components/schemas/CloudMilvusVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAstraDBVectorStore",
        },
      ],
      title: "DataSinkCreateComponent",
      description: "Component that implements the data sink",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
  },
  type: "object",
  required: ["id", "name", "sink_type", "component", "project_id"],
  title: "DataSink",
  description: "Schema for a data sink.",
} as const;

export const DataSinkCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data sink.",
    },
    sink_type: {
      $ref: "#/components/schemas/ConfigurableDataSinkNames",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudPineconeVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudPostgresVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudQdrantVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAzureAISearchVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch",
        },
        {
          $ref: "#/components/schemas/CloudMilvusVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAstraDBVectorStore",
        },
      ],
      title: "DataSinkCreateComponent",
      description: "Component that implements the data sink",
    },
  },
  type: "object",
  required: ["name", "sink_type", "component"],
  title: "DataSinkCreate",
  description: "Schema for creating a data sink.",
} as const;

export const DataSinkUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The name of the data sink.",
    },
    sink_type: {
      $ref: "#/components/schemas/ConfigurableDataSinkNames",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudPineconeVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudPostgresVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudQdrantVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAzureAISearchVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch",
        },
        {
          $ref: "#/components/schemas/CloudMilvusVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAstraDBVectorStore",
        },
        {
          type: "null",
        },
      ],
      title: "DataSinkUpdateComponent",
      description: "Component that implements the data sink",
    },
  },
  type: "object",
  required: ["sink_type"],
  title: "DataSinkUpdate",
  description: "Schema for updating a data sink.",
} as const;

export const DataSourceSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
      ],
      title: "DataSourceCreateComponent",
      description: "Component that implements the data source",
    },
    version_metadata: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSourceReaderVersionMetadata",
        },
        {
          type: "null",
        },
      ],
      description: "Version metadata for the data source",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
  },
  type: "object",
  required: ["id", "name", "source_type", "component", "project_id"],
  title: "DataSource",
  description: "Schema for a data source.",
} as const;

export const DataSourceCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
      ],
      title: "DataSourceCreateComponent",
      description: "Component that implements the data source",
    },
  },
  type: "object",
  required: ["name", "source_type", "component"],
  title: "DataSourceCreate",
  description: "Schema for creating a data source.",
} as const;

export const DataSourceReaderVersionMetadataSchema = {
  properties: {
    reader_version: {
      anyOf: [
        {
          type: "string",
          enum: ["1.0", "2.0", "2.1"],
        },
        {
          type: "null",
        },
      ],
      title: "Reader Version",
      description: "The version of the reader to use for this data source.",
    },
  },
  type: "object",
  title: "DataSourceReaderVersionMetadata",
} as const;

export const DataSourceSyncRequestSchema = {
  properties: {
    pipeline_file_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline File Ids",
    },
  },
  type: "object",
  title: "DataSourceSyncRequest",
  description: `Request model for syncing pipeline data sources.

Notes:
- This endpoint pulls from the 3p data source and parses.
- We accept pipeline_file_ids for now because callers (e.g. add_files_to_pipeline)
  often have these IDs handy. Internally we map them to external IDs to filter
  the reader, which enumerates by external ID.
- Likely to evolve to take external IDs directly; keeping this for convenience.`,
} as const;

export const DataSourceUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
        {
          type: "null",
        },
      ],
      title: "DataSourceUpdateComponent",
      description: "Component that implements the data source",
    },
  },
  type: "object",
  required: ["source_type"],
  title: "DataSourceUpdate",
  description: "Schema for updating a data source.",
} as const;

export const DeleteRequestSchema = {
  properties: {
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "The agent deployment's name to delete data for",
    },
    collection: {
      type: "string",
      title: "Collection",
      description: "The logical agent data collection to delete from",
      default: "default",
    },
    filter: {
      anyOf: [
        {
          additionalProperties: {
            $ref: "#/components/schemas/FilterOperation",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filter",
      description: "Optional filters to select which items to delete",
    },
  },
  type: "object",
  required: ["deployment_name"],
  title: "DeleteRequest",
  description: "API request body for bulk deleting agent data by query",
} as const;

export const DeleteResponseSchema = {
  properties: {
    deleted_count: {
      type: "integer",
      title: "Deleted Count",
    },
  },
  type: "object",
  required: ["deleted_count"],
  title: "DeleteResponse",
  description: "API response for bulk delete operation",
} as const;

export const DiffingStatusDetailsSchema = {
  properties: {
    status: {
      type: "string",
      enum: ["pending", "processing", "completed", "failed"],
      title: "Status",
      description: "Status of the diffing process",
      default: "pending",
    },
    effective_at: {
      type: "string",
      format: "date-time",
      title: "Effective At",
    },
    job_record_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Record Id",
      description: "The job record ID associated with this status, if any.",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message for the latest job attempt, if any.",
    },
  },
  type: "object",
  title: "DiffingStatusDetails",
} as const;

export const DirectRetrievalParamsSchema = {
  properties: {
    mode: {
      $ref: "#/components/schemas/CompositeRetrievalMode",
      description: "The mode of composite retrieval.",
      default: "full",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description:
        "(use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      deprecated: true,
    },
    rerank_config: {
      $ref: "#/components/schemas/ReRankConfig",
      description: "The rerank configuration for composite retrieval.",
    },
    query: {
      type: "string",
      minLength: 1,
      title: "Query",
      description: "The query to retrieve against.",
    },
    pipelines: {
      items: {
        $ref: "#/components/schemas/RetrieverPipeline",
      },
      type: "array",
      title: "Pipelines",
      description: "The pipelines to use for retrieval.",
    },
  },
  type: "object",
  required: ["query"],
  title: "DirectRetrievalParams",
} as const;

export const DirectoryCreateRequestSchema = {
  properties: {
    name: {
      type: "string",
      minLength: 1,
      title: "Name",
      description: "Human-readable name for the directory.",
    },
    description: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "Optional description shown to users.",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "Optional data source id the directory syncs from.",
    },
  },
  type: "object",
  required: ["name"],
  title: "DirectoryCreateRequest",
  description: "API request schema for creating a directory.",
} as const;

export const DirectoryFileCreateRequestSchema = {
  properties: {
    file_id: {
      type: "string",
      title: "File Id",
      description: "File ID for the storage location (required).",
    },
    unique_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Unique Id",
      description:
        "Unique identifier for the file in the directory. If not provided, will use the file's external_file_id or name.",
    },
    display_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Display Name",
      description:
        "Display name for the file. If not provided, will use the file's name.",
    },
  },
  type: "object",
  required: ["file_id"],
  title: "DirectoryFileCreateRequest",
  description: "API request schema for creating a directory file.",
} as const;

export const DirectoryFileQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/DirectoryFileResponse",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "DirectoryFileQueryResponse",
  description: "API query response schema for directory files.",
} as const;

export const DirectoryFileResponseSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the directory file.",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "Project the directory file belongs to.",
    },
    directory_id: {
      type: "string",
      title: "Directory Id",
      description: "Directory the file belongs to.",
    },
    unique_id: {
      type: "string",
      minLength: 1,
      title: "Unique Id",
      description: "Unique identifier for the file in the directory",
    },
    display_name: {
      type: "string",
      minLength: 1,
      title: "Display Name",
      description: "Display name for the file.",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "Optional data source credential associated with the file.",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "File ID for the storage location.",
    },
    deleted_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Deleted At",
      description:
        "Soft delete marker when the file is removed upstream or by user action.",
    },
  },
  type: "object",
  required: ["id", "project_id", "directory_id", "unique_id", "display_name"],
  title: "DirectoryFileResponse",
  description: "API response schema for a directory file.",
} as const;

export const DirectoryFileUpdateRequestSchema = {
  properties: {
    unique_id: {
      anyOf: [
        {
          type: "string",
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Unique Id",
      description: "Updated unique identifier.",
    },
    display_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Display Name",
      description: "Updated display name.",
    },
  },
  type: "object",
  title: "DirectoryFileUpdateRequest",
  description: "API request schema for updating a directory file.",
} as const;

export const DirectoryQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/DirectoryResponse",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "DirectoryQueryResponse",
  description: "API query response schema for directories.",
} as const;

export const DirectoryResponseSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the directory.",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "Project the directory belongs to.",
    },
    name: {
      type: "string",
      minLength: 1,
      title: "Name",
      description: "Human-readable name for the directory.",
    },
    description: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "Optional description shown to users.",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description:
        "Optional data source id the directory syncs from. Null if just manual uploads.",
    },
    deleted_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Deleted At",
      description:
        "Optional timestamp of when the directory was deleted. Null if not deleted.",
    },
  },
  type: "object",
  required: ["id", "project_id", "name"],
  title: "DirectoryResponse",
  description: "API response schema for a directory.",
} as const;

export const DirectorySyncJobCreateRequestSchema = {
  properties: {
    directory_id: {
      type: "string",
      title: "Directory Id",
      description: "Directory being processed",
    },
  },
  type: "object",
  required: ["directory_id"],
  title: "DirectorySyncJobCreateRequest",
  description: "Schema for creating a directory sync job.",
} as const;

export const DirectorySyncJobResponseSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the directory sync job",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "Project this job belongs to",
    },
    directory_id: {
      type: "string",
      title: "Directory Id",
      description: "Directory being processed",
    },
    listing_status_details: {
      $ref: "#/components/schemas/ListingStatusDetails",
      description: "Status of the listing process",
    },
    diffing_status_details: {
      $ref: "#/components/schemas/DiffingStatusDetails",
      description: "Status of the diffing process",
    },
    apply_status_details: {
      $ref: "#/components/schemas/ApplyStatusDetails",
      description: "Status of the apply process (file updates and deletions)",
    },
    started_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Started At",
      description: "Timestamp when job processing started",
    },
    completed_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Completed At",
      description: "Timestamp when job completed",
    },
  },
  type: "object",
  required: [
    "id",
    "project_id",
    "directory_id",
    "listing_status_details",
    "diffing_status_details",
    "apply_status_details",
  ],
  title: "DirectorySyncJobResponse",
  description: "Schema for a directory sync job.",
} as const;

export const DirectoryUpdateRequestSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "Updated name for the directory.",
    },
    description: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "Updated description for the directory.",
    },
  },
  type: "object",
  title: "DirectoryUpdateRequest",
  description: "API request schema for updating a directory.",
} as const;

export const DocumentChunkModeSchema = {
  type: "string",
  enum: ["PAGE", "SECTION"],
  title: "DocumentChunkMode",
  description: "How to chunk documents.",
} as const;

export const ElementSegmentationConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "element",
      title: "Mode",
      default: "element",
    },
  },
  type: "object",
  title: "ElementSegmentationConfig",
} as const;

export const EmbeddingModelConfigSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the embedding model config.",
    },
    embedding_config: {
      oneOf: [
        {
          $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/CohereEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/GeminiEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/OpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/VertexAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/BedrockEmbeddingConfig",
        },
      ],
      title: "Embedding Config",
      description:
        "The embedding configuration for the embedding model config.",
      discriminator: {
        propertyName: "type",
        mapping: {
          AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
          BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
          COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
          GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
          HUGGINGFACE_API_EMBEDDING:
            "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
          OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
          VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig",
        },
      },
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
  },
  type: "object",
  required: ["id", "name", "embedding_config", "project_id"],
  title: "EmbeddingModelConfig",
  description: "Schema for an embedding model config.",
} as const;

export const EmbeddingModelConfigCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the embedding model config.",
    },
    embedding_config: {
      oneOf: [
        {
          $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/CohereEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/GeminiEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/OpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/VertexAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/BedrockEmbeddingConfig",
        },
      ],
      title: "Embedding Config",
      description:
        "The embedding configuration for the embedding model config.",
      discriminator: {
        propertyName: "type",
        mapping: {
          AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
          BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
          COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
          GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
          HUGGINGFACE_API_EMBEDDING:
            "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
          OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
          VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig",
        },
      },
    },
  },
  type: "object",
  required: ["name", "embedding_config"],
  title: "EmbeddingModelConfigCreate",
} as const;

export const EmbeddingModelConfigUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The name of the embedding model config.",
    },
    embedding_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/CohereEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/GeminiEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/OpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/VertexAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/BedrockEmbeddingConfig",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              AZURE_EMBEDDING:
                "#/components/schemas/AzureOpenAIEmbeddingConfig",
              BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
              COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
              GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
              HUGGINGFACE_API_EMBEDDING:
                "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
              OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
              VERTEXAI_EMBEDDING:
                "#/components/schemas/VertexAIEmbeddingConfig",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config",
      description:
        "The embedding configuration for the embedding model config.",
    },
  },
  type: "object",
  title: "EmbeddingModelConfigUpdate",
} as const;

export const ExtractAgentSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The id of the extraction agent.",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the extraction agent.",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description:
        "The ID of the project that the extraction agent belongs to.",
    },
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
      description: "The schema of the data.",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction agent.",
    },
    custom_configuration: {
      anyOf: [
        {
          type: "string",
          const: "default",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Configuration",
      description:
        "Custom configuration type for the extraction agent. Currently supports 'default'.",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "The creation time of the extraction agent.",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "The last update time of the extraction agent.",
    },
  },
  type: "object",
  required: ["id", "name", "project_id", "data_schema", "config"],
  title: "ExtractAgent",
  description: "Schema and configuration for an extraction agent.",
} as const;

export const ExtractAgentCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "The name of the extraction schema",
    },
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
      description: "The schema of the data.",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction agent.",
    },
  },
  type: "object",
  required: ["name", "data_schema", "config"],
  title: "ExtractAgentCreate",
  description: "Settings for creating an extraction agent.",
} as const;

export const ExtractAgentUpdateSchema = {
  properties: {
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
      description: "The schema of the data",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction agent.",
    },
  },
  type: "object",
  required: ["data_schema", "config"],
  title: "ExtractAgentUpdate",
  description: "Settings for updating an extraction schema.",
} as const;

export const ExtractConfigSchema = {
  properties: {
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    extraction_target: {
      $ref: "#/components/schemas/ExtractTarget",
      description: "The extraction target specified.",
      default: "PER_DOC",
    },
    extraction_mode: {
      $ref: "#/components/schemas/ExtractMode",
      description:
        "The extraction mode specified (FAST, BALANCED, MULTIMODAL, PREMIUM).",
      default: "PREMIUM",
    },
    parse_model: {
      anyOf: [
        {
          $ref: "#/components/schemas/PublicModelName",
        },
        {
          type: "null",
        },
      ],
      description:
        "The parse model to use for document parsing. If not provided, uses the default for the extraction mode.",
    },
    extract_model: {
      anyOf: [
        {
          $ref: "#/components/schemas/ExtractModels",
        },
        {
          type: "null",
        },
      ],
      description:
        "The extract model to use for data extraction. If not provided, uses the default for the extraction mode.",
    },
    multimodal_fast_mode: {
      type: "boolean",
      title: "Multimodal Fast Mode",
      description:
        "DEPRECATED: Whether to use fast mode for multimodal extraction.",
      default: false,
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
      description: "The system prompt to use for the extraction.",
    },
    use_reasoning: {
      type: "boolean",
      title: "Use Reasoning",
      description: "Whether to use reasoning for the extraction.",
      default: false,
    },
    cite_sources: {
      type: "boolean",
      title: "Cite Sources",
      description: "Whether to cite sources for the extraction.",
      default: false,
    },
    citation_bbox: {
      type: "boolean",
      title: "Citation Bbox",
      description:
        "Whether to fetch citation bounding boxes for the extraction. Only available in PREMIUM mode.",
      default: false,
    },
    confidence_scores: {
      type: "boolean",
      title: "Confidence Scores",
      description: "Whether to fetch confidence scores for the extraction.",
      default: false,
    },
    chunk_mode: {
      $ref: "#/components/schemas/DocumentChunkMode",
      description: "The mode to use for chunking the document.",
      default: "PAGE",
    },
    high_resolution_mode: {
      type: "boolean",
      title: "High Resolution Mode",
      description: "Whether to use high resolution mode for the extraction.",
      default: false,
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      description: "Whether to invalidate the cache for the extraction.",
      default: false,
    },
    num_pages_context: {
      anyOf: [
        {
          type: "integer",
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Num Pages Context",
      description:
        "Number of pages to pass as context on long document extraction.",
    },
    page_range: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Range",
      description:
        "Comma-separated list of page numbers or ranges to extract from (1-based, e.g., '1,3,5-7,9' or '1-3,8-10').",
    },
  },
  type: "object",
  title: "ExtractConfig",
  description: "Configuration parameters for the extraction agent.",
} as const;

export const ExtractJobSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The id of the extraction job",
    },
    extraction_agent: {
      $ref: "#/components/schemas/ExtractAgent",
      description: "The agent that the job was run on.",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
      description: "The status of the extraction job",
    },
    error: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error",
      description: "The error that occurred during extraction",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The id of the file that the extract was extracted from",
    },
    file: {
      anyOf: [
        {
          $ref: "#/components/schemas/File",
        },
        {
          type: "null",
        },
      ],
      description: "[DEPRECATED] The file that the extract was extracted from",
      deprecated: true,
    },
  },
  type: "object",
  required: ["id", "extraction_agent", "status"],
  title: "ExtractJob",
  description: "Schema for an extraction job.",
} as const;

export const ExtractJobCreateSchema = {
  properties: {
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The id of the file",
    },
    data_schema_override: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema Override",
      description:
        "The data schema to override the extraction agent's data schema with",
    },
    config_override: {
      anyOf: [
        {
          $ref: "#/components/schemas/ExtractConfig",
        },
        {
          type: "null",
        },
      ],
      description: "The config to override the extraction agent's config with",
    },
  },
  type: "object",
  required: ["extraction_agent_id", "file_id"],
  title: "ExtractJobCreate",
  description: "Schema for creating an extraction job.",
} as const;

export const ExtractJobCreateBatchSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    file_ids: {
      items: {
        type: "string",
        format: "uuid",
      },
      type: "array",
      minItems: 1,
      title: "File Ids",
      description: "The ids of the files",
    },
    data_schema_override: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema Override",
      description:
        "The data schema to override the extraction agent's data schema with",
    },
    config_override: {
      anyOf: [
        {
          $ref: "#/components/schemas/ExtractConfig",
        },
        {
          type: "null",
        },
      ],
      description: "The config to override the extraction agent's config with",
    },
  },
  type: "object",
  required: ["extraction_agent_id", "file_ids"],
  title: "ExtractJobCreateBatch",
  description: "Schema for creating extraction jobs in batch.",
} as const;

export const ExtractModeSchema = {
  type: "string",
  enum: ["FAST", "BALANCED", "PREMIUM", "MULTIMODAL"],
  title: "ExtractMode",
  description: "Extraction mode options.",
} as const;

export const ExtractModelsSchema = {
  type: "string",
  enum: [
    "openai-gpt-4-1",
    "openai-gpt-4-1-mini",
    "openai-gpt-4-1-nano",
    "openai-gpt-5",
    "openai-gpt-5-mini",
    "gemini-2.0-flash",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite",
    "gemini-2.5-pro",
    "openai-gpt-4o",
    "openai-gpt-4o-mini",
  ],
  title: "ExtractModels",
  description: "Extract model options.",
} as const;

export const ExtractResultsetSchema = {
  properties: {
    run_id: {
      type: "string",
      format: "uuid",
      title: "Run Id",
      description: "The id of the extraction run",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    data: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          items: {
            additionalProperties: {
              anyOf: [
                {
                  additionalProperties: true,
                  type: "object",
                },
                {
                  items: {},
                  type: "array",
                },
                {
                  type: "string",
                },
                {
                  type: "integer",
                },
                {
                  type: "number",
                },
                {
                  type: "boolean",
                },
                {
                  type: "null",
                },
              ],
            },
            type: "object",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Data",
      description: "The data extracted from the file",
    },
    extraction_metadata: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Extraction Metadata",
      description: "The metadata extracted from the file",
    },
  },
  type: "object",
  required: ["run_id", "extraction_agent_id", "data", "extraction_metadata"],
  title: "ExtractResultset",
  description: "Schema for an extraction resultset.",
} as const;

export const ExtractRunSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The id of the extraction run",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The id of the project that the extraction run belongs to",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
      description: "The schema used for extraction",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The config used for extraction",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The id of the file that the extract was extracted from",
    },
    file: {
      anyOf: [
        {
          $ref: "#/components/schemas/File",
        },
        {
          type: "null",
        },
      ],
      description: "[DEPRECATED] The file that the extract was extracted from",
      deprecated: true,
    },
    status: {
      $ref: "#/components/schemas/ExtractState",
      description: "The status of the extraction run",
    },
    error: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error",
      description: "The error that occurred during extraction",
    },
    job_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Job Id",
      description: "The id of the job that the extraction run belongs to",
    },
    data: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          items: {
            additionalProperties: {
              anyOf: [
                {
                  additionalProperties: true,
                  type: "object",
                },
                {
                  items: {},
                  type: "array",
                },
                {
                  type: "string",
                },
                {
                  type: "integer",
                },
                {
                  type: "number",
                },
                {
                  type: "boolean",
                },
                {
                  type: "null",
                },
              ],
            },
            type: "object",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Data",
      description: "The data extracted from the file",
    },
    extraction_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Extraction Metadata",
      description: "The metadata extracted from the file",
    },
    from_ui: {
      type: "boolean",
      title: "From Ui",
      description: "Whether this extraction run was triggered from the UI",
    },
  },
  type: "object",
  required: [
    "id",
    "project_id",
    "extraction_agent_id",
    "data_schema",
    "config",
    "status",
    "from_ui",
  ],
  title: "ExtractRun",
  description: "Schema for an extraction run.",
} as const;

export const ExtractSchemaGenerateRequestSchema = {
  properties: {
    prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Prompt",
      description:
        "Natural language description of the data structure to extract",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "Optional file ID to analyze for schema generation",
    },
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema",
      description:
        "Optional schema to validate, refine, or extend during generation",
    },
  },
  type: "object",
  title: "ExtractSchemaGenerateRequest",
  description: "Request schema for generating an extraction schema.",
} as const;

export const ExtractSchemaGenerateResponseSchema = {
  properties: {
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
      description: "The generated JSON schema",
    },
  },
  type: "object",
  required: ["data_schema"],
  title: "ExtractSchemaGenerateResponse",
  description: "Response schema for schema generation.",
} as const;

export const ExtractSchemaValidateRequestSchema = {
  properties: {
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
    },
  },
  type: "object",
  required: ["data_schema"],
  title: "ExtractSchemaValidateRequest",
  description: "Request schema for validating an extraction schema.",
} as const;

export const ExtractSchemaValidateResponseSchema = {
  properties: {
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
    },
  },
  type: "object",
  required: ["data_schema"],
  title: "ExtractSchemaValidateResponse",
  description: "Response schema for schema validation.",
} as const;

export const ExtractStateSchema = {
  type: "string",
  enum: ["CREATED", "PENDING", "SUCCESS", "ERROR"],
  title: "ExtractState",
} as const;

export const ExtractStatelessRequestSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
      description: "The schema of the data to extract",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The ID of the file to extract from",
    },
    text: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Text",
      description: "The text content to extract from",
    },
    file: {
      anyOf: [
        {
          $ref: "#/components/schemas/FileData",
        },
        {
          type: "null",
        },
      ],
      description: "The file data with base64 content and MIME type",
    },
  },
  type: "object",
  required: ["data_schema", "config"],
  title: "ExtractStatelessRequest",
  description: "Schema for stateless extraction requests.",
} as const;

export const ExtractTargetSchema = {
  type: "string",
  enum: ["PER_DOC", "PER_PAGE", "PER_TABLE_ROW"],
  title: "ExtractTarget",
  description: "Defines the extraction target scope.",
} as const;

export const ExtractedRegionSummarySchema = {
  properties: {
    region_id: {
      type: "string",
      title: "Region Id",
      description: "Unique identifier for this region within the file",
    },
    sheet_name: {
      type: "string",
      title: "Sheet Name",
      description: "Worksheet name where region was found",
    },
    location: {
      type: "string",
      title: "Location",
      description: "Location of the region in the spreadsheet",
    },
    region_type: {
      type: "string",
      title: "Region Type",
      description: "Type of the extracted region",
    },
    title: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Title",
      description: "Generated title for the region",
    },
    description: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "Generated description for the region",
    },
  },
  type: "object",
  required: ["sheet_name", "location", "region_type"],
  title: "ExtractedRegionSummary",
  description: "A summary of a single extracted region from a spreadsheet",
} as const;

export const FailPageModeSchema = {
  type: "string",
  enum: ["raw_text", "blank_page", "error_message"],
  title: "FailPageMode",
  description:
    "Enum for representing the different available page error handling modes",
} as const;

export const FailedMarkdownPageSchema = {
  properties: {
    page_number: {
      type: "integer",
      title: "Page Number",
      description: "Page number of the document",
    },
    error: {
      type: "string",
      title: "Error",
      description: "Error message describing the failure",
    },
    success: {
      type: "boolean",
      const: false,
      title: "Success",
      description: "Failure indicator",
      default: false,
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["page_number", "error"],
  title: "FailedMarkdownPage",
} as const;

export const FailedStructuredPageSchema = {
  properties: {
    page_number: {
      type: "integer",
      title: "Page Number",
      description: "Page number of the document",
    },
    error: {
      type: "string",
      title: "Error",
      description: "Error message describing the failure",
    },
    success: {
      type: "boolean",
      const: false,
      title: "Success",
      description: "Failure indicator",
      default: false,
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["page_number", "error"],
  title: "FailedStructuredPage",
} as const;

export const FailureHandlingConfigSchema = {
  properties: {
    skip_list_failures: {
      type: "boolean",
      title: "Skip List Failures",
      description:
        "Whether to skip failed batches/lists and continue processing",
      default: false,
    },
  },
  type: "object",
  title: "FailureHandlingConfig",
  description:
    "Configuration for handling different types of failures during data source processing.",
} as const;

export const FileSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "The ID of the file in the external system",
    },
    file_size: {
      anyOf: [
        {
          type: "integer",
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "File Size",
      description: "Size of the file in bytes",
    },
    file_type: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "File Type",
      description: "File type (e.g. pdf, docx, etc.)",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project that the file belongs to",
    },
    last_modified_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Last Modified At",
      description: "The last modified time of the file",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
    permission_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Permission Info",
      description: "Permission information for the file",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the file belongs to",
    },
  },
  type: "object",
  required: ["id", "name", "project_id"],
  title: "File",
  description: "Schema for a file.",
} as const;

export const FileClassificationSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    classify_job_id: {
      type: "string",
      format: "uuid",
      title: "Classify Job Id",
      description: "The ID of the classify job",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the classified file",
    },
    result: {
      anyOf: [
        {
          $ref: "#/components/schemas/ClassificationResult",
        },
        {
          type: "null",
        },
      ],
      description: "The classification result",
    },
  },
  type: "object",
  required: ["id", "classify_job_id", "file_id"],
  title: "FileClassification",
  description: "A file classification.",
} as const;

export const FileCountByStatusResponseSchema = {
  properties: {
    counts: {
      additionalProperties: {
        type: "integer",
      },
      type: "object",
      title: "Counts",
      description: "The counts of files by status",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "The total number of files",
    },
    pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline Id",
      description: "The ID of the pipeline that the files belong to",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the files belong to",
    },
    only_manually_uploaded: {
      type: "boolean",
      title: "Only Manually Uploaded",
      description: "Whether to only count manually uploaded files",
      default: false,
    },
  },
  type: "object",
  required: ["counts", "total_count"],
  title: "FileCountByStatusResponse",
} as const;

export const FileCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description:
        "Name that will be used for created file. If possible, always include the file extension in the name.",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "The ID of the file in the external system",
    },
    file_size: {
      anyOf: [
        {
          type: "integer",
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "File Size",
      description: "Size of the file in bytes",
    },
    last_modified_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Last Modified At",
      description: "The last modified time of the file",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
    permission_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Permission Info",
      description: "Permission information for the file",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the file belongs to",
    },
  },
  type: "object",
  required: ["name"],
  title: "FileCreate",
} as const;

export const FileCreateFromUrlSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description:
        "Name that will be used for created file. If possible, always include the file extension in the name.",
    },
    url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Url",
      description: "URL of the file to download",
    },
    proxy_url: {
      anyOf: [
        {
          type: "string",
          minLength: 1,
          format: "uri",
        },
        {
          type: "null",
        },
      ],
      title: "Proxy Url",
      description: "URL of the proxy server to use for downloading the file",
    },
    request_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Request Headers",
      description:
        "Headers to include in the request when downloading the file",
    },
    verify_ssl: {
      type: "boolean",
      title: "Verify Ssl",
      description:
        "Whether to verify the SSL certificate when downloading the file",
      default: true,
    },
    follow_redirects: {
      type: "boolean",
      title: "Follow Redirects",
      description: "Whether to follow redirects when downloading the file",
      default: true,
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
  },
  type: "object",
  required: ["url"],
  title: "FileCreateFromUrl",
} as const;

export const FileDataSchema = {
  properties: {
    data: {
      type: "string",
      title: "Data",
      description: "The file content as base64-encoded string",
    },
    mime_type: {
      type: "string",
      title: "Mime Type",
      description:
        "The MIME type of the file (e.g., 'application/pdf', 'text/plain')",
    },
  },
  type: "object",
  required: ["data", "mime_type"],
  title: "FileData",
  description: "Schema for file data with base64 content and MIME type.",
} as const;

export const FileFilterSchema = {
  properties: {
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "Filter by project ID",
    },
    file_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "File Ids",
      description: "Filter by specific file IDs",
    },
    file_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "File Name",
      description: "Filter by file name",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "Filter by data source ID",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "Filter by external file ID",
    },
    only_manually_uploaded: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Only Manually Uploaded",
      description:
        "Filter only manually uploaded files (data_source_id is null)",
    },
  },
  type: "object",
  title: "FileFilter",
  description: "Filter parameters for file queries.",
} as const;

export const FileIdPresignedUrlSchema = {
  properties: {
    url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Url",
      description: "A presigned URL for IO operations against a private file",
    },
    expires_at: {
      type: "string",
      format: "date-time",
      title: "Expires At",
      description: "The time at which the presigned URL expires",
    },
    form_fields: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Form Fields",
      description: "Form fields for a presigned POST request",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file associated with the presigned URL",
    },
  },
  type: "object",
  required: ["url", "expires_at", "file_id"],
  title: "FileIdPresignedUrl",
  description: "Schema for a presigned URL with a file ID.",
} as const;

export const FileQueryRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          $ref: "#/components/schemas/FileFilter",
        },
        {
          type: "null",
        },
      ],
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
  },
  type: "object",
  title: "FileQueryRequest",
  description:
    "Request schema for querying files with pagination and filtering.",
} as const;

export const FileQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/File",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "FileQueryResponse",
  description: "Response schema for paginated file queries.",
} as const;

export const FilterConditionSchema = {
  type: "string",
  enum: ["and", "or", "not"],
  title: "FilterCondition",
  description: "Vector store filter conditions to combine different filters.",
} as const;

export const FilterOperationSchema = {
  properties: {
    eq: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Eq",
    },
    gt: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Gt",
    },
    gte: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Gte",
    },
    lt: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Lt",
    },
    lte: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Lte",
    },
    includes: {
      items: {
        anyOf: [
          {
            type: "number",
          },
          {
            type: "integer",
          },
          {
            type: "string",
          },
          {
            type: "string",
            format: "date-time",
          },
          {
            type: "null",
          },
        ],
      },
      type: "array",
      title: "Includes",
    },
  },
  type: "object",
  title: "FilterOperation",
  description: "API request model for a filter comparison operation.",
} as const;

export const FilterOperatorSchema = {
  type: "string",
  enum: [
    "==",
    ">",
    "<",
    "!=",
    ">=",
    "<=",
    "in",
    "nin",
    "any",
    "all",
    "text_match",
    "text_match_insensitive",
    "contains",
    "is_empty",
  ],
  title: "FilterOperator",
  description: "Vector store filter operator.",
} as const;

export const GeminiEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the Gemini model to use.",
      default: "models/embedding-001",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    title: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Title",
      description:
        "Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.",
      default: "",
    },
    task_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Task Type",
      description: "The task for embedding model.",
      default: "retrieval_document",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "API key to access the model. Defaults to None.",
    },
    api_base: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Base",
      description: "API base to access the model. Defaults to None.",
    },
    transport: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Transport",
      description: "Transport to access the model. Defaults to None.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "GeminiEmbedding",
    },
  },
  type: "object",
  title: "GeminiEmbedding",
} as const;

export const GeminiEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "GEMINI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "GEMINI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/GeminiEmbedding",
      description: "Configuration for the Gemini embedding model.",
    },
  },
  type: "object",
  title: "GeminiEmbeddingConfig",
} as const;

export const HTTPValidationErrorSchema = {
  properties: {
    detail: {
      items: {
        $ref: "#/components/schemas/ValidationError",
      },
      type: "array",
      title: "Detail",
    },
  },
  type: "object",
  title: "HTTPValidationError",
} as const;

export const HeadingItemSchema = {
  properties: {
    type: {
      type: "string",
      const: "heading",
      title: "Type",
      description: "Heading item type",
      default: "heading",
    },
    bBox: {
      anyOf: [
        {
          prefixItems: [
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
          ],
          type: "array",
          maxItems: 4,
          minItems: 4,
        },
        {
          type: "null",
        },
      ],
      title: "Bbox",
      description: "Bounding box coordinates [x1, y1, x2, y2]",
    },
    level: {
      type: "integer",
      title: "Level",
      description: "Heading level (1-6)",
    },
    value: {
      type: "string",
      title: "Value",
      description: "Heading text content",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["level", "value"],
  title: "HeadingItem",
} as const;

export const HuggingFaceInferenceAPIEmbeddingSchema = {
  properties: {
    model_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model Name",
      description: "Hugging Face model name. If None, the task will be used.",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    pooling: {
      anyOf: [
        {
          $ref: "#/components/schemas/Pooling",
        },
        {
          type: "null",
        },
      ],
      description:
        "Pooling strategy. If None, the model's default pooling is used.",
      default: "cls",
    },
    query_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Query Instruction",
      description: "Instruction to prepend during query embedding.",
    },
    text_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Text Instruction",
      description: "Instruction to prepend during text embedding.",
    },
    token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Token",
      description:
        "Hugging Face token. Will default to the locally saved token. Pass token=False if you dont want to send your token to the server.",
    },
    timeout: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Timeout",
      description:
        "The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.",
    },
    headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Headers",
      description:
        "Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.",
    },
    cookies: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Cookies",
      description: "Additional cookies to send to the server.",
    },
    task: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Task",
      description:
        "Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "HuggingFaceInferenceAPIEmbedding",
    },
  },
  type: "object",
  title: "HuggingFaceInferenceAPIEmbedding",
} as const;

export const HuggingFaceInferenceAPIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "HUGGINGFACE_API_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "HUGGINGFACE_API_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding",
      description:
        "Configuration for the HuggingFace Inference API embedding model.",
    },
  },
  type: "object",
  title: "HuggingFaceInferenceAPIEmbeddingConfig",
} as const;

export const ImageItemSchema = {
  properties: {
    type: {
      type: "string",
      const: "image",
      title: "Type",
      description: "Image item type",
      default: "image",
    },
    bBox: {
      anyOf: [
        {
          prefixItems: [
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
          ],
          type: "array",
          maxItems: 4,
          minItems: 4,
        },
        {
          type: "null",
        },
      ],
      title: "Bbox",
      description: "Bounding box coordinates [x1, y1, x2, y2]",
    },
    name: {
      type: "string",
      title: "Name",
      description: "Image filename or identifier",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["name"],
  title: "ImageItem",
} as const;

export const IngestionErrorResponseSchema = {
  properties: {
    job_id: {
      type: "string",
      format: "uuid",
      title: "Job Id",
      description: "ID of the job that failed.",
    },
    message: {
      type: "string",
      title: "Message",
      description: "List of errors that occurred during ingestion.",
    },
    step: {
      $ref: "#/components/schemas/JobNameMapping",
      description: "Name of the job that failed.",
    },
  },
  type: "object",
  required: ["job_id", "message", "step"],
  title: "IngestionErrorResponse",
} as const;

export const InputMessageSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "ID of the message, if any. a UUID.",
    },
    role: {
      $ref: "#/components/schemas/MessageRole",
    },
    content: {
      type: "string",
      title: "Content",
    },
    data: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Data",
      description: "Additional data to be stored with the message.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["role", "content"],
  title: "InputMessage",
  description:
    "This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend",
} as const;

export const ItemProcessingResultsResponseSchema = {
  properties: {
    item_id: {
      type: "string",
      title: "Item Id",
      description: "ID of the source item",
    },
    item_name: {
      type: "string",
      title: "Item Name",
      description: "Name of the source item",
    },
    processing_results: {
      items: {
        $ref: "#/components/schemas/ProcessingResult",
      },
      type: "array",
      title: "Processing Results",
      description: "List of all processing operations performed on this item",
    },
  },
  type: "object",
  required: ["item_id", "item_name"],
  title: "ItemProcessingResultsResponse",
  description: "Response containing all processing results for an item.",
} as const;

export const JobNameMappingSchema = {
  type: "string",
  enum: [
    "MANAGED_INGESTION",
    "DATA_SOURCE",
    "FILE_UPDATER",
    "PARSE",
    "TRANSFORM",
    "INGESTION",
    "METADATA_UPDATE",
  ],
  title: "JobNameMapping",
  description: "Enum for mapping original job names to readable names.",
} as const;

export const LLMParametersSchema = {
  properties: {
    model_name: {
      $ref: "#/components/schemas/SupportedLLMModelNames",
      description: "The name of the model to use for LLM completions.",
      default: "GPT_4O_MINI",
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
      description: "The system prompt to use for the completion.",
    },
    temperature: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Temperature",
      description: "The temperature value for the model.",
      default: 0.1,
    },
    use_chain_of_thought_reasoning: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Chain Of Thought Reasoning",
      description: "Whether to use chain of thought reasoning.",
    },
    use_citation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Citation",
      description: "Whether to show citations in the response.",
      default: true,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "LLMParameters",
} as const;

export const ListItemSchema = {
  properties: {
    type: {
      type: "string",
      const: "list",
      title: "Type",
      description: "List item type",
      default: "list",
    },
    bBox: {
      anyOf: [
        {
          prefixItems: [
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
          ],
          type: "array",
          maxItems: 4,
          minItems: 4,
        },
        {
          type: "null",
        },
      ],
      title: "Bbox",
      description: "Bounding box coordinates [x1, y1, x2, y2]",
    },
    items: {
      items: {
        anyOf: [
          {
            $ref: "#/components/schemas/TextItem",
          },
          {
            $ref: "#/components/schemas/ListItem",
          },
        ],
      },
      type: "array",
      title: "Items",
      description: "List of nested text or list items",
    },
    ordered: {
      type: "boolean",
      title: "Ordered",
      description: "Whether the list is ordered or unordered",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["items", "ordered"],
  title: "ListItem",
} as const;

export const ListingStatusDetailsSchema = {
  properties: {
    status: {
      type: "string",
      enum: ["pending", "processing", "completed", "failed"],
      title: "Status",
      description: "Status of the listing process",
      default: "pending",
    },
    effective_at: {
      type: "string",
      format: "date-time",
      title: "Effective At",
    },
    job_record_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Job Record Id",
      description: "The job record ID associated with this status, if any.",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message for the latest job attempt, if any.",
    },
  },
  type: "object",
  title: "ListingStatusDetails",
} as const;

export const LlamaParseAgenticOptionsSchema = {
  properties: {
    ignore: {
      $ref: "#/components/schemas/LlamaParseIgnoreOptions",
      description: "Options for ignoring specific text types",
    },
    ocr_parameters: {
      $ref: "#/components/schemas/LlamaParseOcrParameters",
      description: "OCR configuration parameters",
    },
    aggressive_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Aggressive Table Extraction",
      description: "Whether to use aggressive table extraction",
    },
  },
  type: "object",
  title: "LlamaParseAgenticOptions",
  description: "Options for agentic tier parsing (with AI agents).",
} as const;

export const LlamaParseCropBoxSchema = {
  properties: {
    bottom: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Bottom",
      description: "Bottom boundary of crop box as ratio (0-1)",
    },
    left: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Left",
      description: "Left boundary of crop box as ratio (0-1)",
    },
    right: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Right",
      description: "Right boundary of crop box as ratio (0-1)",
    },
    top: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Top",
      description: "Top boundary of crop box as ratio (0-1)",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseCropBox",
} as const;

export const LlamaParseEmbeddedImagesOptionsSchema = {
  properties: {
    enable: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable",
      description: "Whether this option is enabled",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseEmbeddedImagesOptions",
} as const;

export const LlamaParseExportPdfOptionsSchema = {
  properties: {
    enable: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable",
      description: "Whether this option is enabled",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseExportPdfOptions",
} as const;

export const LlamaParseFastOptionsSchema = {
  properties: {
    ignore: {
      $ref: "#/components/schemas/LlamaParseIgnoreOptions",
      description: "Options for ignoring specific text types",
    },
    ocr_parameters: {
      $ref: "#/components/schemas/LlamaParseOcrParameters",
      description: "OCR configuration parameters",
    },
    aggressive_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Aggressive Table Extraction",
      description: "Whether to use aggressive table extraction",
    },
  },
  type: "object",
  title: "LlamaParseFastOptions",
  description: "Options for fast tier parsing (without AI).",
} as const;

export const LlamaParseFileIdConfigurationSchema = {
  properties: {
    client_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Name",
      description: "Name of the client making the parsing request",
    },
    parse_options: {
      $ref: "#/components/schemas/LlamaParseTierOptions",
      description: "Parsing tier and related configuration options",
    },
    webhook_configurations: {
      items: {
        $ref: "#/components/schemas/LlamaParseWebhookConfiguration",
      },
      type: "array",
      title: "Webhook Configurations",
      description: "List of webhook configurations for notifications",
    },
    input_options: {
      $ref: "#/components/schemas/LlamaParseInputOptions",
      description: "Input format-specific parsing options",
    },
    crop_box: {
      $ref: "#/components/schemas/LlamaParseCropBox",
      description: "Document crop box boundaries",
    },
    page_ranges: {
      $ref: "#/components/schemas/LlamaParsePageRanges",
      description: "Page range selection options",
    },
    disable_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Cache",
      description: "Whether to disable caching for this parsing job",
    },
    output_options: {
      $ref: "#/components/schemas/LlamaParseOutputOptions",
      description: "Output format and styling options",
    },
    processing_control: {
      $ref: "#/components/schemas/LlamaParseProcessingControl",
      description: "Job processing control and failure handling",
    },
    file_id: {
      type: "string",
      title: "File Id",
      description: "ID of an existing file in the project to parse",
    },
  },
  type: "object",
  required: ["parse_options", "file_id"],
  title: "LlamaParseFileIdConfiguration",
  description: "Configuration schema for file ID-based parsing endpoint.",
} as const;

export const LlamaParseHtmlOptionsSchema = {
  properties: {
    make_all_elements_visible: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Make All Elements Visible",
      description: "Make all HTML elements visible during parsing",
    },
    remove_fixed_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Remove Fixed Elements",
      description: "Remove fixed position elements from HTML",
    },
    remove_navigation_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Remove Navigation Elements",
      description: "Remove navigation elements from HTML",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseHtmlOptions",
} as const;

export const LlamaParseIgnoreOptionsSchema = {
  properties: {
    ignore_diagonal_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Diagonal Text",
      description: "Whether to ignore diagonal text in the document",
    },
    ignore_strikethrough_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Strikethrough Text",
      description: "Whether to ignore strikethrough text in the document",
    },
    ignore_text_in_image: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Text In Image",
      description: "Whether to ignore text that appears within images",
    },
    ignore_hidden_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Hidden Text",
      description: "Whether to ignore hidden text in the document",
    },
  },
  type: "object",
  title: "LlamaParseIgnoreOptions",
} as const;

export const LlamaParseInputOptionsSchema = {
  properties: {
    html: {
      $ref: "#/components/schemas/LlamaParseHtmlOptions",
      description: "HTML-specific parsing options",
    },
    pdf: {
      $ref: "#/components/schemas/LlamaParsePdfOptions",
      description: "PDF-specific parsing options",
    },
    spreadsheet: {
      $ref: "#/components/schemas/LlamaParseSpreadsheetOptions",
      description: "Spreadsheet-specific parsing options",
    },
    presentation: {
      $ref: "#/components/schemas/LlamaParsePresentationOptions",
      description: "Presentation-specific parsing options",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseInputOptions",
} as const;

export const LlamaParseJobFailureConditionsSchema = {
  properties: {
    allowed_page_failure_ratio: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          exclusiveMinimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Allowed Page Failure Ratio",
      description: "Maximum ratio of pages allowed to fail (0-1)",
    },
    fail_on_image_extraction_error: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fail On Image Extraction Error",
      description: "Fail job if image extraction encounters errors",
    },
    fail_on_image_ocr_error: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fail On Image Ocr Error",
      description: "Fail job if image OCR encounters errors",
    },
    fail_on_markdown_reconstruction_error: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fail On Markdown Reconstruction Error",
      description: "Fail job if markdown reconstruction encounters errors",
    },
    fail_on_buggy_font: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fail On Buggy Font",
      description: "Fail job if buggy fonts are detected",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseJobFailureConditions",
} as const;

export const LlamaParseMarkdownOptionsSchema = {
  properties: {
    annotate_links: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Annotate Links",
      description: "Add annotations to links in markdown output",
    },
    pages: {
      $ref: "#/components/schemas/LlamaParsePages",
      description: "Page formatting options for markdown",
    },
    tables: {
      $ref: "#/components/schemas/LlamaParseTables",
      description: "Table formatting options for markdown",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseMarkdownOptions",
} as const;

export const LlamaParseOcrParametersSchema = {
  properties: {
    languages: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/ParserLanguages",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Languages",
      description: "List of languages to use for OCR processing",
    },
  },
  type: "object",
  title: "LlamaParseOcrParameters",
} as const;

export const LlamaParseOutputOptionsSchema = {
  properties: {
    markdown: {
      $ref: "#/components/schemas/LlamaParseMarkdownOptions",
      description: "Markdown output formatting options",
    },
    spatial_text: {
      $ref: "#/components/schemas/LlamaParseSpatialTextOptions",
      description: "Spatial text output options",
    },
    tables_as_spreadsheet: {
      $ref: "#/components/schemas/LlamaParseTablesAsSpreadsheetOptions",
      description: "Table export as spreadsheet options",
    },
    embedded_images: {
      $ref: "#/components/schemas/LlamaParseEmbeddedImagesOptions",
      description: "Embedded image extraction options",
    },
    screenshots: {
      $ref: "#/components/schemas/LlamaParseScreenshotsOptions",
      description: "Screenshot generation options",
    },
    export_pdf: {
      $ref: "#/components/schemas/LlamaParseExportPdfOptions",
      description: "PDF export options",
    },
    extract_printed_page_number: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Printed Page Number",
      description: "Extract printed page numbers from the document",
    },
  },
  type: "object",
  title: "LlamaParseOutputOptions",
} as const;

export const LlamaParsePageRangesSchema = {
  properties: {
    max_pages: {
      anyOf: [
        {
          type: "integer",
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
      description: "Maximum number of pages to process",
    },
    target_pages: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
      description: "Specific pages to process (e.g., '1,3,5-10')",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParsePageRanges",
} as const;

export const LlamaParsePagesSchema = {
  properties: {
    merge_tables_across_pages_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Merge Tables Across Pages In Markdown",
      description: "Merge tables that span across pages in markdown output",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParsePages",
} as const;

export const LlamaParseParametersSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    languages: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      minItems: 1,
      title: "Languages",
    },
    parsing_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsing Instruction",
      default: "",
    },
    disable_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Ocr",
      default: false,
    },
    annotate_links: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Annotate Links",
      default: false,
    },
    adaptive_long_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Adaptive Long Table",
      default: false,
    },
    compact_markdown_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Compact Markdown Table",
      default: false,
    },
    disable_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Image Extraction",
      default: false,
    },
    invalidate_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Invalidate Cache",
      default: false,
    },
    outlined_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Outlined Table Extraction",
      default: false,
    },
    aggressive_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Aggressive Table Extraction",
      default: false,
    },
    merge_tables_across_pages_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    output_pdf_of_document: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Pdf Of Document",
      default: false,
    },
    do_not_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Cache",
      default: false,
    },
    fast_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fast Mode",
      default: false,
    },
    skip_diagonal_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Skip Diagonal Text",
      default: false,
    },
    preserve_layout_alignment_across_pages: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Very Small Text",
      default: false,
    },
    gpt4o_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Api Key",
    },
    do_not_unroll_columns: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_layout: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Layout",
      default: false,
    },
    high_res_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Precise Bounding Box",
      default: false,
    },
    line_level_bounding_box: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Line Level Bounding Box",
      default: false,
    },
    html_remove_navigation_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Navigation Elements",
      default: false,
    },
    html_remove_fixed_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Fixed Elements",
      default: false,
    },
    guess_xlsx_sheet_name: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    page_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Separator",
    },
    bounding_box: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Bounding Box",
    },
    bbox_top: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Top",
    },
    bbox_right: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Right",
    },
    bbox_bottom: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Bottom",
    },
    bbox_left: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Left",
    },
    target_pages: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
    },
    use_vendor_multimodal_model: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    vendor_multimodal_model_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Model Name",
    },
    model: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model",
    },
    vendor_multimodal_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Api Key",
    },
    page_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Prefix",
    },
    page_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Suffix",
    },
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
    },
    preset: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Preset",
    },
    take_screenshot: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Take Screenshot",
      default: false,
    },
    is_formatting_instruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Is Formatting Instruction",
      default: true,
    },
    premium_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Premium Mode",
      default: false,
    },
    continuous_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Continuous Mode",
      default: false,
    },
    input_s3_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Path",
    },
    input_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Region",
    },
    output_s3_path_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Path Prefix",
    },
    output_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Region",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
    },
    azure_openai_deployment_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Endpoint",
    },
    azure_openai_api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Api Version",
    },
    azure_openai_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Key",
    },
    input_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input Url",
    },
    http_proxy: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Http Proxy",
    },
    auto_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_regexp_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_trigger_on_text_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_table_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_configuration_json: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Configuration Json",
    },
    structured_output: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema Name",
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    max_pages_enforced: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages Enforced",
    },
    extract_charts: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Charts",
      default: false,
    },
    formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Formatting Instruction",
    },
    complemental_formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Content Guideline Instruction",
    },
    spreadsheet_extract_sub_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Extract Sub Tables",
      default: false,
    },
    spreadsheet_force_formula_computation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Inline Images In Markdown",
      default: false,
    },
    job_timeout_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Save Images",
      default: true,
    },
    hide_headers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Suffix",
    },
    remove_hidden_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Remove Hidden Text",
      default: false,
    },
    keep_page_separator_when_merging_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Keep Page Separator When Merging Tables",
      default: false,
    },
    ignore_document_elements_for_layout_detection: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    output_tables_as_HTML: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Tables As Html",
      default: false,
    },
    internal_is_screenshot_job: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Internal Is Screenshot Job",
      default: false,
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
    },
    system_prompt_append: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt Append",
    },
    user_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Prompt",
    },
    page_error_tolerance: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
      default: "raw_text",
    },
    replace_failed_page_with_error_message_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Prefix",
    },
    replace_failed_page_with_error_message_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Suffix",
    },
    markdown_table_multiline_header_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Markdown Table Multiline Header Separator",
    },
    presentation_out_of_bounds_content: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Presentation Out Of Bounds Content",
      default: false,
    },
    tier: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Tier",
    },
    version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Version",
    },
    extract_printed_page_number: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Printed Page Number",
      default: false,
    },
  },
  type: "object",
  title: "LlamaParseParameters",
  description:
    "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.",
} as const;

export const LlamaParsePdfOptionsSchema = {
  properties: {},
  additionalProperties: false,
  type: "object",
  title: "LlamaParsePdfOptions",
} as const;

export const LlamaParsePresentationOptionsSchema = {
  properties: {
    out_of_bounds_content: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Out Of Bounds Content",
      description: "Extract out of bounds content in presentation slides",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParsePresentationOptions",
} as const;

export const LlamaParseProcessingControlSchema = {
  properties: {
    timeouts: {
      $ref: "#/components/schemas/LlamaParseTimeouts",
      description: "Timeout configuration for parsing jobs",
    },
    job_failure_conditions: {
      $ref: "#/components/schemas/LlamaParseJobFailureConditions",
      description: "Conditions that determine job failure",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseProcessingControl",
} as const;

export const LlamaParseScreenshotsOptionsSchema = {
  properties: {
    enable: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable",
      description: "Whether this option is enabled",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseScreenshotsOptions",
} as const;

export const LlamaParseSpatialTextOptionsSchema = {
  properties: {
    preserve_layout_alignment_across_pages: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Layout Alignment Across Pages",
      description: "Preserve text alignment across page boundaries",
    },
    preserve_very_small_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Very Small Text",
      description: "Include very small text in spatial output",
    },
    do_not_unroll_columns: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Unroll Columns",
      description: "Keep column structure intact without unrolling",
    },
    pages: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParsePages",
        },
        {
          type: "null",
        },
      ],
      description: "Page formatting options for spatial text",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseSpatialTextOptions",
} as const;

export const LlamaParseSpreadsheetOptionsSchema = {
  properties: {
    detect_sub_tables_in_sheets: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Detect Sub Tables In Sheets",
      description: "Detect and extract sub-tables within spreadsheet cells",
    },
    force_formula_computation_in_sheets: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Force Formula Computation In Sheets",
      description:
        "Force re-computation of spreadsheet cells containing formulas",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseSpreadsheetOptions",
} as const;

export const LlamaParseSupportedFileExtensionsSchema = {
  type: "string",
  enum: [
    ".pdf",
    ".doc",
    ".docx",
    ".docm",
    ".dot",
    ".dotx",
    ".dotm",
    ".rtf",
    ".wps",
    ".wpd",
    ".sxw",
    ".stw",
    ".sxg",
    ".pages",
    ".mw",
    ".mcw",
    ".uot",
    ".uof",
    ".uos",
    ".uop",
    ".ppt",
    ".pptx",
    ".pot",
    ".pptm",
    ".potx",
    ".potm",
    ".key",
    ".odp",
    ".odg",
    ".otp",
    ".fopd",
    ".sxi",
    ".sti",
    ".epub",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".bmp",
    ".svg",
    ".tiff",
    ".webp",
    ".html",
    ".htm",
    ".xls",
    ".xlsx",
    ".xlsm",
    ".xlsb",
    ".xlw",
    ".csv",
    ".dif",
    ".sylk",
    ".slk",
    ".prn",
    ".numbers",
    ".et",
    ".ods",
    ".fods",
    ".uos1",
    ".uos2",
    ".dbf",
    ".wk1",
    ".wk2",
    ".wk3",
    ".wk4",
    ".wks",
    ".wq1",
    ".wq2",
    ".wb1",
    ".wb2",
    ".wb3",
    ".qpw",
    ".xlr",
    ".eth",
    ".tsv",
  ],
  title: "LlamaParseSupportedFileExtensions",
} as const;

export const LlamaParseTablesSchema = {
  properties: {
    compact_markdown_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Compact Markdown Tables",
      description: "Use compact formatting for markdown tables",
    },
    output_tables_as_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Tables As Markdown",
      description: "Output tables in markdown format",
    },
    markdown_table_multiline_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Markdown Table Multiline Separator",
      description: "Separator for multiline content in markdown tables",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseTables",
} as const;

export const LlamaParseTablesAsSpreadsheetOptionsSchema = {
  properties: {
    enable: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable",
      description: "Whether this option is enabled",
    },
    guess_sheet_name: {
      type: "boolean",
      title: "Guess Sheet Name",
      description: "Automatically guess sheet names when exporting tables",
      default: true,
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseTablesAsSpreadsheetOptions",
} as const;

export const LlamaParseTierOptionsSchema = {
  properties: {
    tier: {
      $ref: "#/components/schemas/TierName",
      description: "The parsing tier to use",
    },
    version: {
      type: "string",
      enum: ["2025-11-18", "latest"],
      title: "Version",
      description: "Version of the tier configuration",
      default: "latest",
    },
    fast_options: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseFastOptions",
        },
        {
          type: "null",
        },
      ],
      description: "Options for fast tier parsing",
    },
    agentic_options: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseAgenticOptions",
        },
        {
          type: "null",
        },
      ],
      description: "Options for agentic tier parsing",
    },
  },
  type: "object",
  required: ["tier"],
  title: "LlamaParseTierOptions",
  description: "Base configuration for tier-based parsing.",
} as const;

export const LlamaParseTimeoutsSchema = {
  properties: {
    base_in_seconds: {
      anyOf: [
        {
          type: "integer",
          maximum: 1800,
          exclusiveMinimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Base In Seconds",
      description: "Base timeout in seconds (max 30 minutes)",
    },
    extra_time_per_page_in_seconds: {
      anyOf: [
        {
          type: "integer",
          maximum: 300,
          exclusiveMinimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Extra Time Per Page In Seconds",
      description: "Additional timeout per page in seconds (max 5 minutes)",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseTimeouts",
} as const;

export const LlamaParseUrlConfigurationSchema = {
  properties: {
    client_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Name",
      description: "Name of the client making the parsing request",
    },
    parse_options: {
      $ref: "#/components/schemas/LlamaParseTierOptions",
      description: "Parsing tier and related configuration options",
    },
    webhook_configurations: {
      items: {
        $ref: "#/components/schemas/LlamaParseWebhookConfiguration",
      },
      type: "array",
      title: "Webhook Configurations",
      description: "List of webhook configurations for notifications",
    },
    input_options: {
      $ref: "#/components/schemas/LlamaParseInputOptions",
      description: "Input format-specific parsing options",
    },
    crop_box: {
      $ref: "#/components/schemas/LlamaParseCropBox",
      description: "Document crop box boundaries",
    },
    page_ranges: {
      $ref: "#/components/schemas/LlamaParsePageRanges",
      description: "Page range selection options",
    },
    disable_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Cache",
      description: "Whether to disable caching for this parsing job",
    },
    output_options: {
      $ref: "#/components/schemas/LlamaParseOutputOptions",
      description: "Output format and styling options",
    },
    processing_control: {
      $ref: "#/components/schemas/LlamaParseProcessingControl",
      description: "Job processing control and failure handling",
    },
    source_url: {
      type: "string",
      pattern: "^https?:",
      title: "Source Url",
      description: "Source URL to fetch document from",
    },
    http_proxy: {
      anyOf: [
        {
          type: "string",
          pattern: "^https?:",
        },
        {
          type: "null",
        },
      ],
      title: "Http Proxy",
      description: "HTTP proxy URL for network requests",
    },
  },
  type: "object",
  required: ["parse_options", "source_url"],
  title: "LlamaParseUrlConfiguration",
  description: "Configuration schema for URL-based parsing endpoint.",
} as const;

export const LlamaParseWebhookConfigurationSchema = {
  properties: {
    webhook_url: {
      anyOf: [
        {
          type: "string",
          pattern: "^https?:",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
      description: "Webhook URL for receiving parsing notifications",
    },
    webhook_headers: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Headers",
      description: "Custom headers to include in webhook requests",
    },
    webhook_events: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Events",
      description: "List of events that trigger webhook notifications",
    },
  },
  additionalProperties: false,
  type: "object",
  title: "LlamaParseWebhookConfiguration",
} as const;

export const ManagedIngestionStatusSchema = {
  type: "string",
  enum: [
    "NOT_STARTED",
    "IN_PROGRESS",
    "SUCCESS",
    "ERROR",
    "PARTIAL_SUCCESS",
    "CANCELLED",
  ],
  title: "ManagedIngestionStatus",
  description: "Status of managed ingestion with partial Updates.",
} as const;

export const ManagedIngestionStatusResponseSchema = {
  properties: {
    job_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Job Id",
      description: "ID of the latest job.",
    },
    deployment_date: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Deployment Date",
      description: "Date of the deployment.",
    },
    status: {
      $ref: "#/components/schemas/ManagedIngestionStatus",
      description: "Status of the ingestion.",
    },
    error: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/IngestionErrorResponse",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Error",
      description: "List of errors that occurred during ingestion.",
    },
    effective_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Effective At",
      description: "When the status is effective",
    },
  },
  type: "object",
  required: ["status"],
  title: "ManagedIngestionStatusResponse",
} as const;

export const ManagedOpenAIEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      const: "openai-text-embedding-3-small",
      title: "Model Name",
      description: "The name of the OpenAI embedding model.",
      default: "openai-text-embedding-3-small",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "ManagedOpenAIEmbedding",
    },
  },
  type: "object",
  title: "ManagedOpenAIEmbedding",
} as const;

export const ManagedOpenAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "MANAGED_OPENAI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "MANAGED_OPENAI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/ManagedOpenAIEmbedding",
      description: "Configuration for the Managed OpenAI embedding model.",
    },
  },
  type: "object",
  title: "ManagedOpenAIEmbeddingConfig",
} as const;

export const MarkdownResultSchema = {
  properties: {
    pages: {
      items: {
        anyOf: [
          {
            $ref: "#/components/schemas/MarkdownResultPage",
          },
          {
            $ref: "#/components/schemas/FailedMarkdownPage",
          },
        ],
      },
      type: "array",
      title: "Pages",
      description: "List of markdown pages or failed page entries",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["pages"],
  title: "MarkdownResult",
} as const;

export const MarkdownResultPageSchema = {
  properties: {
    page_number: {
      type: "integer",
      title: "Page Number",
      description: "Page number of the document",
    },
    markdown: {
      type: "string",
      title: "Markdown",
      description: "Markdown content of the page",
    },
    success: {
      type: "boolean",
      const: true,
      title: "Success",
      description: "Success indicator",
      default: true,
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["page_number", "markdown"],
  title: "MarkdownResultPage",
} as const;

export const MessageAnnotationSchema = {
  properties: {
    type: {
      type: "string",
      title: "Type",
    },
    data: {
      type: "string",
      contentMediaType: "application/json",
      contentSchema: {},
      title: "Data",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["type", "data"],
  title: "MessageAnnotation",
} as const;

export const MessageRoleSchema = {
  type: "string",
  enum: [
    "system",
    "developer",
    "user",
    "assistant",
    "function",
    "tool",
    "chatbot",
    "model",
  ],
  title: "MessageRole",
  description: "Message role.",
} as const;

export const MetadataFilterSchema = {
  properties: {
    key: {
      type: "string",
      title: "Key",
    },
    value: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "number",
        },
        {
          type: "string",
        },
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          items: {
            type: "number",
          },
          type: "array",
        },
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Value",
    },
    operator: {
      $ref: "#/components/schemas/FilterOperator",
      default: "==",
    },
  },
  type: "object",
  required: ["key", "value"],
  title: "MetadataFilter",
  description: `Comprehensive metadata filter for vector stores to support more operators.

Value uses Strict types, as int, float and str are compatible types and were all
converted to string before.

See: https://docs.pydantic.dev/latest/usage/types/#strict-types`,
} as const;

export const MetadataFiltersSchema = {
  properties: {
    filters: {
      items: {
        anyOf: [
          {
            $ref: "#/components/schemas/MetadataFilter",
          },
          {
            $ref: "#/components/schemas/MetadataFilters",
          },
        ],
      },
      type: "array",
      title: "Filters",
    },
    condition: {
      anyOf: [
        {
          $ref: "#/components/schemas/FilterCondition",
        },
        {
          type: "null",
        },
      ],
      default: "and",
    },
  },
  type: "object",
  required: ["filters"],
  title: "MetadataFilters",
  description: "Metadata filters for vector stores.",
} as const;

export const NodeRelationshipSchema = {
  type: "string",
  enum: ["1", "2", "3", "4", "5"],
  title: "NodeRelationship",
  description: `Node relationships used in \`BaseNode\` class.

Attributes:
    SOURCE: The node is the source document.
    PREVIOUS: The node is the previous node in the document.
    NEXT: The node is the next node in the document.
    PARENT: The node is the parent node in the document.
    CHILD: The node is a child node in the document.`,
} as const;

export const NoneChunkingConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "none",
      title: "Mode",
      default: "none",
    },
  },
  type: "object",
  title: "NoneChunkingConfig",
} as const;

export const NoneSegmentationConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "none",
      title: "Mode",
      default: "none",
    },
  },
  type: "object",
  title: "NoneSegmentationConfig",
} as const;

export const ObjectTypeSchema = {
  type: "string",
  enum: ["1", "2", "3", "4", "5"],
  title: "ObjectType",
} as const;

export const OpenAIEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The name of the OpenAI embedding model.",
      default: "text-embedding-ada-002",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the OpenAI API.",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "The OpenAI API key.",
    },
    api_base: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Base",
      description: "The base URL for OpenAI API.",
      default: "https://api.openai.com/v1",
    },
    api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Version",
      description: "The version for OpenAI API.",
      default: "",
    },
    max_retries: {
      type: "integer",
      title: "Max Retries",
      description: "Maximum number of retries.",
      default: 10,
      gte: 0,
    },
    timeout: {
      type: "number",
      title: "Timeout",
      description: "Timeout for each request.",
      default: 60,
      gte: 0,
    },
    default_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Default Headers",
      description: "The default headers for API requests.",
    },
    reuse_client: {
      type: "boolean",
      title: "Reuse Client",
      description:
        "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
      default: true,
    },
    dimensions: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Dimensions",
      description:
        "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "OpenAIEmbedding",
    },
  },
  type: "object",
  title: "OpenAIEmbedding",
} as const;

export const OpenAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "OPENAI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "OPENAI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/OpenAIEmbedding",
      description: "Configuration for the OpenAI embedding model.",
    },
  },
  type: "object",
  title: "OpenAIEmbeddingConfig",
} as const;

export const OrganizationSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "A name for the organization.",
    },
    parse_plan_level: {
      $ref: "#/components/schemas/ParsePlanLevel",
      description:
        "[Deprecated] Whether the organization is a Parse Premium customer.",
      default: "DEFAULT",
    },
    stripe_customer_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Stripe Customer Id",
      description: "The Stripe customer ID for the organization.",
    },
    feature_flags: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Feature Flags",
      description: "Feature flags for the organization.",
    },
  },
  type: "object",
  required: ["id", "name"],
  title: "Organization",
  description: "Schema for an organization.",
} as const;

export const PGVectorDistanceMethodSchema = {
  type: "string",
  enum: ["l2", "ip", "cosine", "l1", "hamming", "jaccard"],
  title: "PGVectorDistanceMethod",
  description: `Distance methods for PGVector.
Docs:
https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options`,
} as const;

export const PGVectorHNSWSettingsSchema = {
  properties: {
    ef_construction: {
      type: "integer",
      minimum: 1,
      title: "Ef Construction",
      description: "The number of edges to use during the construction phase.",
      default: 64,
    },
    ef_search: {
      type: "integer",
      minimum: 1,
      title: "Ef Search",
      description: "The number of edges to use during the search phase.",
      default: 40,
    },
    m: {
      type: "integer",
      minimum: 1,
      title: "M",
      description:
        "The number of bi-directional links created for each new element.",
      default: 16,
    },
    vector_type: {
      $ref: "#/components/schemas/PGVectorVectorType",
      description: "The type of vector to use.",
      default: "vector",
    },
    distance_method: {
      $ref: "#/components/schemas/PGVectorDistanceMethod",
      description: "The distance method to use.",
      default: "cosine",
    },
  },
  type: "object",
  title: "PGVectorHNSWSettings",
  description: "HNSW settings for PGVector.",
} as const;

export const PGVectorVectorTypeSchema = {
  type: "string",
  enum: ["vector", "half_vec", "bit", "sparse_vec"],
  title: "PGVectorVectorType",
  description: `Vector storage formats for PGVector.
Docs:
https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options`,
} as const;

export const PageFigureMetadataSchema = {
  properties: {
    figure_name: {
      type: "string",
      title: "Figure Name",
      description: "The name of the figure",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file that the figure was taken from",
    },
    page_index: {
      type: "integer",
      minimum: 0,
      title: "Page Index",
      description:
        "The index of the page for which the figure is taken (0-indexed)",
    },
    figure_size: {
      type: "integer",
      minimum: 0,
      title: "Figure Size",
      description: "The size of the figure in bytes",
    },
    is_likely_noise: {
      type: "boolean",
      title: "Is Likely Noise",
      description: "Whether the figure is likely to be noise",
      default: false,
    },
    confidence: {
      type: "number",
      maximum: 1,
      minimum: 0,
      title: "Confidence",
      description: "The confidence of the figure",
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Metadata",
      description: "Metadata for the figure",
    },
  },
  type: "object",
  required: [
    "figure_name",
    "file_id",
    "page_index",
    "figure_size",
    "confidence",
  ],
  title: "PageFigureMetadata",
} as const;

export const PageFigureNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/PageFigureMetadata",
    },
    score: {
      type: "number",
      title: "Score",
      description: "The score of the figure node",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "PageFigureNodeWithScore",
    },
  },
  type: "object",
  required: ["node", "score"],
  title: "PageFigureNodeWithScore",
  description: "Page figure metadata with score",
} as const;

export const PageScreenshotMetadataSchema = {
  properties: {
    page_index: {
      type: "integer",
      minimum: 0,
      title: "Page Index",
      description:
        "The index of the page for which the screenshot is taken (0-indexed)",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file that the page screenshot was taken from",
    },
    image_size: {
      type: "integer",
      minimum: 0,
      title: "Image Size",
      description: "The size of the image in bytes",
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Metadata",
      description: "Metadata for the screenshot",
    },
  },
  type: "object",
  required: ["page_index", "file_id", "image_size"],
  title: "PageScreenshotMetadata",
} as const;

export const PageScreenshotNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/PageScreenshotMetadata",
    },
    score: {
      type: "number",
      title: "Score",
      description: "The score of the screenshot node",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "NodeWithScore",
    },
  },
  type: "object",
  required: ["node", "score"],
  title: "PageScreenshotNodeWithScore",
  description: "Page screenshot metadata with score",
} as const;

export const PageSegmentationConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "page",
      title: "Mode",
      default: "page",
    },
    page_separator: {
      type: "string",
      title: "Page Separator",
      default: `
---
`,
    },
  },
  type: "object",
  title: "PageSegmentationConfig",
} as const;

export const PaginatedExtractRunsResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ExtractRun",
      },
      type: "array",
      title: "Items",
      description: "The list of extraction runs",
    },
    total: {
      type: "integer",
      title: "Total",
      description: "The total number of extraction runs",
    },
    skip: {
      type: "integer",
      title: "Skip",
      description: "The number of extraction runs skipped",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "The maximum number of extraction runs returned",
    },
  },
  type: "object",
  required: ["items", "total", "skip", "limit"],
  title: "PaginatedExtractRunsResponse",
  description: "Schema for paginated extraction runs response.",
} as const;

export const PaginatedListCloudDocumentsResponseSchema = {
  properties: {
    documents: {
      items: {
        $ref: "#/components/schemas/CloudDocument",
      },
      type: "array",
      title: "Documents",
      description: "The documents to list",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "The limit of the documents",
    },
    offset: {
      type: "integer",
      title: "Offset",
      description: "The offset of the documents",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "The total number of documents",
    },
  },
  type: "object",
  required: ["documents", "limit", "offset", "total_count"],
  title: "PaginatedListCloudDocumentsResponse",
} as const;

export const PaginatedListPipelineFilesResponseSchema = {
  properties: {
    files: {
      items: {
        $ref: "#/components/schemas/PipelineFile",
      },
      type: "array",
      title: "Files",
      description: "The files to list",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "The limit of the files",
    },
    offset: {
      type: "integer",
      title: "Offset",
      description: "The offset of the files",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "The total number of files",
    },
  },
  type: "object",
  required: ["files", "limit", "offset", "total_count"],
  title: "PaginatedListPipelineFilesResponse",
} as const;

export const PaginatedResponse_AgentData_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/AgentData",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[AgentData]",
} as const;

export const PaginatedResponse_AggregateGroup_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/AggregateGroup",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[AggregateGroup]",
} as const;

export const PaginatedResponse_ClassifyJob_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ClassifyJob",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[ClassifyJob]",
} as const;

export const PaginatedResponse_SpreadsheetJob_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/SpreadsheetJob",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[SpreadsheetJob]",
} as const;

export const ParseConfigurationSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the parse configuration",
    },
    name: {
      type: "string",
      title: "Name",
      description: "Name of the parse configuration",
    },
    source_type: {
      type: "string",
      title: "Source Type",
      description: "Type of the source (e.g., 'project')",
    },
    source_id: {
      type: "string",
      title: "Source Id",
      description: "ID of the source",
    },
    creator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Creator",
      description: "Creator of the configuration",
    },
    version: {
      type: "string",
      title: "Version",
      description: "Version of the configuration",
    },
    parameters: {
      $ref: "#/components/schemas/LlamaParseParameters",
      description: "LlamaParseParameters configuration",
    },
    created_at: {
      type: "string",
      format: "date-time",
      title: "Created At",
      description: "Creation timestamp",
    },
    updated_at: {
      type: "string",
      format: "date-time",
      title: "Updated At",
      description: "Last update timestamp",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "source_type",
    "source_id",
    "version",
    "parameters",
    "created_at",
    "updated_at",
  ],
  title: "ParseConfiguration",
  description: "Parse configuration schema.",
} as const;

export const ParseConfigurationCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "Name of the parse configuration",
    },
    source_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Source Type",
      description: "Type of the source (e.g., 'project')",
    },
    source_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Source Id",
      description: "ID of the source",
    },
    creator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Creator",
      description: "Creator of the configuration",
    },
    version: {
      type: "string",
      title: "Version",
      description: "Version of the configuration",
    },
    parameters: {
      $ref: "#/components/schemas/LlamaParseParameters",
      description: "LlamaParseParameters configuration",
    },
  },
  type: "object",
  required: ["name", "version", "parameters"],
  title: "ParseConfigurationCreate",
  description: "Schema for creating a new parse configuration (API boundary).",
} as const;

export const ParseConfigurationQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ParseConfiguration",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "ParseConfigurationQueryResponse",
  description: "Response schema for paginated parse configuration queries.",
} as const;

export const ParseConfigurationUpdateSchema = {
  properties: {
    parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description: "Updated LlamaParseParameters configuration",
    },
  },
  type: "object",
  title: "ParseConfigurationUpdate",
  description: "Schema for updating an existing parse configuration.",
} as const;

export const ParsePlanLevelSchema = {
  type: "string",
  enum: ["DEFAULT", "PREMIUM"],
  title: "ParsePlanLevel",
  description: "Enum for the Parse plan level.",
} as const;

export const ParserLanguagesSchema = {
  type: "string",
  enum: [
    "af",
    "az",
    "bs",
    "cs",
    "cy",
    "da",
    "de",
    "en",
    "es",
    "et",
    "fr",
    "ga",
    "hr",
    "hu",
    "id",
    "is",
    "it",
    "ku",
    "la",
    "lt",
    "lv",
    "mi",
    "ms",
    "mt",
    "nl",
    "no",
    "oc",
    "pi",
    "pl",
    "pt",
    "ro",
    "rs_latin",
    "sk",
    "sl",
    "sq",
    "sv",
    "sw",
    "tl",
    "tr",
    "uz",
    "vi",
    "ar",
    "fa",
    "ug",
    "ur",
    "bn",
    "as",
    "mni",
    "ru",
    "rs_cyrillic",
    "be",
    "bg",
    "uk",
    "mn",
    "abq",
    "ady",
    "kbd",
    "ava",
    "dar",
    "inh",
    "che",
    "lbe",
    "lez",
    "tab",
    "tjk",
    "hi",
    "mr",
    "ne",
    "bh",
    "mai",
    "ang",
    "bho",
    "mah",
    "sck",
    "new",
    "gom",
    "sa",
    "bgc",
    "th",
    "ch_sim",
    "ch_tra",
    "ja",
    "ko",
    "ta",
    "te",
    "kn",
  ],
  title: "ParserLanguages",
  description: "Enum for representing the languages supported by the parser",
} as const;

export const ParsingJobSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
    },
    error_code: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Code",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
    },
  },
  type: "object",
  required: ["id", "status"],
  title: "ParsingJob",
} as const;

export const ParsingJobJsonResultSchema = {
  properties: {
    pages: {
      title: "Pages",
      description: "The json result of the parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["pages", "job_metadata"],
  title: "ParsingJobJsonResult",
} as const;

export const ParsingJobMarkdownResultSchema = {
  properties: {
    markdown: {
      type: "string",
      title: "Markdown",
      description: "The markdown result of the parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["markdown", "job_metadata"],
  title: "ParsingJobMarkdownResult",
} as const;

export const ParsingJobStructuredResultSchema = {
  properties: {
    structured: {
      title: "Structured",
      description: "The json result of the structured parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["structured", "job_metadata"],
  title: "ParsingJobStructuredResult",
} as const;

export const ParsingJobTextResultSchema = {
  properties: {
    text: {
      type: "string",
      title: "Text",
      description: "The text result of the parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["text", "job_metadata"],
  title: "ParsingJobTextResult",
} as const;

export const ParsingModeSchema = {
  type: "string",
  enum: [
    "parse_page_without_llm",
    "parse_page_with_llm",
    "parse_page_with_lvm",
    "parse_page_with_agent",
    "parse_page_with_layout_agent",
    "parse_document_with_llm",
    "parse_document_with_lvm",
    "parse_document_with_agent",
  ],
  title: "ParsingMode",
  description: "Enum for representing the mode of parsing to be used",
} as const;

export const PartitionNamesSchema = {
  type: "string",
  enum: [
    "data_source_id_partition",
    "pipeline_id_partition",
    "eval_dataset_id_partition",
    "file_id_partition",
    "pipeline_file_id_partition",
    "file_parsing_id_partition",
    "extraction_schema_id_partition",
  ],
  title: "PartitionNames",
  description: "Enum for dataset partition names.",
} as const;

export const PipelineSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
    embedding_model_config_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Model Config Id",
      description: "The ID of the EmbeddingModelConfig this pipeline is using.",
    },
    embedding_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/EmbeddingModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "The embedding model configuration for this pipeline.",
    },
    pipeline_type: {
      $ref: "#/components/schemas/PipelineType",
      description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
      default: "MANAGED",
    },
    managed_pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Managed Pipeline Id",
      description:
        "The ID of the ManagedPipeline this playground pipeline is linked to.",
    },
    embedding_config: {
      oneOf: [
        {
          $ref: "#/components/schemas/ManagedOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/CohereEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/GeminiEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/OpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/VertexAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/BedrockEmbeddingConfig",
        },
      ],
      title: "Embedding Config",
      discriminator: {
        propertyName: "type",
        mapping: {
          AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
          BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
          COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
          GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
          HUGGINGFACE_API_EMBEDDING:
            "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
          MANAGED_OPENAI_EMBEDDING:
            "#/components/schemas/ManagedOpenAIEmbeddingConfig",
          OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
          VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig",
        },
      },
    },
    sparse_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/SparseModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Configuration for the sparse model used in hybrid search.",
    },
    config_hash: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineConfigurationHashes",
        },
        {
          type: "null",
        },
      ],
      description: "Hashes for the configuration of the pipeline.",
    },
    transform_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/AutoTransformConfig",
        },
        {
          $ref: "#/components/schemas/AdvancedModeTransformConfig",
        },
      ],
      title: "Transform Config",
      description: "Configuration for the transformation.",
    },
    preset_retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Preset retrieval parameters for the pipeline.",
    },
    llama_parse_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description:
        "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.",
    },
    data_sink: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSink",
        },
        {
          type: "null",
        },
      ],
      description:
        "The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.",
    },
    status: {
      anyOf: [
        {
          type: "string",
          enum: ["CREATED", "DELETING"],
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline.",
    },
    metadata_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineMetadataConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Metadata configuration for the pipeline.",
    },
  },
  type: "object",
  required: ["id", "name", "project_id", "embedding_config"],
  title: "Pipeline",
  description: "Schema for a pipeline.",
} as const;

export const PipelineConfigurationHashesSchema = {
  properties: {
    embedding_config_hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config Hash",
      description: "Hash of the embedding config.",
      default: "",
    },
    parsing_config_hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsing Config Hash",
      description: "Hash of the llama parse parameters.",
      default: "",
    },
    transform_config_hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Transform Config Hash",
      description: "Hash of the transform config.",
      default: "",
    },
  },
  type: "object",
  title: "PipelineConfigurationHashes",
  description: "Hashes for the configuration of a pipeline.",
} as const;

export const PipelineCreateSchema = {
  properties: {
    embedding_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/CohereEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/GeminiEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/OpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/VertexAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/BedrockEmbeddingConfig",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              AZURE_EMBEDDING:
                "#/components/schemas/AzureOpenAIEmbeddingConfig",
              BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
              COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
              GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
              HUGGINGFACE_API_EMBEDDING:
                "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
              OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
              VERTEXAI_EMBEDDING:
                "#/components/schemas/VertexAIEmbeddingConfig",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config",
    },
    transform_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/AutoTransformConfig",
        },
        {
          $ref: "#/components/schemas/AdvancedModeTransformConfig",
        },
        {
          type: "null",
        },
      ],
      title: "Transform Config",
      description: "Configuration for the transformation.",
    },
    sparse_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/SparseModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Configuration for the sparse model used in hybrid search.",
    },
    data_sink_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Sink Id",
      description:
        "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.",
    },
    embedding_model_config_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Model Config Id",
      description:
        "Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.",
    },
    data_sink: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSinkCreate",
        },
        {
          type: "null",
        },
      ],
      description:
        "Data sink. When provided instead of data_sink_id, the data sink will be created.",
    },
    preset_retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Preset retrieval parameters for the pipeline.",
    },
    llama_parse_parameters: {
      $ref: "#/components/schemas/LlamaParseParameters",
    },
    status: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline deployment.",
    },
    metadata_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineMetadataConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Metadata configuration for the pipeline.",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
    pipeline_type: {
      $ref: "#/components/schemas/PipelineType",
      description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
      default: "MANAGED",
    },
    managed_pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Managed Pipeline Id",
      description:
        "The ID of the ManagedPipeline this playground pipeline is linked to.",
    },
  },
  type: "object",
  required: ["name"],
  title: "PipelineCreate",
  description: "Schema for creating a pipeline.",
} as const;

export const PipelineDataSourceSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
      ],
      title: "DataSourceCreateComponent",
      description: "Component that implements the data source",
    },
    version_metadata: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSourceReaderVersionMetadata",
        },
        {
          type: "null",
        },
      ],
      description: "Version metadata for the data source",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
    data_source_id: {
      type: "string",
      format: "uuid",
      title: "Data Source Id",
      description: "The ID of the data source.",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline.",
    },
    last_synced_at: {
      type: "string",
      format: "date-time",
      title: "Last Synced At",
      description: "The last time the data source was automatically synced.",
    },
    sync_interval: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Interval",
      description: "The interval at which the data source should be synced.",
    },
    sync_schedule_set_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Schedule Set By",
      description: "The id of the user who set the sync schedule.",
    },
    status: {
      anyOf: [
        {
          type: "string",
          enum: ["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "CANCELLED"],
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "The status of the data source in the pipeline.",
    },
    status_updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Status Updated At",
      description: "The last time the status was updated.",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "source_type",
    "component",
    "project_id",
    "data_source_id",
    "pipeline_id",
    "last_synced_at",
  ],
  title: "PipelineDataSource",
  description: "Schema for a data source in a pipeline.",
} as const;

export const PipelineDataSourceCreateSchema = {
  properties: {
    data_source_id: {
      type: "string",
      format: "uuid",
      title: "Data Source Id",
      description: "The ID of the data source.",
    },
    sync_interval: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Interval",
      description:
        "The interval at which the data source should be synced. Valid values are: 21600, 43200, 86400",
    },
  },
  type: "object",
  required: ["data_source_id"],
  title: "PipelineDataSourceCreate",
  description:
    "Schema for creating an association between a data source and a pipeline.",
} as const;

export const PipelineDataSourceUpdateSchema = {
  properties: {
    sync_interval: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Interval",
      description: "The interval at which the data source should be synced.",
    },
  },
  type: "object",
  title: "PipelineDataSourceUpdate",
  description:
    "Schema for updating an association between a data source and a pipeline.",
} as const;

export const PipelineFileSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "Name of the file",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "The ID of the file in the external system",
    },
    file_size: {
      anyOf: [
        {
          type: "integer",
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "File Size",
      description: "Size of the file in bytes",
    },
    file_type: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "File Type",
      description: "File type (e.g. pdf, docx, etc.)",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "The ID of the project that the file belongs to",
    },
    last_modified_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Last Modified At",
      description: "The last modified time of the file",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The ID of the file",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline that the file is associated with",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
    permission_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Permission Info",
      description: "Permission information for the file",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "Custom metadata for the file",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the file belongs to",
    },
    config_hash: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Config Hash",
      description: "Hashes for the configuration of the pipeline.",
    },
    indexed_page_count: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Indexed Page Count",
      description: "The number of pages that have been indexed for this file",
    },
    status: {
      anyOf: [
        {
          type: "string",
          enum: ["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "CANCELLED"],
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline file",
    },
    status_updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Status Updated At",
      description: "The last time the status was updated",
    },
  },
  type: "object",
  required: ["id", "pipeline_id"],
  title: "PipelineFile",
  description: "Schema for a file that is associated with a pipeline.",
} as const;

export const PipelineFileCreateSchema = {
  properties: {
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "Custom metadata for the file",
    },
  },
  type: "object",
  required: ["file_id"],
  title: "PipelineFileCreate",
  description: "Schema for creating a file that is associated with a pipeline.",
} as const;

export const PipelineFileUpdateSchema = {
  properties: {
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "Custom metadata for the file",
    },
  },
  type: "object",
  title: "PipelineFileUpdate",
  description: "Schema for updating a file that is associated with a pipeline.",
} as const;

export const PipelineMetadataConfigSchema = {
  properties: {
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      description: "List of metadata keys to exclude from embeddings",
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      description: "List of metadata keys to exclude from LLM during retrieval",
    },
  },
  type: "object",
  title: "PipelineMetadataConfig",
} as const;

export const PipelineTypeSchema = {
  type: "string",
  enum: ["PLAYGROUND", "MANAGED"],
  title: "PipelineType",
  description: "Enum for representing the type of a pipeline",
} as const;

export const PipelineUpdateSchema = {
  properties: {
    embedding_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/CohereEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/GeminiEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/OpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/VertexAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/BedrockEmbeddingConfig",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              AZURE_EMBEDDING:
                "#/components/schemas/AzureOpenAIEmbeddingConfig",
              BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
              COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
              GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
              HUGGINGFACE_API_EMBEDDING:
                "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
              OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
              VERTEXAI_EMBEDDING:
                "#/components/schemas/VertexAIEmbeddingConfig",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config",
    },
    transform_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/AutoTransformConfig",
        },
        {
          $ref: "#/components/schemas/AdvancedModeTransformConfig",
        },
        {
          type: "null",
        },
      ],
      title: "Transform Config",
      description: "Configuration for the transformation.",
    },
    sparse_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/SparseModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Configuration for the sparse model used in hybrid search.",
    },
    data_sink_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Sink Id",
      description:
        "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.",
    },
    embedding_model_config_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Model Config Id",
      description:
        "Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.",
    },
    data_sink: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSinkCreate",
        },
        {
          type: "null",
        },
      ],
      description:
        "Data sink. When provided instead of data_sink_id, the data sink will be created.",
    },
    preset_retrieval_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/PresetRetrievalParams",
        },
        {
          type: "null",
        },
      ],
      description: "Preset retrieval parameters for the pipeline.",
    },
    llama_parse_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description:
        "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.",
      deprecated: true,
    },
    status: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline deployment.",
    },
    metadata_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineMetadataConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Metadata configuration for the pipeline.",
    },
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
    },
    managed_pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Managed Pipeline Id",
      description:
        "The ID of the ManagedPipeline this playground pipeline is linked to.",
    },
  },
  type: "object",
  title: "PipelineUpdate",
  description: "Schema for updating a pipeline.",
} as const;

export const PlaygroundSessionSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
    },
    user_id: {
      type: "string",
      title: "User Id",
    },
    llm_params_id: {
      type: "string",
      format: "uuid",
      title: "Llm Params Id",
    },
    llm_params: {
      $ref: "#/components/schemas/LLMParameters",
      description: "LLM parameters last used in this session.",
    },
    retrieval_params_id: {
      type: "string",
      format: "uuid",
      title: "Retrieval Params Id",
    },
    retrieval_params: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Preset retrieval parameters last used in this session.",
    },
    chat_messages: {
      items: {
        $ref: "#/components/schemas/ChatMessage",
      },
      type: "array",
      title: "Chat Messages",
      description: "Chat message history for this session.",
    },
  },
  type: "object",
  required: [
    "id",
    "pipeline_id",
    "user_id",
    "llm_params_id",
    "retrieval_params_id",
  ],
  title: "PlaygroundSession",
  description: "A playground session for a user.",
} as const;

export const PoolingSchema = {
  type: "string",
  enum: ["cls", "mean", "last"],
  title: "Pooling",
  description: "Enum of possible pooling choices with pooling behaviors.",
} as const;

export const PresetRetrievalParamsSchema = {
  properties: {
    dense_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Top K",
      description: "Number of nodes for dense retrieval.",
      default: 30,
    },
    dense_similarity_cutoff: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Cutoff",
      description: "Minimum similarity score wrt query for retrieval",
      default: 0,
    },
    sparse_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Sparse Similarity Top K",
      description: "Number of nodes for sparse retrieval.",
      default: 30,
    },
    enable_reranking: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable Reranking",
      description: "Enable reranking for retrieval",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description: "Number of reranked nodes for returning.",
      default: 6,
    },
    alpha: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Alpha",
      description:
        "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.",
    },
    search_filters: {
      anyOf: [
        {
          $ref: "#/components/schemas/MetadataFilters",
        },
        {
          type: "null",
        },
      ],
      description: "Search filters for retrieval.",
    },
    search_filters_inference_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Search Filters Inference Schema",
      description:
        "JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.",
    },
    files_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 5,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Files Top K",
      description:
        "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
      default: 1,
    },
    retrieval_mode: {
      $ref: "#/components/schemas/RetrievalMode",
      description: "The retrieval mode for the query.",
      default: "chunks",
    },
    retrieve_image_nodes: {
      type: "boolean",
      title: "Retrieve Image Nodes",
      description: "Whether to retrieve image nodes.",
      default: false,
      deprecated: true,
    },
    retrieve_page_screenshot_nodes: {
      type: "boolean",
      title: "Retrieve Page Screenshot Nodes",
      description: "Whether to retrieve page screenshot nodes.",
      default: false,
    },
    retrieve_page_figure_nodes: {
      type: "boolean",
      title: "Retrieve Page Figure Nodes",
      description: "Whether to retrieve page figure nodes.",
      default: false,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "PresetRetrievalParams",
  description:
    "Schema for the search params for an retrieval execution that can be preset for a pipeline.",
} as const;

export const PresignedUrlSchema = {
  properties: {
    url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Url",
      description: "A presigned URL for IO operations against a private file",
    },
    expires_at: {
      type: "string",
      format: "date-time",
      title: "Expires At",
      description: "The time at which the presigned URL expires",
    },
    form_fields: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Form Fields",
      description: "Form fields for a presigned POST request",
    },
  },
  type: "object",
  required: ["url", "expires_at"],
  title: "PresignedUrl",
  description: "Schema for a presigned URL.",
} as const;

export const ProcessingResultSchema = {
  properties: {
    result_id: {
      type: "string",
      title: "Result Id",
      description: "Unique identifier for this result",
    },
    item_id: {
      type: "string",
      title: "Item Id",
      description: "Source item that was processed",
    },
    job_type: {
      $ref: "#/components/schemas/BatchJobType",
      description: "Type of processing performed",
    },
    job_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/BatchParseJobRecordCreate",
        },
        {
          $ref: "#/components/schemas/ClassifyJob",
        },
      ],
      title: "Job Config",
      description: "Job configuration used for processing",
    },
    parameters_hash: {
      type: "string",
      title: "Parameters Hash",
      description: "Hash of parameters for deduplication",
    },
    output_s3_path: {
      type: "string",
      title: "Output S3 Path",
      description: "S3 location of processing output",
    },
    output_metadata: {
      anyOf: [
        {
          $ref: "#/components/schemas/ProcessingResultMetadata",
        },
        {
          type: "null",
        },
      ],
      description: "Summary statistics about the output",
    },
    processed_at: {
      type: "string",
      format: "date-time",
      title: "Processed At",
      description: "When this processing occurred",
    },
  },
  type: "object",
  required: [
    "result_id",
    "item_id",
    "job_type",
    "job_config",
    "parameters_hash",
    "output_s3_path",
    "processed_at",
  ],
  title: "ProcessingResult",
  description: "A processing result with lineage information.",
} as const;

export const ProcessingResultMetadataSchema = {
  properties: {},
  type: "object",
  title: "ProcessingResultMetadata",
  description: `Metadata about processing output.

Currently empty - will be populated with job-type-specific metadata fields in the future.`,
} as const;

export const ProjectSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    ad_hoc_eval_dataset_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Ad Hoc Eval Dataset Id",
    },
    organization_id: {
      type: "string",
      format: "uuid",
      title: "Organization Id",
      description: "The Organization ID the project is under.",
    },
    is_default: {
      type: "boolean",
      title: "Is Default",
      description: "Whether this project is the default project for the user.",
      default: false,
    },
  },
  type: "object",
  required: ["name", "id", "organization_id"],
  title: "Project",
  description: "Schema for a project.",
} as const;

export const PublicModelNameSchema = {
  type: "string",
  enum: [
    "openai-gpt-4o",
    "openai-gpt-4o-mini",
    "openai-gpt-4-1",
    "openai-gpt-4-1-mini",
    "openai-gpt-4-1-nano",
    "openai-gpt-5",
    "openai-gpt-5-mini",
    "openai-gpt-5-nano",
    "openai-text-embedding-3-large",
    "openai-text-embedding-3-small",
    "openai-whisper-1",
    "anthropic-sonnet-3.5",
    "anthropic-sonnet-3.5-v2",
    "anthropic-sonnet-3.7",
    "anthropic-sonnet-4.0",
    "anthropic-sonnet-4.5",
    "anthropic-haiku-3.5",
    "anthropic-haiku-4.5",
    "gemini-2.5-flash",
    "gemini-3.0-pro",
    "gemini-2.5-pro",
    "gemini-2.0-flash",
    "gemini-2.0-flash-lite",
    "gemini-2.5-flash-lite",
    "gemini-1.5-flash",
    "gemini-1.5-pro",
  ],
  title: "PublicModelName",
  description: "Public model names.",
} as const;

export const ReRankConfigSchema = {
  properties: {
    top_n: {
      type: "integer",
      title: "Top N",
      description:
        "The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      default: 6,
      gte: 1,
    },
    type: {
      $ref: "#/components/schemas/ReRankerType",
      description: "The type of reranker to use.",
      default: "system_default",
    },
  },
  type: "object",
  title: "ReRankConfig",
} as const;

export const ReRankerTypeSchema = {
  type: "string",
  enum: ["system_default", "llm", "cohere", "bedrock", "score", "disabled"],
  title: "ReRankerType",
  description: "Enum for the reranker type.",
} as const;

export const RelatedNodeInfoSchema = {
  properties: {
    node_id: {
      type: "string",
      title: "Node Id",
    },
    node_type: {
      anyOf: [
        {
          $ref: "#/components/schemas/ObjectType",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Node Type",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
    },
    hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Hash",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "RelatedNodeInfo",
    },
  },
  type: "object",
  required: ["node_id"],
  title: "RelatedNodeInfo",
} as const;

export const RetrievalModeSchema = {
  type: "string",
  enum: ["chunks", "files_via_metadata", "files_via_content", "auto_routed"],
  title: "RetrievalMode",
} as const;

export const RetrievalParamsSchema = {
  properties: {
    dense_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Top K",
      description: "Number of nodes for dense retrieval.",
      default: 30,
    },
    dense_similarity_cutoff: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Cutoff",
      description: "Minimum similarity score wrt query for retrieval",
      default: 0,
    },
    sparse_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Sparse Similarity Top K",
      description: "Number of nodes for sparse retrieval.",
      default: 30,
    },
    enable_reranking: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable Reranking",
      description: "Enable reranking for retrieval",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description: "Number of reranked nodes for returning.",
      default: 6,
    },
    alpha: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Alpha",
      description:
        "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.",
    },
    search_filters: {
      anyOf: [
        {
          $ref: "#/components/schemas/MetadataFilters",
        },
        {
          type: "null",
        },
      ],
      description: "Search filters for retrieval.",
    },
    search_filters_inference_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Search Filters Inference Schema",
      description:
        "JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.",
    },
    files_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 5,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Files Top K",
      description:
        "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
      default: 1,
    },
    retrieval_mode: {
      $ref: "#/components/schemas/RetrievalMode",
      description: "The retrieval mode for the query.",
      default: "chunks",
    },
    retrieve_image_nodes: {
      type: "boolean",
      title: "Retrieve Image Nodes",
      description: "Whether to retrieve image nodes.",
      default: false,
      deprecated: true,
    },
    retrieve_page_screenshot_nodes: {
      type: "boolean",
      title: "Retrieve Page Screenshot Nodes",
      description: "Whether to retrieve page screenshot nodes.",
      default: false,
    },
    retrieve_page_figure_nodes: {
      type: "boolean",
      title: "Retrieve Page Figure Nodes",
      description: "Whether to retrieve page figure nodes.",
      default: false,
    },
    query: {
      type: "string",
      minLength: 1,
      title: "Query",
      description: "The query to retrieve against.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["query"],
  title: "RetrievalParams",
  description: "Schema for the search params for an retrieval execution.",
} as const;

export const RetrieveResultsSchema = {
  properties: {
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description:
        "The ID of the pipeline that the query was retrieved against.",
    },
    retrieval_nodes: {
      items: {
        $ref: "#/components/schemas/TextNodeWithScore",
      },
      type: "array",
      title: "Retrieval Nodes",
      description: "The nodes retrieved by the pipeline for the given query.",
    },
    image_nodes: {
      items: {
        $ref: "#/components/schemas/PageScreenshotNodeWithScore",
      },
      type: "array",
      title: "Image Nodes",
      description:
        "The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.",
      deprecated: true,
    },
    page_figure_nodes: {
      items: {
        $ref: "#/components/schemas/PageFigureNodeWithScore",
      },
      type: "array",
      title: "Page Figure Nodes",
      description:
        "The page figure nodes retrieved by the pipeline for the given query.",
    },
    retrieval_latency: {
      additionalProperties: {
        type: "number",
      },
      type: "object",
      title: "Retrieval Latency",
      description: "The end-to-end latency for retrieval and reranking.",
    },
    metadata: {
      additionalProperties: {
        type: "string",
      },
      type: "object",
      title: "Metadata",
      description: "Metadata associated with the retrieval execution",
    },
    inferred_search_filters: {
      anyOf: [
        {
          $ref: "#/components/schemas/MetadataFilters",
        },
        {
          type: "null",
        },
      ],
      description: "The inferred search filters for the query.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "RetrieveResults",
    },
  },
  type: "object",
  required: ["pipeline_id", "retrieval_nodes"],
  title: "RetrieveResults",
  description: "Schema for the result of an retrieval execution.",
} as const;

export const RetrieverSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description:
        "A name for the retriever tool. Will default to the pipeline name if not provided.",
    },
    pipelines: {
      items: {
        $ref: "#/components/schemas/RetrieverPipeline",
      },
      type: "array",
      title: "Pipelines",
      description: "The pipelines this retriever uses.",
    },
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project this retriever resides in.",
    },
  },
  type: "object",
  required: ["name", "id", "project_id"],
  title: "Retriever",
  description:
    "An entity that retrieves context nodes from several sub RetrieverTools.",
} as const;

export const RetrieverCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description:
        "A name for the retriever tool. Will default to the pipeline name if not provided.",
    },
    pipelines: {
      items: {
        $ref: "#/components/schemas/RetrieverPipeline",
      },
      type: "array",
      title: "Pipelines",
      description: "The pipelines this retriever uses.",
    },
  },
  type: "object",
  required: ["name"],
  title: "RetrieverCreate",
} as const;

export const RetrieverPipelineSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description:
        "A name for the retriever tool. Will default to the pipeline name if not provided.",
    },
    description: {
      anyOf: [
        {
          type: "string",
          maxLength: 15000,
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "A description of the retriever tool.",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline this tool uses.",
    },
    preset_retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Parameters for retrieval configuration.",
    },
  },
  type: "object",
  required: ["name", "description", "pipeline_id"],
  title: "RetrieverPipeline",
} as const;

export const RetrieverUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "A name for the retriever.",
    },
    pipelines: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/RetrieverPipeline",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Pipelines",
      description: "The pipelines this retriever uses.",
    },
  },
  type: "object",
  required: ["pipelines"],
  title: "RetrieverUpdate",
} as const;

export const SearchRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          additionalProperties: {
            $ref: "#/components/schemas/FilterOperation",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filter",
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "The agent deployment's name to search within",
    },
    collection: {
      type: "string",
      title: "Collection",
      description: "The logical agent data collection to search within",
      default: "default",
    },
    include_total: {
      type: "boolean",
      title: "Include Total",
      description:
        "Whether to include the total number of items in the response",
      default: false,
    },
    offset: {
      anyOf: [
        {
          type: "integer",
          maximum: 1000,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Offset",
      description:
        "The offset to start from. If not provided, the first page is returned",
      default: 0,
    },
  },
  type: "object",
  required: ["deployment_name"],
  title: "SearchRequest",
  description: "API request body for searching agent data",
} as const;

export const SemanticChunkingConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "semantic",
      title: "Mode",
      default: "semantic",
    },
    buffer_size: {
      type: "integer",
      title: "Buffer Size",
      default: 1,
    },
    breakpoint_percentile_threshold: {
      type: "integer",
      title: "Breakpoint Percentile Threshold",
      default: 95,
    },
  },
  type: "object",
  title: "SemanticChunkingConfig",
} as const;

export const SentenceChunkingConfigSchema = {
  properties: {
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      default: 200,
      gte: 0,
    },
    mode: {
      type: "string",
      const: "sentence",
      title: "Mode",
      default: "sentence",
    },
    separator: {
      type: "string",
      title: "Separator",
      default: " ",
    },
    paragraph_separator: {
      type: "string",
      title: "Paragraph Separator",
      default: `


`,
    },
  },
  type: "object",
  title: "SentenceChunkingConfig",
} as const;

export const SparseModelConfigSchema = {
  properties: {
    model_type: {
      $ref: "#/components/schemas/SparseModelType",
      description:
        "The sparse model type to use. 'bm25' uses Qdrant's FastEmbed BM25 model (default for new pipelines), 'splade' uses HuggingFace Splade model, 'auto' selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade).",
      default: "bm25",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "SparseModelConfig",
    },
  },
  type: "object",
  title: "SparseModelConfig",
  description: `Configuration for sparse embedding models used in hybrid search.

This allows users to choose between Splade and BM25 models for
sparse retrieval in managed data sinks.`,
} as const;

export const SparseModelTypeSchema = {
  type: "string",
  enum: ["splade", "bm25", "auto"],
  title: "SparseModelType",
  description: `Enum for sparse model types supported in LlamaCloud.

SPLADE: Uses HuggingFace Splade model for sparse embeddings
BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)`,
} as const;

export const SplitCategorySchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 200,
      minLength: 1,
      title: "Name",
      description: "Name of the category.",
    },
    description: {
      anyOf: [
        {
          type: "string",
          maxLength: 2000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description:
        "Optional description of what content belongs in this category.",
    },
  },
  type: "object",
  required: ["name"],
  title: "SplitCategory",
  description: "Category definition for document splitting.",
} as const;

export const SplitCreateRequestSchema = {
  properties: {
    document_input: {
      $ref: "#/components/schemas/SplitDocumentInput",
      description: "Document to be split.",
    },
    categories: {
      items: {
        $ref: "#/components/schemas/SplitCategory",
      },
      type: "array",
      maxItems: 50,
      minItems: 1,
      title: "Categories",
      description: "Categories to split the document into.",
    },
    splitting_strategy: {
      $ref: "#/components/schemas/SplitStrategy",
      description: "Strategy for splitting the document.",
    },
  },
  type: "object",
  required: ["document_input", "categories"],
  title: "SplitCreateRequest",
  description: "Request to create a document split job.",
} as const;

export const SplitDocumentInputSchema = {
  properties: {
    type: {
      type: "string",
      title: "Type",
      description: "Type of document input. Valid values are: file_id",
    },
    value: {
      type: "string",
      title: "Value",
      description: "Document identifier.",
    },
  },
  type: "object",
  required: ["type", "value"],
  title: "SplitDocumentInput",
  description: "Document input specification.",
} as const;

export const SplitJobQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/SplitJobResponse",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "SplitJobQueryResponse",
  description: "Paginated list of split jobs.",
} as const;

export const SplitJobResponseSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the split job.",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "Project ID this job belongs to.",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "User ID who created this job.",
    },
    document_input: {
      $ref: "#/components/schemas/SplitDocumentInput",
      description: "Document that was split.",
    },
    categories: {
      items: {
        $ref: "#/components/schemas/SplitCategory",
      },
      type: "array",
      title: "Categories",
      description: "Categories used for splitting.",
    },
    status: {
      type: "string",
      title: "Status",
      description:
        "Current status of the job. Valid values are: pending, processing, completed, failed.",
    },
    result: {
      anyOf: [
        {
          $ref: "#/components/schemas/SplitResultResponse",
        },
        {
          type: "null",
        },
      ],
      description: "Split result (available when status is COMPLETED).",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
      description: "Error message if the job failed.",
    },
  },
  type: "object",
  required: [
    "id",
    "project_id",
    "user_id",
    "document_input",
    "categories",
    "status",
  ],
  title: "SplitJobResponse",
  description: "A document split job.",
} as const;

export const SplitResultResponseSchema = {
  properties: {
    segments: {
      items: {
        $ref: "#/components/schemas/SplitSegmentResponse",
      },
      type: "array",
      title: "Segments",
      description: "List of document segments.",
    },
  },
  type: "object",
  required: ["segments"],
  title: "SplitResultResponse",
  description: "Result of a completed split job.",
} as const;

export const SplitSegmentResponseSchema = {
  properties: {
    category: {
      type: "string",
      title: "Category",
      description: "Category name this split belongs to.",
    },
    pages: {
      items: {
        type: "integer",
      },
      type: "array",
      title: "Pages",
      description: "1-indexed page numbers in this split.",
    },
    confidence_category: {
      type: "string",
      title: "Confidence Category",
      description:
        "Categorical confidence level. Valid values are: high, medium, low.",
    },
  },
  type: "object",
  required: ["category", "pages", "confidence_category"],
  title: "SplitSegmentResponse",
  description: "A segment of the split document.",
} as const;

export const SplitStrategySchema = {
  properties: {
    allow_uncategorized: {
      type: "boolean",
      title: "Allow Uncategorized",
      description:
        "Whether to allow pages that don't match any category to be grouped as 'uncategorized'. If False, all pages must be assigned to a defined category.",
      default: false,
    },
  },
  type: "object",
  title: "SplitStrategy",
  description: "Configuration for how to split the document.",
} as const;

export const SpreadsheetJobSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "The ID of the job",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The ID of the user",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project",
    },
    config: {
      $ref: "#/components/schemas/SpreadsheetParsingConfig",
      description: "Configuration for the parsing job",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
      description: "The status of the parsing job",
    },
    created_at: {
      type: "string",
      title: "Created At",
      description: "When the job was created",
    },
    updated_at: {
      type: "string",
      title: "Updated At",
      description: "When the job was last updated",
    },
    success: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Success",
      description: "Whether the job completed successfully",
    },
    regions: {
      items: {
        $ref: "#/components/schemas/ExtractedRegionSummary",
      },
      type: "array",
      title: "Regions",
      description: "All extracted regions (populated when job is complete)",
    },
    worksheet_metadata: {
      items: {
        $ref: "#/components/schemas/WorksheetMetadata",
      },
      type: "array",
      title: "Worksheet Metadata",
      description:
        "Metadata for each processed worksheet (populated when job is complete)",
    },
    errors: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Errors",
      description: "Any errors encountered",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The ID of the input file",
    },
    file: {
      anyOf: [
        {
          $ref: "#/components/schemas/File",
        },
        {
          type: "null",
        },
      ],
      description: "The file that was parsed",
      deprecated: true,
    },
  },
  type: "object",
  required: [
    "id",
    "user_id",
    "project_id",
    "config",
    "status",
    "created_at",
    "updated_at",
    "file_id",
  ],
  title: "SpreadsheetJob",
  description: "A spreadsheet parsing job",
} as const;

export const SpreadsheetJobCreateSchema = {
  properties: {
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file to parse",
    },
    config: {
      $ref: "#/components/schemas/SpreadsheetParsingConfig",
      description: "Configuration for the parsing job",
    },
  },
  type: "object",
  required: ["file_id"],
  title: "SpreadsheetJobCreate",
  description: "Request to create a spreadsheet parsing job",
} as const;

export const SpreadsheetParsingConfigSchema = {
  properties: {
    sheet_names: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Sheet Names",
      description:
        "The names of the sheets to extract regions from. If empty, all sheets will be processed.",
    },
    include_hidden_cells: {
      type: "boolean",
      title: "Include Hidden Cells",
      description:
        "Whether to include hidden cells when extracting regions from the spreadsheet.",
      default: true,
    },
    extraction_range: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Extraction Range",
      description:
        "A1 notation of the range to extract a single region from. If None, the entire sheet is used.",
    },
    generate_additional_metadata: {
      type: "boolean",
      title: "Generate Additional Metadata",
      description:
        "Whether to generate additional metadata (title, description) for each extracted region.",
      default: true,
    },
    use_experimental_processing: {
      type: "boolean",
      title: "Use Experimental Processing",
      description: "Enables experimental processing. Accuracy may be impacted.",
      default: false,
    },
  },
  type: "object",
  title: "SpreadsheetParsingConfig",
  description: "Configuration for spreadsheet parsing and region extraction",
} as const;

export const SpreadsheetResultTypeSchema = {
  type: "string",
  enum: ["table", "extra", "cell_metadata"],
  title: "SpreadsheetResultType",
} as const;

export const StatusEnumSchema = {
  type: "string",
  enum: ["PENDING", "SUCCESS", "ERROR", "PARTIAL_SUCCESS", "CANCELLED"],
  title: "StatusEnum",
  description: "Enum for representing the status of a job",
} as const;

export const StructuredResultSchema = {
  properties: {
    pages: {
      items: {
        anyOf: [
          {
            $ref: "#/components/schemas/StructuredResultPage",
          },
          {
            $ref: "#/components/schemas/FailedStructuredPage",
          },
        ],
      },
      type: "array",
      title: "Pages",
      description: "List of structured pages or failed page entries",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["pages"],
  title: "StructuredResult",
} as const;

export const StructuredResultPageSchema = {
  properties: {
    page_number: {
      type: "integer",
      title: "Page Number",
      description: "Page number of the document",
    },
    items: {
      items: {
        oneOf: [
          {
            $ref: "#/components/schemas/TextItem",
          },
          {
            $ref: "#/components/schemas/HeadingItem",
          },
          {
            $ref: "#/components/schemas/ListItem",
          },
          {
            $ref: "#/components/schemas/CodeItem",
          },
          {
            $ref: "#/components/schemas/TableItem",
          },
          {
            $ref: "#/components/schemas/ImageItem",
          },
        ],
        discriminator: {
          propertyName: "type",
          mapping: {
            code: "#/components/schemas/CodeItem",
            heading: "#/components/schemas/HeadingItem",
            image: "#/components/schemas/ImageItem",
            list: "#/components/schemas/ListItem",
            table: "#/components/schemas/TableItem",
            text: "#/components/schemas/TextItem",
          },
        },
      },
      type: "array",
      title: "Items",
      description: "List of structured items on the page",
    },
    success: {
      type: "boolean",
      const: true,
      title: "Success",
      description: "Success indicator",
      default: true,
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["page_number", "items"],
  title: "StructuredResultPage",
} as const;

export const SupportedLLMModelNamesSchema = {
  type: "string",
  enum: [
    "GPT_4O",
    "GPT_4O_MINI",
    "GPT_4_1",
    "GPT_4_1_NANO",
    "GPT_4_1_MINI",
    "AZURE_OPENAI_GPT_4O",
    "AZURE_OPENAI_GPT_4O_MINI",
    "AZURE_OPENAI_GPT_4_1",
    "AZURE_OPENAI_GPT_4_1_MINI",
    "AZURE_OPENAI_GPT_4_1_NANO",
    "CLAUDE_3_5_SONNET",
    "CLAUDE_4_5_SONNET",
    "BEDROCK_CLAUDE_3_5_SONNET_V1",
    "BEDROCK_CLAUDE_3_5_SONNET_V2",
    "VERTEX_AI_CLAUDE_3_5_SONNET_V2",
  ],
  title: "SupportedLLMModelNames",
} as const;

export const TableItemSchema = {
  properties: {
    type: {
      type: "string",
      const: "table",
      title: "Type",
      description: "Table item type",
      default: "table",
    },
    bBox: {
      anyOf: [
        {
          prefixItems: [
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
          ],
          type: "array",
          maxItems: 4,
          minItems: 4,
        },
        {
          type: "null",
        },
      ],
      title: "Bbox",
      description: "Bounding box coordinates [x1, y1, x2, y2]",
    },
    rows: {
      items: {
        items: {
          type: "string",
        },
        type: "array",
      },
      type: "array",
      title: "Rows",
      description: "Table data as array of string arrays",
    },
    html: {
      type: "string",
      title: "Html",
      description: "HTML representation of the table",
    },
    md: {
      type: "string",
      title: "Md",
      description: "Markdown representation of the table",
    },
    csv: {
      type: "string",
      title: "Csv",
      description: "CSV representation of the table",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["rows", "html", "md", "csv"],
  title: "TableItem",
} as const;

export const TextItemSchema = {
  properties: {
    type: {
      type: "string",
      const: "text",
      title: "Type",
      description: "Text item type",
      default: "text",
    },
    bBox: {
      anyOf: [
        {
          prefixItems: [
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
            {
              type: "number",
            },
          ],
          type: "array",
          maxItems: 4,
          minItems: 4,
        },
        {
          type: "null",
        },
      ],
      title: "Bbox",
      description: "Bounding box coordinates [x1, y1, x2, y2]",
    },
    value: {
      type: "string",
      title: "Value",
      description: "Text content",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["value"],
  title: "TextItem",
} as const;

export const TextNodeSchema = {
  properties: {
    id_: {
      type: "string",
      title: "Id",
      description: "Unique ID of the node.",
    },
    embedding: {
      anyOf: [
        {
          items: {
            type: "number",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding",
      description: "Embedding of the node.",
    },
    extra_info: {
      additionalProperties: true,
      type: "object",
      title: "Extra Info",
      description: "A flat dictionary of metadata fields",
    },
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      description:
        "Metadata keys that are excluded from text for the embed model.",
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      description: "Metadata keys that are excluded from text for the LLM.",
    },
    relationships: {
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/components/schemas/RelatedNodeInfo",
          },
          {
            items: {
              $ref: "#/components/schemas/RelatedNodeInfo",
            },
            type: "array",
          },
        ],
      },
      propertyNames: {
        $ref: "#/components/schemas/NodeRelationship",
      },
      type: "object",
      title: "Relationships",
      description: "A mapping of relationships to other node information.",
    },
    metadata_template: {
      type: "string",
      title: "Metadata Template",
      description:
        "Template for how metadata is formatted, with {key} and {value} placeholders.",
      default: "{key}: {value}",
    },
    metadata_seperator: {
      type: "string",
      title: "Metadata Seperator",
      description:
        "Separator between metadata fields when converting to string.",
      default: `
`,
    },
    text: {
      type: "string",
      title: "Text",
      description: "Text content of the node.",
      default: "",
    },
    mimetype: {
      type: "string",
      title: "Mimetype",
      description: "MIME type of the node content.",
      default: "text/plain",
    },
    start_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Start Char Idx",
      description: "Start char index of the node.",
    },
    end_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "End Char Idx",
      description: "End char index of the node.",
    },
    text_template: {
      type: "string",
      title: "Text Template",
      description:
        "Template for how text is formatted, with {content} and {metadata_str} placeholders.",
      default: `{metadata_str}

{content}`,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "TextNode",
    },
  },
  type: "object",
  title: "TextNode",
  description: `Provided for backward compatibility.

Note: we keep the field with the typo "seperator" to maintain backward compatibility for
serialized objects.`,
} as const;

export const TextNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/TextNode",
    },
    score: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Score",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "TextNodeWithScore",
    },
  },
  type: "object",
  required: ["node"],
  title: "TextNodeWithScore",
  description: `Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
FastAPI doesn't accept abstract classes like BaseNode.`,
} as const;

export const TextResultSchema = {
  properties: {
    pages: {
      items: {
        $ref: "#/components/schemas/TextResultPage",
      },
      type: "array",
      title: "Pages",
      description: "List of text pages",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["pages"],
  title: "TextResult",
} as const;

export const TextResultPageSchema = {
  properties: {
    page_number: {
      type: "integer",
      title: "Page Number",
      description: "Page number of the document",
    },
    text: {
      type: "string",
      title: "Text",
      description: "Plain text content of the page",
    },
  },
  additionalProperties: false,
  type: "object",
  required: ["page_number", "text"],
  title: "TextResultPage",
} as const;

export const TierNameSchema = {
  type: "string",
  enum: ["fast", "cost_effective", "agentic", "agentic_plus"],
  title: "TierName",
  description: "Enum for representing the tier names",
} as const;

export const TokenChunkingConfigSchema = {
  properties: {
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      default: 200,
      gte: 0,
    },
    mode: {
      type: "string",
      const: "token",
      title: "Mode",
      default: "token",
    },
    separator: {
      type: "string",
      title: "Separator",
      default: " ",
    },
  },
  type: "object",
  title: "TokenChunkingConfig",
} as const;

export const UsageMetricSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The system-generated UUID for the metric",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The ID of the user",
    },
    event_type: {
      type: "string",
      enum: [
        "pages_indexed",
        "pages_embedded",
        "pages_parsed",
        "set_total_pages_indexed",
        "set_total_indexes",
        "layout_extracted",
        "layout_aware_parsing",
        "layout_aware_chart_extraction",
        "chart_parsing_agentic",
        "chart_parsing_plus",
        "chart_parsing_efficient",
        "image_classified",
        "precise_bbox_extraction",
        "audio_seconds_parsed",
        "extraction_num_pages",
        "extraction_num_pages_parsed",
      ],
      title: "Event Type",
      description: "The event type that is emitted",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "The project ID",
    },
    organization_id: {
      type: "string",
      title: "Organization Id",
      description: "The organization ID",
    },
    value: {
      type: "integer",
      title: "Value",
      description: "The unit measurement associated with the event type",
    },
    properties: {
      additionalProperties: true,
      type: "object",
      title: "Properties",
      description: "Properties associated with the metric",
    },
    day: {
      type: "string",
      title: "Day",
      description:
        "The day the metric was emitted [UTC], in the format 'YYYY-MM-DD'",
    },
    event_aggregation_key: {
      type: "string",
      title: "Event Aggregation Key",
      description: "The source job identifier, i.e. job_id or file_id",
    },
    event_aggregation_type: {
      type: "string",
      title: "Event Aggregation Type",
      description: "The source job aggregation type, i.e. pdf",
    },
  },
  type: "object",
  required: [
    "id",
    "user_id",
    "event_type",
    "project_id",
    "organization_id",
    "value",
    "day",
    "event_aggregation_key",
    "event_aggregation_type",
  ],
  title: "UsageMetric",
  description: "API boundary representation of a usage metric.",
} as const;

export const UsageMetricQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/UsageMetric",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "UsageMetricQueryResponse",
  description: "Paginated response containing usage metrics.",
} as const;

export const ValidationErrorSchema = {
  properties: {
    loc: {
      items: {
        anyOf: [
          {
            type: "string",
          },
          {
            type: "integer",
          },
        ],
      },
      type: "array",
      title: "Location",
    },
    msg: {
      type: "string",
      title: "Message",
    },
    type: {
      type: "string",
      title: "Error Type",
    },
  },
  type: "object",
  required: ["loc", "msg", "type"],
  title: "ValidationError",
} as const;

export const VertexAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "VERTEXAI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "VERTEXAI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/VertexTextEmbedding",
      description: "Configuration for the VertexAI embedding model.",
    },
  },
  type: "object",
  title: "VertexAIEmbeddingConfig",
} as const;

export const VertexEmbeddingModeSchema = {
  type: "string",
  enum: ["default", "classification", "clustering", "similarity", "retrieval"],
  title: "VertexEmbeddingMode",
  description: `Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.`,
} as const;

export const VertexTextEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the VertexAI model to use.",
      default: "textembedding-gecko@003",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    location: {
      type: "string",
      title: "Location",
      description: "The default location to use when making API calls.",
    },
    project: {
      type: "string",
      title: "Project",
      description:
        "The default GCP project to use when making Vertex API calls.",
    },
    embed_mode: {
      $ref: "#/components/schemas/VertexEmbeddingMode",
      description: "The embedding mode to use.",
      default: "retrieval",
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the Vertex.",
    },
    client_email: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Email",
      description: "The client email for the VertexAI credentials.",
    },
    token_uri: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Token Uri",
      description: "The token URI for the VertexAI credentials.",
    },
    private_key_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Private Key Id",
      description: "The private key ID for the VertexAI credentials.",
    },
    private_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Private Key",
      description: "The private key for the VertexAI credentials.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "VertexTextEmbedding",
    },
  },
  type: "object",
  required: [
    "location",
    "project",
    "client_email",
    "token_uri",
    "private_key_id",
    "private_key",
  ],
  title: "VertexTextEmbedding",
} as const;

export const WebhookConfigurationSchema = {
  properties: {
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
      description: "The URL to send webhook notifications to.",
    },
    webhook_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Headers",
      description: "Custom HTTP headers to include with webhook requests.",
    },
    webhook_events: {
      anyOf: [
        {
          items: {
            type: "string",
            enum: [
              "extract.pending",
              "extract.success",
              "extract.error",
              "extract.partial_success",
              "extract.cancelled",
              "parse.pending",
              "parse.success",
              "parse.error",
              "parse.partial_success",
              "parse.cancelled",
              "unmapped_event",
            ],
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Events",
      description: "List of event names to subscribe to",
    },
    webhook_output_format: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Output Format",
      description:
        "The output format to use for the webhook. Defaults to string if none supplied. Currently supported values: string, json",
    },
  },
  type: "object",
  title: "WebhookConfiguration",
  description:
    "Allows the user to configure webhook options for notifications and callbacks.",
} as const;

export const WorksheetMetadataSchema = {
  properties: {
    sheet_name: {
      type: "string",
      title: "Sheet Name",
      description: "Name of the worksheet",
    },
    title: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Title",
      description: "Generated title for the worksheet",
    },
    description: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "Generated description of the worksheet",
    },
  },
  type: "object",
  required: ["sheet_name"],
  title: "WorksheetMetadata",
  description: "Metadata about a worksheet in a spreadsheet",
} as const;
